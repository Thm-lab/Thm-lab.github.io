---
title: 进程管理
date: 2023-02-10 13:05:39
author: Thm
tags: Operating System
math: true
katex: true
mermaid: true
---
# 进程管理

## 描述与控制
进程的**定义**: 
- 一个**正在执行的程序**
- 一个**正在**计算机上执行的**程序实例**
- 能**分配给处理器并由处理器执行的实体**
- 由一组执行的**指令**、一个**当前状态**和一组相关的**系统资源**表征的活动单元

进程的**基本特征**: 
- **动态性(本质特性)**: 正在计算机上执行的程序实例，**存在生命周期**
- **并发性(重要特性)**: 任何进程都可以同其他进程**一起**向前推进
- **独立性**: 各进程的**地址空间相互独立**，除非采用进程间通信手段
- **异步性**: 按**各自独立的、不可预知**的速度向前推进

进程与程序的**区别**: 
<b>

- 程序是静态的，而进程是动态的
- 进程包括了程序相关的数据
- 一个应用程序的执行可能有多个进程

</b>

### 进程结构
**进程 = 程序代码 + 相关数据 + 进程控制块(PCB, Process Control Block)**
**进程映像(Process Image) = 程序代码段 + 数据 + PCB + 栈**
![进程映像在虚存中结构](process_image.png)

#### PCB
进程控制块**包含了充分的信息**， 因此可以中断一个进程的执行，并在后来恢复进程的执行，就好像进程未被中断过那样，PCB是OS**支持多进程并提供多重处理技术**的关键工具

**PCB的内容**: 
<b>

- 进程标识信息
- 处理器状态信息
- 进程控制信息

</b>

##### 进程标识信息
操作系统控制的许多表可以使用**进程标识符**来引用进程表
- 说明内存、I/O设备和文件分配给了**哪个进程**
- 内存表、I/O和文件表都可以引用进程标识符，进而交叉引用**进程表**
- 进程通信时，标识通信目标
- 指明每个进程的父进程和子进程

**典型进程标识信息**: 
- **唯一的进程ID**
- **父进程(创建该进程的进程)ID**
- **用户ID**

##### 处理器状态信息
包括**通用寄存器内容**与**标志寄存器内容**，可以帮助处理器**恢复现场**

**典型处理器状态信息**: 
- **用户可见寄存器**内容: 部分通用寄存器(**IA-32的EAX、EBX、ECX、EDX、ESI、EDI**)
- **栈寄存器**内容: 每个进程有一个或多个与之相关联的后进先出(LIFO)系统栈，栈用于保存参数和过程调用或系统调用的地址(**IA-32的ESP、EBP**)
- **标志寄存器**内容: 程序计数器(**EIP**)和条件码寄存器(**EFLAGS**)

##### 进程控制信息
是操作系统**控制和协调各种活动进程所需的额外信息**

**典型进程控制信息**: 
- **调度和状态**信息: 
  - **进程状态**：如运行态、就绪态、等待态、停止态
  - **优先级**：描述进程调度优先级的一个或多个域
  - **调度相关信息**：具体取决于所用的调度算法，如进程等待的时间总量和进程上次运行的执行时间总量
  - **事件**：进程在继续执行前等待的事件标识
- **数据结构**信息: 进程可以以排队、环或其他数据结构链接到其他进程(如链表指向的下一个进程ID)
- **进程间通信**: 各种标记、信号和信息可与两个无关进程间的通信关联
- **进程特权**: 进程根据其可以访问的内存和可执行的指令类型来赋予特权
- **存储管理**: 包括指向描述分配给该进程的虚存的段表和/或页表的指针
- **资源所有权和使用情况**: 指示进程控制的资源(IO资源等)

### 进程状态

#### 两状态模型
![两状态模型](two_state_process_model.png)

- **创建**: 一个新进程添加到正被管理的进程集时，操作系统需要**建立用于管理该进程的数据结构(PCB)**，并**在内存中给它分配地址空间**，这些行为构成了一个新进程的创建过程
  ![创建进程原因](enter.png)
- **终止**: 由**批处理程序显式调用**或**用户指出进程**何时结束，或**进程进行非法操作时由OS进行终止**
  ![终止进程原因](exit.png)

![两状态模型排队](two_state_process_queuing.png)
当多进程需要处理时，未运行进程在**创建队列进行排队**

#### 五状态模型
![五状态模型](five_state_process_model.png)

- **新建(New)**: 刚刚创建的进程，操作系统还**未把它加入可执行进程组**，它通常是**进程控制块己经创建但还未加载到内存中的新进程**
- **就绪(Ready)**: 进程做好了准备，**只要有机会就开始执行**
- **阻塞(Blocked)**: 进程**在某些事件发生前不能执行**，如I/O操作完成
- **运行(Runing)**: 处理器**正在执行该进程**
- **退出(Eixt)**: 操作系统**从可执行进程组中释放出的进程**，要么它自身**已停止**，要么它因某种原因**被取消**

![单阻塞队列](single_blocked_queue.png)
**单阻塞队列: 所有阻塞进程位于一个阻塞队列**

![多阻塞队列](multiple_blocked_queue.png)
**多阻塞队列: 不同事件对应一个阻塞队列**

![五状态模型转换示例](five_state_process_model_example.png)

<span style="color:#ff562b"><b>多队列思想同样可以用于就绪队列！从而对就绪进程进行优先级分级</b></span>

#### 带挂起状态模型
![单挂起态模型](one_suspended_model.png)
![双挂起态模型](two_suspended_model.png)
- **就绪/挂起(Ready/Suspended)**: 进程**己在外存**中，但只要**载入内存就可执行**
- **阻塞/挂起(Blocked/Suspended)**: 进程**己在外存中并等待一个事件**

![挂起进程原因](suspend.png)

### 进程控制
操作系统采用表格(或数据结构)来**记载各资源的信息**，从而实现对资源的管理、维护、更新等，同时进程表必须能被操作系统所访问，因此其**受制于内存管理**
![进程表](process_table.png)

#### 操作系统内核
OS内核是**操作系统中包含重要系统功能的部分**，并且需要**常驻内存，便于提高操作系统运行效能**

**内核功能**: 
- **资源管理功能**
  - 进程管理: 进程的创建、终止、调度、分派、切换、通信等
  - 存储管理: 内存管理和内外存交换
  - I/O设备管理: 缓冲区管理和I/O通道的分配
- **支撑功能**
  - 中断处理
  - 时钟管理
  - 记账功能

**处理器模式**: 
- **用户模式**: 具有较少优先权的模式，运行用户程序
- **内核模式**: 运行操作系统的内核，执行某些特权指令，访问某些内存空间

使用两种模式可以**保护操作系统和重要的操作系统表(如PCB)不受程序干扰**

#### 进程创建
当出现了需要创建进程的情况时，操作系统将按以下步骤创建一个新进程
![进程创建](creat_process.png)

#### 进程切换
进程切换指的是**操作系统中断一个正在运行的进程，将另一个进程置于运行模式，并把控制权交给后者**

![进程切换原因](process_switch_reason.png)

[异常和中断的区别](https://thm-lab.github.io/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/#cpu%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86)详见计组

但是！**中断不一定会引起进程切换**，例如I/O中断由CPU执行中断处理程序后仍然有可能切换为原进程
然而**进程切换一定会引起模式切换**，因为**进程切换需要切换到内核模式下完成进程调度**

进程切换的**步骤**: 
1. **保存处理器上下文环境**，包括程序计数器和其它寄存器
2. **更新当前处于运行状态进程的进程控制块**
3. 将进程的**进程控制块移至相应队列**(就绪、阻塞、就绪/挂起等)
4. **选择另一进程执行**
5. **更新其进程控制块信息**
6. **更新内存管理数据结构**
7. **恢复**被选择进程的**上下文环境**，如载入程序计数器和其他寄存器先前的值

#### 模式切换
模式切换指**用户模式和内核模式之间的相互转换**

由用户模式切到内核模式的原因: 
- **系统调用**: 是操作系统提供给用户程序**访问系统内核功能的接口**，用户程序通过调用系统调用来获取操作系统提供的服务，服务完成后返回应用程序
- **中断**: 以便中断处理能执行特权指令

然而**模式切换不一定会引起进程切换**，某些系统调用(如getpid)就不会导致进程切换

### Unix SVR4的进程管理
![Unix进程状态转换](unix_process_state_model.png)

**进程创建**由**内核系统调用fork()实现**
fork()调用后的步骤: 
1. 在**进程表中**为新进程**分配一个空项**
2. 为子进程**分配一个唯一的进程标识符**
3. **复制**父进程的**进程映象**，但共享内存除外
4. **增加父进程**所拥有的**文件的计数器**，反映另一个进程现在也拥有这些文件的事实
5. **将子进程设置为就绪态**
6. **将子进程的ID号返回给父进程，将0值返回给子进程**

**fork()创建子进程之后，父进程和子进程均在下一条语句上继续运行**
**fork()创建子进程之后，执行返回父进程，或调度切换到子进程或其他进程(与OS的调度算法有关)**

``` c
#include<stdio.h>
#Include<sys/types.h>
#include<unistd.h>

void main(void) {
  printf("Hello\n");
  fork(); 
  printf("Bye\n");
}
```
输出: 
``` shell
Hello
Bye
Bye
```

``` c
#include <stdio.h>
#include <unistd.h>
int main() {
  int i;
  for (i=0;i<3;i++)
    fork();
    printf("hello, world\n");
    return 0;
}

```
输出: 共$2^3=8$个`hello, world`(8个进程，每个进程打印一个)
``` shell
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
```

``` c
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int global = 4;
int main(void) {
  int  pid;
  int vari = 5;
  printf("before fork\n");

  if ((pid = fork()) < 0) {
      printf("fork error\n");
      
  } else if (pid == 0) {
  global++;
  vari--;
  printf("child\n");
  }
 printf("global=%d,vari=%d\n", global, vari);
 return 0;
}
```
输出: 因为子进程是**复制**了父进程的**进程映像**(除共享空间外)，因此**不会影响父进程的数据**，**子进程数据为自己独有**
``` shell
before fork
global=4,vari=5
child
global=5,vari=4
```

### 线程
进程的**2个基本属性**: 
- **进程是拥有资源的独立单位**
- **进程是调度/执行的基本单位**，挂起进程会导致内部所有线程被挂起，终止进程会导致内部所有线程被终止，因此线程只是独立调度和分配的基本单位

**线程**是进程中的一个实体，**是独立调度和分配的基本单位**
![线程](thread.png)
- 单进程单线程: MS Dos等
- 单进程多线程: JVM(Java虚拟机)等
- 多进程单线程: 传统Unix等
- 多进程多线程: 现在操作系统(Windows、Solaris)等

![多线程模型](multithreaded_process_model.png)
进程内可能有多个线程，每个线程都有**包含线程信息的TCB**(Thread Control Block)、线程**代码**、**局部变量的静态存储空间**、**执行栈**和**与进程内其他线程共享的内存和资源访问**

线程的**优点**: 
- **创建时间短**
- **终止时间短**
- **切换时间短**
- 执行程序间的通信效率高(**进程通信难度大于线程通信**)

![多线程示例](multithreaded_process_example.png)

#### 线程分类
可以分为: 
- **用户级线程(ULT)**
- **内核级线程(KLT)**
- 混合方法

##### ULT
![用户级线程](ULT.png)
**线程由用户自己管理(创建、终止、调度、挂起)**，OS不知道有线程存在

##### KLT
![内核级线程](KLT.png)
线程管理由OS进行，应用程序无法参与线程管理

##### 不同类型线程优缺点
| 线程类型 | 用户级                                                                                                         | 内核级                                                                                                                                                                                   | 混合方法                                                                                                                                                                             |
| -------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 优点     | **线程切换不需要内核模式特权**<br>**调度策略因应用程序不同而不同**<br>**可以运行在任何操作系统上**             | 内核可以把同一个进程内的**多个线程调度到多处理器上**，**提高并发性**<br>**当一个线程阻塞时，内核可以调度同一进程内的其他线程**<br>**内核例程本身也可以是多线程的，提高了内核的运行效率** | **线程创建在用户空间完成**(开销小，不需要模式切换)<br>**线程调度和同步也由应用程序完成**(开销小，不需要模式切换)<br>**一个应用程序中的多个线程被映射到一些**(小于或等于用户级线程数) |
| 缺点     | 当用户级线程执行系统调用时，不仅阻塞当前线程，还**将引起同一进程中的其他线程阻塞**<br>**不能利用多处理器技术** | 把控制权从一个线程传递到相同进程内的另一个线程时，需要**切换到内核模式**(**由OS进行线程切换**)                                                                                           |                                                                                                                                                                                      |


## 调度

## 同步

## 死锁