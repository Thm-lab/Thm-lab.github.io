---
title: 软件工程
date: 2023-01-06 15:01:37
author: Thm
tags: Software Engineering
math: true
katex: true
mermaid: true
---

# 软件工程

## 概论

### 软件的定义
<b>软件定义: 软件 = 程序 + 数据 + 文档</b>

- 程序: 按事先设计的**功能**和**性能**需求执行的**指令序列**
- 数据: 是程序能正常操纵信息的**数据结构**
- 文档: 与**程序开发**、**维护**和**使用**有关的**图文材料**

**文档的作用**
- 提高软件开发过程的**能见度**；
- **记录**开发过程的**有关信息**，便于使用与维护；
- 提高开发**效率**；
- 作为开发人员**阶段工作成果和结束标志**；
- 提供软件运行、维护、培训有关**资料**；
- 便于**用户了解**软件功能和性能；

### 软件的特点
软件是逻辑的，而不是物理的，其特点如下: 
- 软件是**开发的或者是工程化**的，**并不是制造的**
- 软件**开发环境**对产品影响较大
- 软件开发时间和工作量**难以估计**
- 软件会**多次修改**
- 软件的开发进度几何**没有客观衡量标准**
- 软件测试困难
- 软件**不会磨损和老化**
- 软件维护易产生新的问题
- 软件生产是简单的拷贝


### 软件的双重作用
软件的双重作用是指软件具有**两种角色**，软件即是一种**产品**，也是**开发其他软件产品的工具**
- 作为产品，软件扮演着信息转换的角色，产生、管理、查询、修改、显示、传递信息。如应用软件(office)等
- 作为产品生产的载体，软件提供了计算机控制、信息通信以及应用程序开发和控制的基础平台。如操作系统(Windows)、软件开发工具(IDE)等


### 软件危机
<b>软件危机的定义: 是指在软体开发及维护的过程中所遇到的一系列严重问题，比如软件开发周期长、软件开发成本高、软件质量差、软件维护难</b>

软件危机的**具体表现**为: 
- 开发成本和进度估计不准，**开发进度难以控制**(开发难)
- 软件**开发生产率滞后**于硬件和计算机应用普及(周期长)
- 软件成本逐年上升(**成本高**)
- **用户对已完成的软件系统不满意(质量差)**
- 软件质量和可靠性差强人意(**质量差**)
- 软件常常是不可维护的(**维护难**)
- 软件通常没有适当的文档资料(**维护难、使用难**)

### 软件工程
软件工程是为了**应对软件危机**在实践中总结出来的**开发软件的成功技术和方法**。其认为软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。

#### 定义
<b>软件工程的定义: 将系统化的、科学化的、可量化的方法应用于软件的开发、运行和维护，即针对软件的工程应用以及对上述方法的研究。</b>

#### 目标
<b>软件工程的目标是在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。</b>

#### 原则
1. 使用**阶段性生命周期计划的管理**
2. 进行**连续的验证**
3. 保证**严格的产品控制**
4. 使用**现代编程工具/工程**实践
5. 保持清晰的**责任分配**
6. 用**更好更少**的人
7. 保持**过程改进**

#### 对软件工程的误解
1. Question: 如果项目进度落后了，可以加入更多的程序员来赶进度？
   Answer: 软件开发的机制和手工作业不一样。在一个延迟了的软件项目中**加入新的开发人员只会让它延迟更多**
2. Question: 如果我们将软件项目外包给第三方，我们就轻松了，让那个公司去完成它吧
   Answer: 如果组织管理方不懂得如何**从内部管理和控制软件项目**，即使将项目外包也无济于事
3. Question: 对目标的一般陈述就足以开始编程，我们可以今后再补充细节
   Answer: 前期糟糕的项目需求定义，是导致软件失败的主要原因。项目需求的确在不断变化,但**变化所产生的影响是根据变化提出的时间不同而不同的**
4. Question: 一旦我们编程完毕并成功运行，我们的工作就结束了
   Answer: 越早开始写代码，我们就会花费越长的时间去完成它。工业数据显示，**软件开发60%-80%的精力将耗费在软件首次提交给用户以后**
5. Question: 当我的程序运行之前，我没有办法评估它的质量
   Answer: 一个最有效的**软件质量保证机制应当在项目的正式开始启动时**——可以通过技术报告体现
6. Question: 唯一可交付的工作成果是一个成功运行的项目程序
   Answer: 一个可运行的程序**只是软件结构的一部分**，它还包含了许多其它因素**比如开发文档、使用文档等**
7. Question: 软件工程将会让我们去创建大量不必要的文档，并且总是使我们的进度放慢。软件工程仅仅是文档而已
   Answer: **所有的文档都是提高团队沟通和质量所必须的**

## 软件过程
由软件工程出现的原因可以知道: 
- 软件工程的**中心**: **质量**

实现软件工程的**三要素**: 
- **过程**
- **方法**
- **工具**

本章节即详细讲述软件工程的要素之一: 过程

### 软件过程的概念
软件过程是指开发和维护软件及其相关产品所涉及的一系列**活动**


**术语解读:** 
- **任务: 将输入转化为输出的操作**
- **活动: 一系列任务的集合**
- **过程: 不同的活动按一定顺序排列的集合**

![软件过程](process.png)

### 基本软件过程
软件过程多样，但所有过程都具有以下共同活动: 
1. **沟通**: 包括软件设计者与客户沟通，客户提出要求，软件设计者收集材料，以及其它相关活动
2. **计划**: 软件开发小组讨论使用何种方法及何种工具来实现客户需求
3. **建模**: 软件开发小组根据需求讨论选择何种模型来满足需求
4. **构造**: 编码和测试
5. **部署**: 软件交付给客户，客户给出建议和反馈，软件实施小组改进软件

一个典型的基本软件过程: 
{% mermaid %}
graph LR
    RA("需求分析")-->SD("软件设计")
    SD-->SC("软件编码")
    SC-->ST("软件测试")
{% endmermaid %}
- 需求分析: 解决现实世界某个问题的软件产品及其约束的描述，要求**输出编制软件需求说明书或初步的系统用户手册**
- 软件设计: 分为**概要设计**和**详细设计**两个活动，要求**输出概要设计说明书与详细设计说明书**
  - 概要设计: **把各项需求转换成软件的体系结构**，结构中每个部分都是一个模块，每个模块都与某些需求相对应
  - 详细设计: **对每个模块要完成的工作进行具体描述**，为源程序编写打下基础
- 软件编码: 将软件设计转换成结构良好、清晰易读，且与设计相一致的计算机可以运行的**程序代码**，要求**提交源程序清单与可执行程序模块**
- 软件测试: 通过测试来判断一个软件是否满足规定的功能和性能要求，发现软件所存在的问题，避免出现缺陷导致事故，分为**单元测试**和**组装测试**，要求**提交软件评测报告**
  - 单元测试: 检测**各模块**在功能和结构上存在的问题并加以纠正
  - 组装测试: 将已测试通过的模块**按一定顺序组装起来**，**按规定的各项需求，逐项进行有效性测试**，决定已开发的软件是否合格，能否交付给用户使用

### 软件过程模型
定义: 是软件开发**全部过程、活动和任务的结构框架**。**它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略**。

常见过程模型主要为3类: 
- 瀑布模型: 
- 演化模型
- 增量过程模型

#### 瀑布模型
瀑布模型的**开发过程与软件生命周期是一致的**，也称经典的生命周期模型。其规定了各项软件工程活动，以及它们**自上而下，相互衔接的固定次序**，如同瀑布流水，逐级下落。

{% gi 2 2 %}
  ![传统瀑布模型](Waterfall_Model1.jpg)
  ![迭代瀑布模型](Waterfall_Model2.jpg)
{% endgi %}

瀑布模型的**特点**: 
- 阶段间具有**顺序性**和**依赖性**，过程**透明性高**，过程**可管理性高**
- **推迟实现**的观点: 软件实现前必须进行系统分析和设计工作
- **质量保证**的观点
  - 每个阶段**必须完成规定的文档**，没有交出合格的文档就是没有完成该阶段的任务；
  - 每个阶段**结束前**都要对所完成的文档进行**评审**，以便尽早发现问题，改正错误；

瀑布模型的**缺点**: 
- 不够灵活(需求不明确时难以调整)
- 整体性太强(风险高)
- 严格的文档驱动，比较繁琐

瀑布模型适用的场景: 系统**需求明确**、**技术成熟**、工**程管理较严格**

#### 演化模型
由于**准确的需求很难一次获得**、**软件很难一次开发成功**的事实，瀑布模型并不能适用于大部分场景，因此产生了**演化模型**。
演化模型的基本思想为: 倡导**多次迭代开发**，前期得到实验性的**原型产品**，探索可行性，理清需求，后期再前期基础上**优化完善**得到满意的产品

演化模型中可将常见的分为3类: 
- **快速原型模型**
- **并行开发模型**
- **基于构件模型**

本节以**快速原型模型**作为主要内容进行介绍。

快速原型模型作为演化模型的一种，其生命周期与瀑布模型自然有所不同，由于演化模型的思想在于**多次迭代开发**，因此**快速原型模型的生命周期是一个循环周期**，由某种条件控制循环的结束。
![快速原型模型](prototype.jfif)

快速原型模型的**优点**: 
- **强调用户参与和决策**，强化了用户与开发人员的沟通
- 可**加快需求的确定**，能够处理需求的不确定性和风险
- **简化了项目管理**、**缩短了开发时间**、**降低了风险和开发成本**

快速原型模型的**缺点**: 
- **不适用于开发大型系统**
- 软件**可维护性差**
- **用户合作要求高**，如果合作不好，反而会拖延开发进度

快速原型模型适用的场景: 
- **客户或领域专家不熟悉电脑/软件**
- **需求、技术不明确**
- **软件人员不熟悉领域,沟通理解困难**

#### 增量过程模型
增量过程模型是一种**非整体开发**的模型、**进化式的开发过程**，其允许从**部分需求定义**出发，先建立一个**不完整的系统**，通过测试运行取得经验和反馈，然后进一步**扩充和完善**该系统。反复进行，直至软件人员和用户满意为止。

**演化模型与增量过程模型的异同**: 
演化模型和增量过程模型都是进行**多次开发**，而瀑布模型是**一次开发**即可完成系统，但演化模型与增量过程模型**不同之处**在于演化模型根据原型每次的开发结果是一个**整系统**，而增量过程模型的阶段开发结果可以是**不完整系统**。

本节通过**增量模型**和**螺旋模型**来对增量过程模型进行介绍。

**增量模型**
增量模型结合了**原型模型的基本要素和迭代的特征**，采用了**基于时间的线性序列**，每个确定线性序列都会输出该软件的一个**增量**，每个增量都是小而可用的软件
![增量模型](incremental.png)

增量模型的**特点**: 
- 在前面增量的基础上开发后面的增量
- 每个增量的开发可用瀑布或快速原型模型
- 迭代的思路

增量模型的**优点**: 
- 引入增量包概念，**不需要提供完整的需求**。只要有一个增量包出现，开发就可以进行
- 在项目的初始阶段**不需要投入太多的人力资源**
- 增量可以**有效地管理技术风险**，**降低系统失败风险**
- 有利于增加客户信心，**提高系统可靠性、可维护性和稳定性**


增量模型的**缺点**: 
- **增量粒度难以选择**，因为每个增量必须提供一些系统功能
- 确定所有的基本业务比较困难

增量模型适用的场景: 
- **需求比较明确**
- **架构比较稳定**，每次增量不影响架构

**螺旋模型**
螺旋模型**结合了瀑布模型**和**原型模型**的特点，并且**强调风险管理**
![螺旋模型](spiral.png)
螺旋模型沿着螺线旋转，在笛卡尔坐标的四个象限上分别表达了四个方面的活动: 
- 制定计划: **确定软件目标**，选定实施方案，弄清项目开发的限制条件
- 风险分析: **分析所选方案风险**，考虑如何识别和消除风险
- 实施工程: 实施**软件开发**
- 客户评估: **评价开发工作，提出修正建议**

螺旋模型的**优点**: 
- 支持**用户需求的动态变化**
- **原型可看作可执行的需求规格说明书**
- 强调**原型的可扩充性和可修改性**
- 为项目管理人员及时调整管理决策提供了方便，进而可**降低开发风险**

螺旋模型的**缺点**: 
- 如果每次**迭代的效率不高**，致使迭代次数过多，将会**增加成本并推迟提交时间**
- 要求**开发队伍水平较高**

螺旋模型适用的场景: 
- **需求不明确**
- **大规模软件开发**
- **高风险项目**

#### 四种模型总结
<table style="border-collapse:collapse;border-color:#9ABAD9;border-spacing:0" class="tg"><thead><tr><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">模型</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">描述</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">优点</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">缺点</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">应用场景</th></tr></thead><tbody><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">瀑布模型<br>Waterfall Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">过程划为计划,需求,设计,编码,测试,维护阶段<br>各阶段自上而下,相互衔接固定次序,如同瀑布流水<br>各阶段评审确认通过,前阶段输出是后阶段输入<br><b>文档驱动(Document Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">利于大型软件项目中人员的组织与管理<br>利于开发方法工具的研究和使用<br>提高大型项目中的高发效率与质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">呈线性,成果未经测试时,用户看不到结果,增加风险<br>前阶段未发现的错误传到后阶段甚至扩散,可导致项目失败.<br>需求阶段,完全确定需求比较困难</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">大型软件项目<br>需求明确<br>需求很少变更</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">快速原型模型<br>Rapid Prototype Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">快速建造初步非完整软件原型,实现客户与系统交互<br>客户对原型评价,细化需求<br>逐步调整原型满足要求,原型内部结构不重要<br><b>原型驱动(Prototype Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">确定客户真正需求,减少需求不明确<br>更好和客户沟通,提高客户对软件满意度<br>减少技术,应用风险,缩小成本,提高产品质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">需要尽可能尽快建造软件原型,可能会限制开发人员创新<br>所选技术工具不一定符合主流<br>原型快速建立的内部结构及连续修改可能致产品设计差<br>客户确定真正需求,原型可能被弃</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">客户或领域专家不熟悉电脑/软件<br>软件人员不熟悉领域,沟通理解困难<br></td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">增量模型<br>Incremental Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">分阶段实现,软件增量设计,实现,集成,测试<br>整个产品拆成多个构件,分次逐个构件交付可运行产品<br><b>功能驱动(Function Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">较好适应变化<br>客户看到不断变化软件,降低开发风险<br>鼓舞团队的士气</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">容易退化成边做边改,失去对软件过程的整体控制<br>不破坏现有架构<br>产品,架构不是开放的,维护难度加大</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">需求比较明确<br>架构比较稳定,每次增量不影响架构</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">螺旋模型<br>Spiral Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">分成计划,评估,设计实施,用户反馈四个象限<br>沿着螺线进行若干次迭代<br>关注风险,风险分析后决策项目是否继续<br><b>风险驱动(Risk Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">强调可选方案及约束条件支持软件重用<br>助于提升软件质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">要求客户接受相信其风险分析,并作出反应不容易<br>风险分析成本&gt;项目利润,项目风险分析无意义<br>要善于识别风险,且准确,否则将带来更大风险</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">大规模软件开发<br>高风险项目</td></tr></tbody></table>

**增量模型和螺旋模型的异同点**
- 相同
    - 都是非整体的**迭代式**的开发方式
- 不同
    - 两者迭代的层级不同
        - 增量：**活动级**的迭代
        - 螺旋：**过程级**的迭代
    - 需求分析时间不同
        - 增量：先做总体需求分析和设计，在编码和测试**逐个的增量包**开发
        - 螺旋：开发周期内采用**瀑布模型**
    - 交互软件的不同
        - 增量：每次增量开发都在上一次增量的基础上提交**新的一部分**的软件
        - 螺旋：每次迭代都提交一个**新的完整**的软件版本
    - 减少风险的方式不用
        - 增量：**避免使用未成熟技术**，和经常的客户反馈减少风险
        - 螺旋：直接引入**风险分析**

### 软件过程成熟度模型(Capatility Maturity Model)
**软件过程成熟度模型**是软件行业标准模型，**用来定义和评价软件企业开发过程的成熟度**，提供如何做才能提高软件质量的指导。
该模型可以说明一个特定的**软件过程**被显示地**定义**、**管理**、**度量**、**控制**和**执行**的程度，可用于指示企业加强其**软件过程能力**的潜力
CMM分为**5个**层级，分别为: 
- **初始级: 有能力的人和个人英雄主义**
- **可重复级: 基本项目管理**
- **已定义级: 过程标准化**
- **量化管理级: 量化管理**
- **优化级: 持续的过程改进**

![软件过程成熟度模型](CMM.png)

### 过程与产品关系
软件开发中有两种倾向: 
- **以产品为中心**，主要关心最终产品
- **以过程为中心**，强调软件过程的重要性(**软件工程强调该倾向**)

一般来说，软件过程决定了软件产品的质量，不同的项目需要不同的过程模型或模型的组合。

## 需求分析

### 需求的定义
- 软件需求表达了对解决现实世界中某类问题的产品的**要求**和**约束**
- 确定**系统必须具有的功能和性能**，系统要求的**运行环境**，并且预测系统发展的前景
- 需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的**陈述的一个集合**

### 需求的特性
- 可验证性: **需求是测试的依据**，因此需求必须具有可以被验证的性质
- 可量化性: **需求的表述应该是量化的**，如"软件应该对用户是友好的"即是不可量化的表述，而"在任何营业时间内出现一个致命错误的可能性低于$1\times 10^{-8}$"则是量化的表述
- 优先级: 需求应当根据紧迫程度和现有资源确定**优先级**

### 需求的分类
需求可以分为**功能性需求**和**非功能性需求**两种
- 功能性需求: **描述系统应该做什么**，即为用户和其它系统完成的功能、提供的服务，如**输入**、**输出**、**计算**、**数据存储**等
- 非功能性需求: 指解决问题时的**约束**，按约束类型不同可以细分为: **可靠性需求**、**可用性需求**、**性能需求**、**可维护性需求**
   - 可靠性: 如"机场雷达系统一个月内不能出现2次以上故障"
   - 可用性: 如"系统出错后可以允许的最大恢复时间"
   - 性能: 如"应力分析程序必须在一分种内生成任何一个梁的应力报告"
   - 可维护性: 如"有健全程序的文档"

### 需求分析过程
完整的需求分析过程分为4个步骤: 
- 需求获取: **收集需求**
- 需求提炼(**也名需求分析**): **根据需求产生操作规格参数表**，指明与其他系统元件的**软件接口**，确定软件必须遵循的**约束**
- 需求描述(**也名需求定义**): 撰写需求规格说明书
- 需求验证: **检查需求的正确性、完整性、非二义性、内部和外部的连贯性**

#### 需求获取

**需求获取的任务**
- **发现和分析问题**，并分析问题的原因/结果关系
- 与用户进行各种方式的交流，并使用调查研究方法**收集信息**
- 按照三个成分(即**数据**、**过程**和**接口**)观察问题的不同侧面
- 将获取的需求**文档化(用例、决策表、决策树)**

**需求获取的方法**
- 采访: 获取需求的传统手段
- 设定情景: 通过**用例图**来设置情景从而获得需求
- 原型: 通过**原型**来表示不明确的需求，可将原型视为可执行的需求说明书
- 会议: 通过讨论提出更多更全面的多角度需求

#### 需求提炼
定义: 对应用问题及环境的**理解和分析**，为问题涉及的信息、功能及系统行为**建立模型**，将用户需求精确化、完全化

需求提炼采用多种形式描述需求，通过**建立需求的多种视图**，揭示出一些更深的问题，并且需要**产生操作规格参数表**，**指明与其他系统元件的软件接口**，确定软件必须遵循的**约束**

**需求提炼的方法**
主要有**2种**方法: 
- **结构化分析模型**
- **面向对象分析模型**

<span style="color:#ff562b"><b>这两种方法是需求分析中最需要掌握的模型！</b></span>

##### 结构化分析模型
结构化分析可以**分析商业的需求**，**再转换为规格文件**，最后再产生电脑软件、硬件配置及相关的手册及程序。
**结构化思维**是软件工程学科中一种典型的**分析系统**、**设计系统**的思维方法，采用**系统科学**思想、依据**层次分解**、 **自顶向下**分析和设计系统

![结构化分析模型](Structured_Analysis.png)
该模型**以数据字典为核心**，通过分别进行**功能建模**、**数据建模**和**行为建模**从而对需求进行分析。

- **功能建模**: 通过**多层数据流图**来反应系统的数据流通情况
  首先说明数据流图的基本图形符号: 
  ![数据流图基本图形符号](dfd.png)
  ![多个数据流之间的关系](data_flow.png)
  其中多个数据流之间的$*$代表要求**同时出现多个输入或输出**，$\oplus$代表**必须且只能出现一个输入或输出**
  结构化分析策略是**自顶向下逐步求精**，因此数据流图有多层结构: 
  ![多层数据流](data_flow_structure.gif)
  1. **顶层数据流图(0层数据流图/环境图): 仅包括一个数据处理过程，也就是要开发的目标系统**，其**作用**在于用是**确定系统在其环境中的位置**，通过确定系统的输入和输出与外部实体的关系**确定其边界**
  ![顶层数据流图](top_data_flow.png)
  2. **下层数据流图(1层、2层···)**: 对系统中不同功能模块的具体数据流方向进行描述，描述方法与顶层数据流相同

  ![数据流图实例](data_flow_sample.png)
- **数据建模**: 在结构化分析方法中，使用**实体—关系建模技术来建立数据模型**，通过**实体—关系图**进行可视化
  实体—关系图仅**包含3种相互关联的元素**: **数据对象(实体)**、**描述数据对象的属性**及**数据对象(实体)彼此间相互连接的关系**
  1. **数据对象(实体)**: 可以是外部实体、事物、角色、行为或事件、组织单位、地点或结构等
  2. **属性**: 数据对象的特征，在ER图中用**椭圆或圆角矩形**表示，并用**无向边**将属性与相关的数据对象连接在一起
  ![实体的属性表示](ER_attribute.png)

  3. **关系**: 说明两个实体之间的关系，在ER图上用**无向边**表示，同时在无向边的两端**应标识出关联实例的数量**，也称为关联的重数
  ![不同重数的表示](ER_relationship.png)
  **关系本身也可能有属性**，这在多对多的关系中尤其常见，在表示关系的无向边上**再加一个菱形框，并在菱形框中标明关系的名字**
  ![关系的属性表示](ER_relationship_attribute.png)
- **行为建模**: 行为建模通过**描绘系统的状态及引起系统状态转换的事件**，来表示系统的行为，通过**状态转换图**来可视化
  ![状态转换图基本图形符号](std.png)

  1. **状态**: **状态是任何可以被观察到的系统行为模式**，一个状态代表系统的一种行为模式，状态规定了系统对事件的响应方式，状态可能有: **初态(初始状态)**、**终态(最终状态)**和**中间态**三种可选值，**在一张状态图中只能有一个初态，而终态则可以有多个，也可以没有**
  2. **事件**: 事件是在某个特定时刻发生的事情，它是**对引起系统做动作或从一个状态转换到另一个状态的外部事件的抽象**
    **事件表达式: 事件说明(守卫条件)/动作表达式**
    - **事件说明**: **事件名(参数表)**
    - **守卫条件**: **布尔表达式**(如果同时使用守卫条件和事件说明，则当且仅当事件发生且布尔表达式成立时，状态转换才发生。如果只有守卫条件没有事件说明，则只要守卫条件为真，状态转换就发生)
    - **动作表达式**: 是一个过程表达式，当状态转换开始时执行该表达式
  ![状态转换图实例](std_sample.png)

##### 面向对象分析模型

#### 需求描述
软件需求规格说明书(SRS)是**对待开发系统的行为的完整描述**，包含了描述用户与软件交互的**用例的集合**。用例通常描述功能性需求，除了用例之外，SRS还包含非功能性需求

需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书，其中**需求描述步骤即是根据需求提炼出的模型来撰写需求规格说明书的过程**。

**需求规格说明的特征**
- 应该只具有固定的、已知的和同意交付的系统的**基本特征**
- 应该包含**交付什么**
- 应该**使用客户能理解的词汇**
- 应该是**正确的**
- 应该是**准确的**
- 应该是**明确的**
- 应该是**完整的**
- 应该是**可验证的**
- 应该是**能确认的**
- 应该是**一致的**
- 应该是**可更改的**
- 应该是**可以追踪的**

**需求规格说明的原则**
- 从现实中分离功能(**描述要"做什么"而不是"怎样实现"**)
- 要求使用**面向处理的规格说明语言**
- **如果被开发软件只是一个大系统中的一个元素，那么整个大系统也包括在规格说明的描述之中**
- 规格说明必须包括**系统运行环境**
- 规格说明必须是一个**认识模型**
- 规格说明必须是**可操作的**
- 规格说明必须**容许不完备性并允许扩充**
- 规格说明必须**局部化和松散耦合**

**需求规格说明的内容**
- **功能性需求(核心部分)**
- **非功能性需求(功能约束)**
- **环境描述和系统目标**
- **项目管理**
- **生命周期需求**
- **系统交付和安装说明**
- **数据和传输协议需求**

[IEEE 830](https://personal.utdallas.edu/~chung/RE/IEEE830-1993.pdf)为软件需求说明书定义了一种格式，仅作为**参考**
[GB/T 8567-2006](https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=84C42B6277D2714B7176B10C6E6B1A44)为中国《计算机软件文档编制规范》标准，其中涉及需求规格说明文档

#### 需求验证
定义: 需求验证即检查需求的**正确性**、**完整性**、**非二义性**、**内部和外部的连贯性**。

需求文档需要验证，以表明它真实地定义了客户想要的系统，因此需求通常是同时从**客户**和**开发人员**的角度来进行检查的
- 客户角度: 
  - 有效性检查: 检查**不同用户使用不同功能的有效性**
  - 一致性检查: 在文档中，**需求不应该冲突**
  - 完备性检查: 需求文档应该**包括所有用户想要的功能和约束**
  - 现实性检查: 检查保证能**利用现有技术实现需求**
- 开发人员角度: 
  - 可验证性: 需求**可被验证的能力**
  - 可理解性: 需求**被理解的能力**
  - 可追踪性: 有关每一个元件存在原因的说明(**需求不变的概率**)
  - 适应性(修改性): 文档**可被修改的程度**

**需求验证的方法**
- 利用**原型检验系统**是否符合用户的真正需要
- 对每个需求编写概念性的**测试用例**
- 编写用户手册
- 自动的一致性分析: 可用CASE工具检验需求模型的一致性

## 软件设计

## 生产率和工作度量

## 软件测试

## 测试策略

## 软件维护

## 软件维护

## 项目管理