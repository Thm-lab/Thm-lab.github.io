---
title: 进程管理
date: 2023-02-10 13:05:39
author: Thm
tags: Operating System
math: true
katex: true
mermaid: true
---
# 进程管理

## 描述与控制
进程的**定义**: 
- 一个**正在执行的程序**
- 一个**正在**计算机上执行的**程序实例**
- 能**分配给处理器并由处理器执行的实体**
- 由一组执行的**指令**、一个**当前状态**和一组相关的**系统资源**表征的活动单元

进程的**基本特征**: 
- **动态性(本质特性)**: 正在计算机上执行的程序实例，**存在生命周期**
- **并发性(重要特性)**: 任何进程都可以同其他进程**一起**向前推进
- **独立性**: 各进程的**地址空间相互独立**，除非采用进程间通信手段
- **异步性**: 按**各自独立的、不可预知**的速度向前推进

进程与程序的**区别**: 
<b>

- 程序是静态的，而进程是动态的
- 进程包括了程序相关的数据
- 一个应用程序的执行可能有多个进程

</b>

### 进程结构
**进程 = 程序代码 + 相关数据 + 进程控制块(PCB, Process Control Block)**
**进程映像(Process Image) = 程序代码段 + 数据 + PCB + 栈**
![进程映像在虚存中结构](process_image.png)

#### PCB
进程控制块**包含了充分的信息**， 因此可以中断一个进程的执行，并在后来恢复进程的执行，就好像进程未被中断过那样，PCB是OS**支持多进程并提供多重处理技术**的关键工具

**PCB的内容**: 
<b>

- 进程标识信息
- 处理器状态信息
- 进程控制信息

</b>

##### 进程标识信息
操作系统控制的许多表可以使用**进程标识符**来引用进程表
- 说明内存、I/O设备和文件分配给了**哪个进程**
- 内存表、I/O和文件表都可以引用进程标识符，进而交叉引用**进程表**
- 进程通信时，标识通信目标
- 指明每个进程的父进程和子进程

**典型进程标识信息**: 
- **唯一的进程ID**
- **父进程(创建该进程的进程)ID**
- **用户ID**

##### 处理器状态信息
包括**通用寄存器内容**与**标志寄存器内容**，可以帮助处理器**恢复现场**

**典型处理器状态信息**: 
- **用户可见寄存器**内容: 部分通用寄存器(**IA-32的EAX、EBX、ECX、EDX、ESI、EDI**)
- **栈寄存器**内容: 每个进程有一个或多个与之相关联的后进先出(LIFO)系统栈，栈用于保存参数和过程调用或系统调用的地址(**IA-32的ESP、EBP**)
- **标志寄存器**内容: 程序计数器(**EIP**)和条件码寄存器(**EFLAGS**)

##### 进程控制信息
是操作系统**控制和协调各种活动进程所需的额外信息**

**典型进程控制信息**: 
- **调度和状态**信息: 
  - **进程状态**：如运行态、就绪态、等待态、停止态
  - **优先级**：描述进程调度优先级的一个或多个域
  - **调度相关信息**：具体取决于所用的调度算法，如进程等待的时间总量和进程上次运行的执行时间总量
  - **事件**：进程在继续执行前等待的事件标识
- **数据结构**信息: 进程可以以排队、环或其他数据结构链接到其他进程(如链表指向的下一个进程ID)
- **进程间通信**: 各种标记、信号和信息可与两个无关进程间的通信关联
- **进程特权**: 进程根据其可以访问的内存和可执行的指令类型来赋予特权
- **存储管理**: 包括指向描述分配给该进程的虚存的段表和/或页表的指针
- **资源所有权和使用情况**: 指示进程控制的资源(IO资源等)

### 进程状态

#### 两状态模型
![两状态模型](two_state_process_model.png)

- **创建**: 一个新进程添加到正被管理的进程集时，操作系统需要**建立用于管理该进程的数据结构(PCB)**，并**在内存中给它分配地址空间**，这些行为构成了一个新进程的创建过程
  ![创建进程原因](enter.png)
- **终止**: 由**批处理程序显式调用**或**用户指出进程**何时结束，或**进程进行非法操作时由OS进行终止**
  ![终止进程原因](exit.png)

![两状态模型排队](two_state_process_queuing.png)
当多进程需要处理时，未运行进程在**创建队列进行排队**

#### 五状态模型
![五状态模型](five_state_process_model.png)

- **新建(New)**: 刚刚创建的进程，操作系统还**未把它加入可执行进程组**，它通常是**进程控制块己经创建但还未加载到内存中的新进程**
- **就绪(Ready)**: 进程做好了准备，**只要有机会就开始执行**
- **阻塞(Blocked)**: 进程**在某些事件发生前不能执行**，如I/O操作完成
- **运行(Runing)**: 处理器**正在执行该进程**
- **退出(Eixt)**: 操作系统**从可执行进程组中释放出的进程**，要么它自身**已停止**，要么它因某种原因**被取消**

![单阻塞队列](single_blocked_queue.png)
**单阻塞队列: 所有阻塞进程位于一个阻塞队列**

![多阻塞队列](multiple_blocked_queue.png)
**多阻塞队列: 不同事件对应一个阻塞队列**

![五状态模型转换示例](five_state_process_model_example.png)

<span style="color:#ff562b"><b>多队列思想同样可以用于就绪队列！从而对就绪进程进行优先级分级</b></span>

#### 带挂起状态模型
![单挂起态模型](one_suspended_model.png)
![双挂起态模型](two_suspended_model.png)
- **就绪/挂起(Ready/Suspended)**: 进程**己在外存**中，但只要**载入内存就可执行**
- **阻塞/挂起(Blocked/Suspended)**: 进程**己在外存中并等待一个事件**

![挂起进程原因](suspend.png)

### 进程控制
操作系统采用表格(或数据结构)来**记载各资源的信息**，从而实现对资源的管理、维护、更新等，同时进程表必须能被操作系统所访问，因此其**受制于内存管理**
![进程表](process_table.png)

#### 操作系统内核
OS内核是**操作系统中包含重要系统功能的部分**，并且需要**常驻内存，便于提高操作系统运行效能**

**内核功能**: 
- **资源管理功能**
  - 进程管理: 进程的创建、终止、调度、分派、切换、通信等
  - 存储管理: 内存管理和内外存交换
  - I/O设备管理: 缓冲区管理和I/O通道的分配
- **支撑功能**
  - 中断处理
  - 时钟管理
  - 记账功能

**处理器模式**: 
- **用户模式**: 具有较少优先权的模式，运行用户程序
- **内核模式**: 运行操作系统的内核，执行某些特权指令，访问某些内存空间

使用两种模式可以**保护操作系统和重要的操作系统表(如PCB)不受程序干扰**

#### 进程创建
当出现了需要创建进程的情况时，操作系统将按以下步骤创建一个新进程
![进程创建](creat_process.png)

#### 进程切换
进程切换指的是**操作系统中断一个正在运行的进程，将另一个进程置于运行模式，并把控制权交给后者**

![进程切换原因](process_switch_reason.png)

[异常和中断的区别](https://thm-lab.github.io/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/#cpu%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86)详见计组

但是！**中断不一定会引起进程切换**，例如I/O中断由CPU执行中断处理程序后仍然有可能切换为原进程
然而**进程切换一定会引起模式切换**，因为**进程切换需要切换到内核模式下完成进程调度**

进程切换的**步骤**: 
1. **保存处理器上下文环境**，包括程序计数器和其它寄存器
2. **更新当前处于运行状态进程的进程控制块**
3. 将进程的**进程控制块移至相应队列**(就绪、阻塞、就绪/挂起等)
4. **选择另一进程执行**
5. **更新其进程控制块信息**
6. **更新内存管理数据结构**
7. **恢复**被选择进程的**上下文环境**，如载入程序计数器和其他寄存器先前的值

#### 模式切换
模式切换指**用户模式和内核模式之间的相互转换**

由用户模式切到内核模式的原因: 
- **系统调用**: 是操作系统提供给用户程序**访问系统内核功能的接口**，用户程序通过调用系统调用来获取操作系统提供的服务，服务完成后返回应用程序
- **中断**: 以便中断处理能执行特权指令

然而**模式切换不一定会引起进程切换**，某些系统调用(如getpid)就不会导致进程切换

### Unix SVR4的进程管理
![Unix进程状态转换](unix_process_state_model.png)

**进程创建**由**内核系统调用fork()实现**
fork()调用后的步骤: 
1. 在**进程表中**为新进程**分配一个空项**
2. 为子进程**分配一个唯一的进程标识符**
3. **复制**父进程的**进程映象**，但共享内存除外
4. **增加父进程**所拥有的**文件的计数器**，反映另一个进程现在也拥有这些文件的事实
5. **将子进程设置为就绪态**
6. **将子进程的ID号返回给父进程，将0值返回给子进程**

**fork()创建子进程之后，父进程和子进程均在下一条语句上继续运行**
**fork()创建子进程之后，执行返回父进程，或调度切换到子进程或其他进程(与OS的调度算法有关)**

``` c
#include<stdio.h>
#Include<sys/types.h>
#include<unistd.h>

void main(void) {
  printf("Hello\n");
  fork(); 
  printf("Bye\n");
}
```
输出: 
``` shell
Hello
Bye
Bye
```

``` c
#include <stdio.h>
#include <unistd.h>
int main() {
  int i;
  for (i=0;i<3;i++)
    fork();
    printf("hello, world\n");
    return 0;
}

```
输出: 共$2^3=8$个`hello, world`(8个进程，每个进程打印一个)
``` shell
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
hello, world
```

``` c
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int global = 4;
int main(void) {
  int  pid;
  int vari = 5;
  printf("before fork\n");

  if ((pid = fork()) < 0) {
      printf("fork error\n");
      
  } else if (pid == 0) {
  global++;
  vari--;
  printf("child\n");
  }
 printf("global=%d,vari=%d\n", global, vari);
 return 0;
}
```
输出: 因为子进程是**复制**了父进程的**进程映像**(除共享空间外)，因此**不会影响父进程的数据**，**子进程数据为自己独有**
``` shell
before fork
global=4,vari=5
child
global=5,vari=4
```

### 线程
进程的**2个基本属性**: 
- **进程是拥有资源的独立单位**
- **进程是调度/执行的基本单位**，挂起进程会导致内部所有线程被挂起，终止进程会导致内部所有线程被终止，因此线程只是独立调度和分配的基本单位

**线程**是进程中的一个实体，**是独立调度和分配的基本单位**
![线程](thread.png)
- 单进程单线程: MS Dos等
- 单进程多线程: JVM(Java虚拟机)等
- 多进程单线程: 传统Unix等
- 多进程多线程: 现在操作系统(Windows、Solaris)等

![多线程模型](multithreaded_process_model.png)
进程内可能有多个线程，每个线程都有**包含线程信息的TCB**(Thread Control Block)、线程**代码**、**局部变量的静态存储空间**、**执行栈**和**与进程内其他线程共享的内存和资源访问**

线程的**优点**: 
- **创建时间短**
- **终止时间短**
- **切换时间短**
- 执行程序间的通信效率高(**进程通信难度大于线程通信**)

![多线程示例](multithreaded_process_example.png)

#### 线程分类
可以分为: 
- **用户级线程(ULT)**
- **内核级线程(KLT)**
- 混合方法

##### ULT
![用户级线程](ULT.png)
**线程由用户自己管理(创建、终止、调度、挂起)**，OS不知道有线程存在

##### KLT
![内核级线程](KLT.png)
线程管理由OS进行，应用程序无法参与线程管理

##### 不同类型线程优缺点
| 线程类型 | 用户级                                                                                                         | 内核级                                                                                                                                                                                   | 混合方法                                                                                                                                                                             |
| -------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 优点     | **线程切换不需要内核模式特权**<br>**调度策略因应用程序不同而不同**<br>**可以运行在任何操作系统上**             | 内核可以把同一个进程内的**多个线程调度到多处理器上**，**提高并发性**<br>**当一个线程阻塞时，内核可以调度同一进程内的其他线程**<br>**内核例程本身也可以是多线程的，提高了内核的运行效率** | **线程创建在用户空间完成**(开销小，不需要模式切换)<br>**线程调度和同步也由应用程序完成**(开销小，不需要模式切换)<br>**一个应用程序中的多个线程被映射到一些**(小于或等于用户级线程数) |
| 缺点     | 当用户级线程执行系统调用时，不仅阻塞当前线程，还**将引起同一进程中的其他线程阻塞**<br>**不能利用多处理器技术** | 把控制权从一个线程传递到相同进程内的另一个线程时，需要**切换到内核模式**(**由OS进行线程切换**)                                                                                           |                                                                                                                                                                                      |
## 调度

### 调度类型
调度的**目的**是以**满足系统目标**(如响应时间、吞吐率、处理器效率)的方式，把进程分配到一个或多个处理器上执行
在本节中仅考虑**单处理器**，多处理器的调度复杂度远高于单处理器调度

首先可以将调度进行分类: 
- **长程调度**: 长程调度程序决定哪个程序可以进入系统中处理(创建进程)，因此它控制了系统的并发度，常见的调度算法: **先来先服务FCFS**或**根据优先级、期望执行时间等进行调度**
- **中程调度**: 中程调度是交换功能的一部分(主要是**进程在内存与外存的管理**)，**调度算法与存储管理相关**
- **短程调度**: **由就绪状态中挑选进程进入执行状态**，调度算法将在下面详细介绍

![调度层次](scheduling.png)
![状态转变的调度层级](scheduling_state_transaction.png)

**本节也主要关注短程调度**

### 调度标准

- **响应时间**: **从用户提交一个请求开始，到接收到第一个响应之间的时间间隔**，响应时间 = 输入传送时间 + 计算时间 + 响应传送时间
- **周转时间**: **从作业提交开始，到作业完成之间的时间间隔**
- **截止时间**: 某任务**必须开始执行的最迟时间**，或**必须完成的最迟时间**
- **吞吐量**: **单位时间内完成的进程数量**
- **处理器利用率**: **处理器处于忙状态的时间百分比**

<span style="color:#ff562b"><b>响应时间与周转时间无法比较长短，如果进程只进行一次响应后即结束，则响应时间等于周转时间；如果进程需要响应多次，则响应时间小于周转时间</b></span>

- **平均周转时间**: $T = \frac{1}{n} \sum_{i=1}^{n} T_i$
- **带权周转时间**: $W = \frac{T}{T_{s}}$，其中T为**周转时间**，$T_s$为**系统为进程服务时间**
- **平均带权周转时间**: $T = \frac{1}{n} \sum_{i=1}^{n} W_i$

### 调度决策

#### 调度规则
**短程调度**的主要目标: **按照优化系统某些方面的方式，来分配处理器时间**

调度规则的影响因素: **面向用户/面向系统**与**性能相关/性能无关**
- **面向用户且性能相关**: **周转时间、响应时间、截止时间**
- **面向用户且性能无关**: **可预测性**
- **面向系统且性能相关**: **吞吐量、处理器利用率**
- **面向系统且性能无关**: **公平性、强制优先级、平衡资源**

**优先级: 通过多条就绪队列进行实现**

#### 调度模式
- 非抢占式: 执行进程只有在**执行完毕**，或因申请I/O或请求某些操作系统服务而**阻塞自己**时，才释放处理器
- 抢占式: 执行进程可能被操作系统中断，并转换为**就绪态**，抢占发生原因: 
  - **新进程到达**
  - **中断发生后把一个阻塞进程置为就绪态**
  - **周期性的时钟中断(防止独占)**

#### 调度函数
关键参数: 
<b>

- w: 目前为止在系统里的等待时间
- e: 目前为止花费的执行时间
- s: 进程所需的总服务时间(用户提供或估计)

</b>

### 调度算法
<b>

- 先来先服务(First Come First Served, FCFS)
- 时间片轮转(Round Robin, RR)
- 短作业优先(Shortest Job First, SJF)
- 剩余时间最短优先(Shortest Remaining Time, SRT)
- 响应比高优先(Highest Response Ratio Next, HRRN)
- 反馈(Feedback, FB)

</b>

#### FCFS
说明: 按照**到达的先后顺序来调度，属于非抢占调度方式**

评价: 
- **有利于CPU繁忙型**的进程，而**不利于I/O繁忙型**的进程(**CPU繁忙型会持续占有CPU**，而**I/O繁忙型进程进行I/O后需要重新排队**)
- **平均周转时间长**，**不适合直接用于单处理器系统,通常与其它调度算法混合使用**

#### RR
说明: 每个进程被**分配一个时间片**，周期性产生时钟中断，**中断时当前进程进入就绪队列末尾**，**基于FCFS选择下一个作业运行**，如果进程在时间片内**阻塞或结束**，则**立即切换**进程

评价: 
- 属于**抢占调度方式**
- **时间片的设置**与系统性能、响应时间密切相关
  - 当时间片趋于无穷大时: RR变为FCFS，对CPU繁忙型有利，同样会**引起对短的交互请求的响应时间变长**
  - 当时间片为1时，对I/O繁忙型较为有利(**但IO阻塞后仍需排队**)，但**频繁切换进程降低了CPU的效率**
  - 因此时间片最好**略大于一次典型交互的时间**，仍对CPU繁忙型有利

RR算法在**通用的分时系统**或**事务处理系统**中特别有效

![示例](RR_example.png)
**平均周转时间** = $\frac{4+16+13+14+7}{5}=10.8$，**平均带权周转时间** = $\frac{\frac{4}{3}+\frac{16}{6}+\frac{13}{4}+\frac{14}{5}+\frac{7}{2}}{5}=2.71$

**VRR**: 是对RR的改进，**增加一个辅助队列，接收I/O阻塞完成的进程，调度优先于就绪队列，但占用的处理机时间小于就绪队列的时间片**

#### SJF
说明: **根据用户提供的或估算的作业执行时间进行调度，选择执行时间最短的作业交给CPU**

评价: 
- **属于非抢占调度方式**，短进程跳到队列头，**可能导致长进程饥饿**，因此不适用于分时系统或事务处理环境
- 有利于短进程，**减小了平均周转时间**(非抢占调度下，长进程一般会导致短进程的高周转时间，所以有利于短进程能减小平均周转时间)
- 进程的长短根据用户所提供的估计执行时间而定，用户估计不准时，导致该算法不一定能真正做到短作业优先调度

![示例](SJF_example.png)
**平均周转时间** = $\frac{3+7+11+14+3}{5}=7.6$，**平均带权周转时间** = $\frac{\frac{3}{3}+\frac{7}{6}+\frac{11}{4}+\frac{14}{5}+\frac{3}{2}}{5}=1.78$

#### SRT
说明: **调度程序总是选择预期剩余时间最短的进程**，当一个新进程加入就绪队列时，如果它比当前运行的进程具有更短的剩余时间，就可能**抢占**当前正在运行的进程

评价: 
- **属于抢占式调度方式**，既不像FCFS那样偏爱长进程(非抢占式)，也不像RR算法那样会产生很多额外的中断(因时间片而产生)，从而**减少了开销**
- 周转时间短，SRT比SJF性能要好，只要就绪，短作业可以立即被选择执行
- **需要估计预期的服务时间**(估计可能不准)
- **存在长进程饥饿现象**
- **必须记录进程的已服务时间**

![示例](SRT_example.png)
**平均周转时间** = $\frac{3+13+4+14+2}{5}=7.2$，**平均带权周转时间** = $\frac{\frac{3}{3}+\frac{13}{6}+\frac{4}{4}+\frac{14}{5}+\frac{2}{2}}{5}=1.59$

#### HRRN
说明: **选择就绪队列中响应比最高的进程投入执行**
**响应比**: $\frac{T_w + T_s}{T_s}$，$T_w$为进程等待时间$，T_s$为估计的作业执行时间

评价: 
- **属于非抢占式**调度方法，实质上是一种动态优先权调度算法
- 是FCFS和SJF的结合，**既照顾了短进程，又考虑了作业到达的先后次序**，不会使长进程长期得不到服务
- 需要计算响应比，**增加系统开销**，且难以准确计算(**需要估计执行时间**)

![示例](HRRN_example.png)
**平均周转时间** = $\frac{3+7+9+14+7}{5}=8$，**平均带权周转时间** = $\frac{\frac{3}{3}+\frac{7}{6}+\frac{9}{4}+\frac{14}{5}+\frac{7}{2}}{5}=2.14$

#### FB
SJF、SRT和HARRN都采用了**进程估计执行时间**这一参数作为调度的因素来**奖励短进程从而降低平均周转时间**，然而该参数很难进行准确估算
而FB采用的是惩罚长进程的思想，其关注进程的**已执行时间**参数，该参数可以被精准测量，根据进程执行历史，**调度基于按时间片的抢占原则**

说明: 
1. 设置多个就绪队列，每个队列赋予不同优先级(**第一队列优先级最高，依次递减，各个队列中进程执行的时间片不相同，优先级越高的队列，时间片越小**)
2. 新进程进入时，首先放入第一个队列尾(**优先级默认最高**)，按FCFS原则排队
3. 如果进程在当前队列规定的时间片内**完成则退出**，**未完成则抢占**，一般而言，从队列i中调度的进程允许执行$2^i$的时间，然后才被抢占，降级到下一个优先级队列(**如果没有其他进程需调度，则当前进程不降级**)
4. **到达最低优先级队列后，不再降级**
5. **仅当第一队列空闲时，才调度第二队列中的进程，依次类推**

评价: 
- **属于抢占式调度方式**，能**较好地满足各种类型用户**的需要
- **有利于终端型作业用户**: 常为短作业，**能在第一队列所规定的时间片内完**
- **对短作业用户有利**: **能在前几个队列所规定的时间片内完成**
- **长进程**: 将依次在第1, 2, ···, n个队列中运行，**随着优先级下降，分配的时间片长度增加，减少了抢占次数，不会发生长进程饥饿**

![示例](FB_q=1.png)
**平均周转时间** = $\frac{4+18+12+13+3}{5}=10$，**平均带权周转时间** = $\frac{\frac{4}{3}+\frac{18}{6}+\frac{12}{4}+\frac{13}{5}+\frac{3}{2}}{5}=2.29$
![示例](FB_q=2i.png)
**平均周转时间** = $\frac{4+15+14+14+6}{5}=8$，**平均带权周转时间** = $\frac{\frac{4}{3}+\frac{15}{6}+\frac{14}{4}+\frac{14}{5}+\frac{6}{2}}{5}=2.63$

### 实时系统与实时调度

#### 实时系统
实时系统要求系统能够**及时(即时)响应外部事件的请求**，在**规定的时间内完成**对该事件的处理，并控制所有实时任务协调一致地运行

实时任务: 具有**及时性要求**的、常常**被重复执行**的特定进程，在实时系统中习惯称为任务

[调度标准](#调度标准)中有一个标准为**截止时间**，在实时系统中截止时间分为2类: 
- 开始截止时间: 任务在某时间以前，必须开始执行
- 完成截止时间: 任务在某时间以前必须完成

![实时任务分类](real_time_task.png)

实时任务的**信息**: 
- 就绪时间
- 开始截止时间
- 完成截止时间
- 处理时间
- 资源需求
- 优先级
- 子任务结构: 一个任务可分解为**一个必须执行的子任务**和一个可选执行子任务，**前者有硬截止时间**

实时操作系统**特点**: 
- **可确定性**: 任务按照**固定的、预先确定的时间**或时间间隔进行
- **可响应性**: 关注系统在知道中断后**为中断提供服务的时间**
- **用户控制**: 用户能够区分软、硬实时任务，并**控制任务优先级**
- **可靠性**: 实时响应和控制事件，保障性能
- **失效弱化**: 系统具有稳定性，当不能满足所有任务的实时性时，首先满足优先级高的任务

#### 实时调度
实时调度从2个角度进行分类: 
- **调度方法**
- **抢占方式**

##### 调度方法
- **静态表驱动**调度法
- **静态优先级抢占**调度法
- **基于动态规划**的调度法
- **动态尽力**调度法

**静态表驱动调度法**
制订**静态调度表**(即固定时间执行固定进程)，用于调度**周期性实时任务**
任何任务的调度**申请改动都会引起调度表的修改**

**EDF(Early Deadline First)调度算法**即是属于静态表驱动调度法
说明: 根据任务的截止时间来确定任务的优先级

![示例](edf_example_question.png)
![示例](edf_example_answer.png)

**静态优先级抢占调度法**
**根据任务的时间约束确定优先级从而根据优先级进行抢占调度**，多用于非实时多道程序系统

**速度单调算法(RM,Rate Monotonic)**即是根据**任务周期长度**为实时任务赋予**静态优先级**
说明: 任务周期越短，优先级越高，优先级函数是**任务速度(任务周期的倒数)**的单调**递增**的函数

![速率与优先级](RM.png)

**基于动态规划的调度法**
当实时任务到达以后，系统为新到达的任务和正在执行的任务**动态创建一张调度表**
说明: 在**当前执行进程不会错过其截止时间的条件下**，如果也能**使新到达任务在截止时间内完成，则立即调度执行新任务**

**动态尽力调度法**
当任务到达时，系统**根据其属性赋予优先级**，优先级高的先调度
当任务是非周期时，其缺点在于**当任务完成，或截止时间到达时，很难知道该任务是否满足其约束时间**

**允许CPU空闲的EDF**
说明: 优先调度**截止时间最早的还未就绪但是已知道其开始截止时间任务**，并让该任务运行完毕

![示例](edf_idle_time_question.png)
![示例](edf_idle_time_answer.png)

##### 抢占方式
- **基于时间片**的轮转抢占式调度
- **基于优先级**的**非抢占式**调度
- **基于优先级**的抢**占点抢占**调度
- **立即抢占式**调度

![抢占方式](preemption.png)

## 同步

## 死锁