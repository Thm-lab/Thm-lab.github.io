<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件管理</title>
    <link href="/2023/02/14/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/14/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h1><h2 id="文件组织"><a class="markdownIt-Anchor" href="#文件组织"></a> 文件组织</h2><h2 id="文件目录"><a class="markdownIt-Anchor" href="#文件目录"></a> 文件目录</h2><h2 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h2><h2 id="记录组块"><a class="markdownIt-Anchor" href="#记录组块"></a> 记录组块</h2><h2 id="辅存管理"><a class="markdownIt-Anchor" href="#辅存管理"></a> 辅存管理</h2><h3 id="文件分配"><a class="markdownIt-Anchor" href="#文件分配"></a> 文件分配</h3><h3 id="空闲空间管理"><a class="markdownIt-Anchor" href="#空闲空间管理"></a> 空闲空间管理</h3><h2 id="unix文件管理"><a class="markdownIt-Anchor" href="#unix文件管理"></a> Unix文件管理</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O管理与磁盘调度</title>
    <link href="/2023/02/13/I-O%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/02/13/I-O%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="io管理与磁盘调度"><a class="markdownIt-Anchor" href="#io管理与磁盘调度"></a> I/O管理与磁盘调度</h1><h2 id="io管理"><a class="markdownIt-Anchor" href="#io管理"></a> I/O管理</h2><h3 id="io设备概述"><a class="markdownIt-Anchor" href="#io设备概述"></a> I/O设备概述</h3><p>外设分类:</p><ol><li>按信息传输方向:<ul><li>输入设备: 从外部向计算机输入信息，如：键盘、鼠标、扫描仪等</li><li>输出设备:从计算机向外部输出信息，如：打印机、显示器等</li><li>输入输出设备: 既可输入又可输出，如：带触屏的显示器、磁盘存储器等</li></ul></li><li>按功能:<ul><li>人-机交互设备:输入/输出的信息是人可读的，或可操作的。如: 键盘、鼠标、扫描仪、打印机、显示器等</li><li>外部存储设备: 用于信息的存储(其输入/出的信息是机器可读的)。如: 磁盘、磁带、光盘等</li><li>主机间通信设备: 主要用于计算机和计算机之间的通信。如: 网卡、调制解调器、A/D、D/A等</li></ul></li></ol><p><img src="io_devices_model.png" alt="外部设备通用模型" /></p><ul><li>电缆: 通过电缆与计算机内部I/O接口进行数据、状态和控制信息的传送。电缆线中包括<strong>控制信号</strong>、<strong>状态信号</strong>和<strong>数据信号</strong>三种信号线</li><li>控制逻辑: 根据控制信息控制设备的操作并检测设备状态</li><li>缓冲器: <strong>用于保存与计算机交换的数据信息</strong></li><li>变换器: 用于实现电信号形式与其他形式的设备数据之间的转换</li></ul><p><b>所有外部设备均可抽象为该模型</b></p><h3 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> I/O控制方式</h3><p>I/O设备与主机进行数据交换的三种基本方式:</p><ul><li>程序直接控制方式:<ul><li>无条件传送: 对简单外设定时同步进行数据传送</li><li><strong>条件传送</strong>: 轮询方式，OS主动查询，I/O设备将自己的状态放到一个状态寄存器中，OS阶段性的查询状态寄存器中的特定状态以决定下一步动作。</li></ul></li><li><strong>中断方式</strong>: 几乎所有系统都支持的方式<ol><li>当一个I/O设备需要CPU的干预时，他通过<strong>中断请求来通知CPU</strong></li><li>CPU<strong>中止当前程序的执行</strong>，调出OS中断处理程序来执行</li><li>处理完成后<strong>返回到中止的程序继续执行</strong></li></ol></li><li><strong>DMA方式</strong>: 磁盘等高速外设<strong>成批的直接和主存进行数据交换</strong></li></ul><p><span style="color:#ff562b"><b>三种方式的详细说明在计组的<a href="https://thm-lab.github.io/2022/06/13/%E4%BA%92%E8%BF%9E%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%84%E7%BB%87/#io%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F">互连及输入输出组织</a><br /></b></span></p><p><strong>I/O通道控制方式</strong><br /><strong>I/O通道</strong>: <strong>是DMA方式的发展</strong>，有自己的I/O指令集，通过<strong>执行通道程序，与设备控制器共同实现对I/O设备的控制</strong></p><p><strong>与DMA方式的不同</strong>:</p><ul><li>DMA以<strong>一个数据块</strong>为数据读写单位，I/O通道以<strong>一组数据块</strong>为数据读写单位</li><li>DMA中<strong>CPU控制传输方向、数据大小、数据在内存的位置</strong>，<strong>I/O通道自己控制传输方向、数据大小、数据在内存的位置</strong></li></ul><p>因此I/O通道可实现CPU、I/O通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率</p><p><strong>一个设备可以连接到多个控制器上，而一个控制器又连接到多个通道上</strong><br /><img src="io_channel.png" alt="I/O通道" /></p><p><img src="io_control_development.png" alt="I/O控制发展史" /></p><h3 id="io功能组织模型"><a class="markdownIt-Anchor" href="#io功能组织模型"></a> I/O功能组织模型</h3><p>操作系统的功能可以根据复杂性、特征时间尺度(time scale)和层次的抽象来分开，每一层执行相关的子功能，<strong>分层定义</strong>，<strong>使得某层的功能变化不影响其他层次</strong></p><p><img src="io_organization_model.png" alt="I/O功能组织模型" /></p><ul><li><strong>逻辑I/O</strong>: 把设备当作<strong>逻辑资源</strong>处理，不关心控制设备的细节</li><li><strong>设备I/O</strong>: 请求的操作和数据被转换成对应的I/O指令、通道指令和控制器指令，并可以使用缓冲提高效率</li><li><strong>调度和控制</strong>: 与硬件真正发生交互的软件层，处理中断，收集和报告I/O状态</li></ul><p>典型I/O功能组织模型的设计结构:</p><ul><li>通信架构</li><li>文件系统</li></ul><p><img src="communication.png" alt="通信架构" /><br /><img src="file_system.png" alt="文件系统" /></p><h3 id="io缓冲"><a class="markdownIt-Anchor" href="#io缓冲"></a> I/O缓冲</h3><p><strong>缓冲</strong>: 操作系统在<strong>内存中</strong>给I/O请求分配一个<strong>缓冲区</strong></p><p>缓冲的<strong>作用</strong>:</p><ul><li><strong>缓解I/O设备速度与CPU速度不匹配的矛盾</strong>，进程的需求大于I/O设备的服务能力时，进程每处理完一块数据后得停下等待</li><li>在多道程序环境中，当存在多种I/O活动和多种进程活动时，<strong>缓冲可以提高操作系统效率</strong>，提高单个进程的性能</li></ul><p>缓冲缓解I/O设备速度与CPU速度不匹配的<strong>原理</strong>:</p><ul><li><strong>在输入请求发出前开始输入传送</strong></li><li><strong>在输出请求发出后一段时间后才开始执行输出传送</strong></li></ul><p>I/O设备<strong>传输方式</strong>分类:<br /><img src="block_stream.png" alt="不同传输方式" /></p><ul><li><strong>面向块的设备</strong>: 以<strong>数据块为传输单位</strong>，采用<strong>DMA</strong>或<strong>I/O通道</strong>方式控制I/O，传送完一块或一组数据才中断</li><li><strong>面向流的设备</strong>: 以<strong>字节、字或一行为传输单位</strong>，采用<strong>中断驱动</strong>的I/O控制方式，每传送完一个字节、一个字或一行就产生中断</li></ul><p>以下均为输入，输出同理<br /><img src="no_buffer.png" alt="无缓冲(T: 传输数据到用户内存的时间，C: 计算时间)" /><br /><strong>无缓冲时</strong>，应用程序直接访问I/O设备，<strong>需要等设备将数据传送到内存，再计算</strong>，每块数据处理时间为: <strong>T + C</strong></p><p><img src="single_buffer.png" alt="单缓冲(T: 传输数据到系统缓存时间，M: Move数据从内存缓冲区到用户内存的时间，C: 计算时间)" /><br /><strong>单缓冲时</strong>，应用程序从缓冲区拿数据，<strong>计算数据时，下一块数据正在传送到缓冲区，因此影响处理时间的为计算时间和传送时间中较大的那个，取走数据后才能将数据输入到缓冲区，因此要加上取数据时间</strong>，每块数据处理时间为: <strong>Max(T, C) + M</strong></p><p><img src="double_buffer.png" alt="双缓冲(T: 传输数据到用户内存的时间，C: 计算时间)" /><br /><strong>双缓冲时</strong>，应用程序从缓冲区拿数据，<strong>在应用程序从一个缓冲区取数据时，另一个缓冲区可以开始传送新数据，因此影响处理时间的为计算时间和传送时间中较大的那个</strong>，每块数据处理时间为: <strong>Max(T, M + C)</strong></p><p><strong>循环缓冲</strong>: <strong>使用两个或多个缓冲区构成循环缓冲</strong>，当希望I/O操作跟上进程执行速度时，使用循环缓冲，原理与双缓冲相同<br /><img src="circle_buffer.png" alt="循环缓冲" /></p><h3 id="spooling"><a class="markdownIt-Anchor" href="#spooling"></a> SPOOLing</h3><p><strong>SPOOLing(Simultaneous Peripheral Operating On Line, 假脱机操作)技术</strong>: 在<strong>磁盘中建立I/O缓冲区(上一节为内存缓冲)</strong>，缓和CPU的高速性与I/O设备低速性间的矛盾<br />同时<strong>通过SPOOLing技术便可将一台独占物理I/O设备虚拟为多台逻辑I/O设备</strong>，从而允许多个用户<strong>共享一台物理I/O设备</strong></p><p>SPOOL结构:</p><ul><li>输入/输出进程: <strong>应用程序</strong>，需求使用I/O设备进行输入/输出</li><li>输入井/输出井: <strong>磁盘上的一块空间</strong></li><li>输入缓冲区/输出缓冲区: <strong>内存中一块空间</strong></li></ul><p>SPOOLing<strong>思想</strong>:</p><ul><li><strong>输入</strong>:<ol><li>将用户需要数据通过<strong>输入设备送到输入缓冲区</strong></li><li>将输入缓冲区内的<strong>数据送到输入井</strong></li><li>当CPU需要数据时，将<strong>数据从输入井送到内存中(不是输入缓冲区，是应用程序自己的内存)</strong></li></ol></li><li><strong>输出</strong>:<ol><li>将用户需要输出的<strong>数据送到输出井中</strong></li><li>当输出设备空闲时，将<strong>输出井数据送到输出缓冲区中</strong></li><li>将<strong>输出缓冲区数据输出到输出设备中</strong></li></ol></li></ul><p>SPOOLing技术<strong>分析</strong>:</p><ul><li>通过SPOOLing技术，对应用程序而言，<strong>与I/O设备直接打交道的的低速</strong>提升到了<strong>与磁盘打交道的相对高速</strong>来</li><li>同时，<strong>没有为任何进程实际分配设备</strong>，只是在输入井/输出井中为进程分配一个存储区和建立一张I/O请求表，因此<strong>将独占设备改造为共享设备</strong></li><li>在输入井/输出井中可以进行排队，<strong>一台独占物理设备变换为若干台逻辑设备</strong>，因此<strong>实现了虚拟设备功能</strong></li></ul><h2 id="磁盘调度"><a class="markdownIt-Anchor" href="#磁盘调度"></a> 磁盘调度</h2><h3 id="磁盘结构"><a class="markdownIt-Anchor" href="#磁盘结构"></a> 磁盘结构</h3><p><img src="disk.png" alt="磁盘" /></p><ul><li>磁盘设备可包括一或多个物理盘片，每个磁盘片分一个或两个<strong>盘面</strong>(surface)</li><li>每个磁盘面被组织成若干个同心环，这种环称为<strong>磁道</strong>(track)</li><li>每条磁道逻辑上划分成若干个<strong>扇区</strong>(sectors)</li><li>不同盘面相同的磁道成为<strong>柱面</strong>(cylinder)</li></ul><h3 id="磁盘性能参数"><a class="markdownIt-Anchor" href="#磁盘性能参数"></a> 磁盘性能参数</h3><b><p>读写数据流程:</p><ol><li>寻道: 磁头径向移动到指定的磁道</li><li>旋转: 在磁头固定不动的情况下，盘片旋转直到扇区在磁头下停止</li><li>读写: 通过载体运动产生感应电压从而进行读取数据或磁头加电流进行写操作</li></ol></b><p>因此<b>平均存取时间: T = 平均寻道时间 + 平均旋转等待时间 + 数据传输时间</b></p><p><strong>寻道时间</strong>: 在磁头可移动系统中，将磁头臂<strong>移动到指定磁道</strong>所需的时间，<strong>一般由生产商给出</strong><br /><strong>旋转等待时间</strong>: 将待访问的<strong>扇区移动到磁头位置</strong>所花时间称为旋转时间，可<strong>由转速计算得到</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">T = \frac{1}{2} \times \frac{1}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>r为转速，单位为rps</strong><br />例如对于一个<strong>转速为3600r/m</strong>的硬盘而言，<strong>其每旋转一周的时间为16.6ms，其平均旋转延迟为8.3ms</strong><br /><strong>数据传输时间</strong>: 向磁盘传送或从磁盘传送数据的时间，取决于<strong>磁盘的转速</strong>和<strong>一个磁道的字节数</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mo>×</mo><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T = \frac{b}{r\times N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.14077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>b为要传送的字节数，r为旋转速度，N为一个磁道中的字节数</strong></p><p>例题:<br />考虑一个典型的磁盘，平均寻道时间为4ms，转速为7500r/m，每个磁道有500个扇区，每个扇区有512个字节。假设有一个文件存放在2500个扇区上，估算下列两种情况下读取该文件需要的时间<br />(1)2500个扇区分别位于5个相邻磁道上，且文件按扇区顺序存放<br />(2)2500个扇区随机分布</p><p><strong>答</strong>:<br />转速 = 7500r/m = 125r/s<br /><strong>(1)</strong>: 转一圈需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>125</mn></mfrac><mo>=</mo><mn>8</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{1}{125}=8ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，2500个扇区分别在相邻的5个磁道上，因此<strong>寻道只需要一次</strong>共4ms，每个磁道均需要旋转到起始位置，旋转时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>×</mo><mn>8</mn><mi>m</mi><mi>s</mi><mo>=</mo><mn>4</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2} \times 8ms = 4ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，总共5个磁道共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>m</mi><mi>s</mi><mo>×</mo><mn>5</mn><mo>=</mo><mn>20</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">4ms \times 5 = 20ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，每个磁道需要8ms来传输共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mi>m</mi><mi>s</mi><mo>×</mo><mn>5</mn><mo>=</mo><mn>40</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">8ms \times 5 = 40ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，因此总时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn><mi>m</mi><mi>s</mi><mo>+</mo><mn>20</mn><mi>m</mi><mi>s</mi><mo>+</mo><mn>40</mn><mi>m</mi><mi>s</mi><mo>=</mo><mn>64</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T = 4ms + 20ms + 40ms = 64ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span><br /><strong>(2)</strong>: 2500个扇区随机分布，因此每个扇区均需要寻道共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>m</mi><mi>s</mi><mo>×</mo><mn>2500</mn><mo>=</mo><mn>10000</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">4ms \times 2500 = 10000ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，每个扇区均需要旋转到起始位置，总共2500个扇区共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>m</mi><mi>s</mi><mo>×</mo><mn>2500</mn><mo>=</mo><mn>10000</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">4ms \times 2500 = 10000ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，每个扇区的读写时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>8</mn><mi>m</mi><mi>s</mi></mrow><mn>500</mn></mfrac><mo>=</mo><mn>0.016</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{8ms}{500} = 0.016ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，共2500个扇区需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.016</mn><mo>×</mo><mn>2500</mn><mo>=</mo><mn>40</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">0.016 \times 2500 = 40ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，因此总时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>10000</mn><mi>m</mi><mi>s</mi><mo>+</mo><mn>10000</mn><mi>m</mi><mi>s</mi><mo>+</mo><mn>200</mn><mi>m</mi><mi>s</mi><mo>=</mo><mn>20040</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T = 10000ms + 10000ms + 200ms = 20040ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span></p><h3 id="磁盘调度-2"><a class="markdownIt-Anchor" href="#磁盘调度-2"></a> 磁盘调度</h3><p><img src="disk_scheduling.png" alt="磁盘调度策略" /></p><h4 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h4><p>思想: 根据<strong>进程请求访问磁盘的先后顺序</strong>，处理队列中的访问需求<br /><img src="FIFO.png" alt="示例" /></p><h4 id="pri"><a class="markdownIt-Anchor" href="#pri"></a> PRI</h4><p>思想: 调度的控制不属于磁盘管理软件的范畴，目标不是优化磁盘的利用，而是满足操作系统的其他需求</p><h4 id="lifo"><a class="markdownIt-Anchor" href="#lifo"></a> LIFO</h4><p>思想: Last In First Out，<strong>优先处理新到请求</strong>，大量请求到达导致磁盘忙碌时，会出现先到请求的饥饿</p><h4 id="sstf"><a class="markdownIt-Anchor" href="#sstf"></a> SSTF</h4><p>思想: Shortest Service Time First，<strong>选择最短寻道时间的请求(选择离磁头最近的磁道)</strong><br /><img src="SSTF.png" alt="示例" /></p><h4 id="scan"><a class="markdownIt-Anchor" href="#scan"></a> SCAN</h4><p>思想: <strong>扫描式寻道，磁头只沿着一个方向移动</strong>，在移动途中满足所有未完成的请求，<strong>直到到达移动方向的尽头(改进为在这个方向上没有其他请求则是LOOK)</strong>，然后<strong>掉头</strong>，沿反方向扫描<br /><img src="SCAN.png" alt="示例" /></p><h4 id="c-scan"><a class="markdownIt-Anchor" href="#c-scan"></a> C-SCAN</h4><p>思想: Circular SCAN，与SCAN相同，但限定只朝一个方向扫描，即在沿指定方向扫描到磁盘最后一个磁道时，<strong>磁臂返回到反方向末端(改进为返回到反方向第一个有请求的磁道则是C-LOOK)</strong>，再次沿指定方向扫描<br /><img src="C_SCAN.png" alt="示例" /></p><h4 id="n-step-scan"><a class="markdownIt-Anchor" href="#n-step-scan"></a> N-Step-SCAN</h4><p>SSTF、SCAN和C-SCAN具有磁头臂黏着现象： 当<strong>一个或多个进程对同一个磁道有较高访问速度时</strong>，<strong>磁头臂黏在相应磁道上不移动</strong><br />N-Step-SCAN将磁盘访问请求序列<strong>分为若干个子队列</strong>，每个子队列的长度为N，<strong>每次使用SCAN方法处理一个队列</strong><br />当前队列正在处理时，<strong>新到的访问请求必须加到其他队列中</strong></p><ul><li>N较大时，性能接近SCAN(但不会出现磁头臂黏着现象)</li><li>N = 1时，就是FIFO</li></ul><h4 id="fscan"><a class="markdownIt-Anchor" href="#fscan"></a> FSCAN</h4><p>使用两个子队列，当<strong>扫描开始时，所有请求都放在一个队列中</strong>，另一个队列为空，<strong>扫描过程中，新到的请求被放到另外一个队列中</strong>，当原来队列里的请求处理完毕时，才会处理另一个队列里的请求</p><h3 id="raid"><a class="markdownIt-Anchor" href="#raid"></a> RAID</h3><p>RAID: 独立磁盘冗余阵列，有0~6不同等级，提供了**容错(fault-tolerance)<strong>和</strong>逻辑数据备份(logical data redundancy)**技术</p><h4 id="raid0"><a class="markdownIt-Anchor" href="#raid0"></a> RAID0</h4><p><img src="RAID0.png" alt="RAID0" /></p><h4 id="raid1"><a class="markdownIt-Anchor" href="#raid1"></a> RAID1</h4><p><img src="RAID1.png" alt="RAID1" /></p><h4 id="raid2"><a class="markdownIt-Anchor" href="#raid2"></a> RAID2</h4><p><img src="RAID2.png" alt="RAID2" /></p><h4 id="raid3"><a class="markdownIt-Anchor" href="#raid3"></a> RAID3</h4><p><img src="RAID3.png" alt="RAID3" /></p><h4 id="raid4"><a class="markdownIt-Anchor" href="#raid4"></a> RAID4</h4><p><img src="RAID4.png" alt="RAID4" /></p><h4 id="raid5"><a class="markdownIt-Anchor" href="#raid5"></a> RAID5</h4><p><img src="RAID5.png" alt="RAID5" /></p><h4 id="raid6"><a class="markdownIt-Anchor" href="#raid6"></a> RAID6</h4><p><img src="RAID6.png" alt="RAID6" /></p><h3 id="磁盘cache"><a class="markdownIt-Anchor" href="#磁盘cache"></a> 磁盘cache</h3><p><span style="color:#ff562b"><b><br />cache是通过将高速的存储器放置在CPU内部从而将一部分常用的内存放入其中，进而满足内存低速与CPU高速之间的不平衡<br />磁盘cache原理相同，是在内存中开辟一块空间，用来放置磁盘某些常用扇区的备份，以平衡内存的高速与磁盘的低速</b></span><br /><img src="disk_cache.png" alt="磁盘cache" /></p><p>与cache相同，磁盘cache满后也需要置换算法选择扇区进行置换，磁盘cache最常用LRU和LFU算法</p><h4 id="lru"><a class="markdownIt-Anchor" href="#lru"></a> LRU</h4><p>思想: <strong>位于磁盘高速缓存中最近最少使用的块被换出</strong>，是局部性原理的实际运用<br /><img src="LRU.png" alt="LRU性能" /></p><h4 id="lfu"><a class="markdownIt-Anchor" href="#lfu"></a> LFU</h4><p>思想: <strong>置换访问次数最少的块</strong>，如果一个块短期内被频繁访问，计数器值迅速增加，之后即使长时间不访问，也不会被选作置换对象，因此需要<strong>将磁盘cache分区</strong><br /><img src="LFU_partition.png" alt="LFU分区" /><br />位于<strong>新区中的快访问计数器不会增加</strong>，<strong>只有老区符合置换条件</strong>，<strong>中区可以增加自己的访问计数器</strong>，增加的快的不会进入老区，也就不会被置换</p><p><img src="LFU.png" alt="LRU性能" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1><p>内存管理: <strong>关注内存和外存之间的信息流的组织</strong>，简单来说就是关注<strong>进程在什么时候将进程放入内存和内存中如何放置</strong></p><h2 id="基本内存管理"><a class="markdownIt-Anchor" href="#基本内存管理"></a> 基本内存管理</h2><p>基本内存管理指不使用虚存技术，也不使用高速存储技术(cache)，仅有内存和外存作为存储设备时，OS对内存的管理</p><h3 id="程序的加载与链接"><a class="markdownIt-Anchor" href="#程序的加载与链接"></a> 程序的加载与链接</h3><p>高级语言由源代码转换为进程需要<strong>3个步骤</strong>:</p><ul><li><strong>编译</strong>: 由<strong>编译器将源代码转为机器指令</strong>，其中源代码会被<strong>编译为多个模块</strong>(某些库文件是单独模块)</li><li><strong>链接</strong>: 将编译出的<strong>多个模块链接到一起形成加载模块(包含完整程序和数据模块)</strong></li><li><strong>加载</strong>: 由<strong>加载程序将加载模块装入内存</strong></li></ul><h4 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h4><p>链接的方式有<strong>3种</strong>:</p><ul><li>静态链接</li><li>加载时动态链接</li><li>运行时动态链接</li></ul><h5 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h5><p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个<strong>完整的装配模块</strong>(又称执行模块)，以后不再拆开<br />静态链接即将所有目标模块和库函数<strong>打包为一个模块</strong>，在打包时链接器需要:</p><ul><li><strong>修改相对地址</strong>: 由编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，在<strong>链接成一个加载模块时修改模块的相对地址</strong></li><li><strong>变换外部引用地址</strong>: 将每个模块中所用的<strong>外部调用符号也都变换为相对地址(加载模块内部的相对地址)</strong></li></ul><p>缺点:</p><ul><li><strong>不利于代码共享</strong>: 不同应用使用同一个模块，但该模块被多次分别打包入不同加载模块</li><li><strong>不利于模块的独立升级</strong>: 每次对某个目标模块的修改升级，都要打开整个加载模块</li><li><strong>浪费存储空间和处理器时间</strong>: 可能链接一些不会执行的模块</li></ul><h5 id="加载时动态链接"><a class="markdownIt-Anchor" href="#加载时动态链接"></a> 加载时动态链接</h5><p>待加载的模块在加载内存时，如果该模块中有到外部模块的引用，<strong>加载程序将查找这些模块并加载内存</strong>，并把这些引用修改为相对应用程序模块开始处的相对地址<br /><strong>加载时动态链接的模块链接由加载程序完成，链接器只完成了对外部模块引用的声明</strong></p><p>优点:</p><ul><li><strong>便于各个模块的独立升级</strong>: 重新编译新模块后<strong>将加载模块重新加载</strong>即可</li><li><strong>便于实现模块的共享</strong>: 共享的模块只需在内存中保留一份即可</li></ul><p>缺点:</p><ul><li><strong>浪费存储空间和处理器时间</strong>: 可能链接一些不会执行的模块</li><li><strong>模块加载后不能移动位置</strong>: 因为仅在加载时重定位，若移动则地址错误</li></ul><h5 id="运行时动态链接"><a class="markdownIt-Anchor" href="#运行时动态链接"></a> 运行时动态链接</h5><p>在程序执行中需要某目标模块时，<strong>由操作系统去找到该模块并将之加载内存</strong>，随后把它链接到调用者模块上，<strong>典型的就是Windows下dll文件</strong></p><p>凡在执行过程中未被用到的目标模块，不会被调入内存和被链接到加载模块上，这样不仅可<strong>加快程序的加载过程</strong>，而且<strong>可节省大量的内存空间</strong>，并且<strong>支持分段系统</strong>，是主流做法</p><h4 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h4><p>加载程序需要<strong>将可加载模块装入内存</strong>、<strong>将执行文件中的逻辑地址转化为内存物理地址的过程</strong></p><p>其中地址映射建立方式有<strong>3种</strong>:</p><ul><li>绝对加载方式</li><li>静态重定位</li><li>动态重定位</li></ul><h5 id="绝对加载"><a class="markdownIt-Anchor" href="#绝对加载"></a> 绝对加载</h5><p><strong>程序中的逻辑地址与实际内存地址完全相同</strong>，因此不同模块的地址在编码时就需要确定，由程序员进行完全掌控，在汇编语言中较为常见<br /><img src="absolutely_load.png" alt="绝对加载" /></p><p>优点: <strong>实现简单</strong>，无须进行逻辑地址到物理地址的变换</p><p>缺点:</p><ul><li>程序每次必须装入<strong>同一内存区</strong></li><li>程序员必须事先了解内存的使用情况，根据内存情况确定程序的逻辑地址</li><li>不适于多道程序系统</li></ul><h5 id="静态重定位"><a class="markdownIt-Anchor" href="#静态重定位"></a> 静态重定位</h5><p><strong>地址映射在程序加载时进行，以后不再更改程序地址</strong><br /><img src="static_load.png" alt="静态重定位" /></p><p>优点: 易实现，<strong>无需硬件支持</strong></p><p>缺点: 程序重定位后就<strong>不能移动</strong>，因而<strong>不能重新分配内存</strong>，不利于内存的有效利用</p><h5 id="动态重定位"><a class="markdownIt-Anchor" href="#动态重定位"></a> 动态重定位</h5><p>程序的地址转换不是在加载时进行，而是在程序运行时动态进行，在运行时<strong>通过重定位寄存器内的起始物理地址和指令或数据的逻辑地址计算其物理地址</strong><br /><img src="dynamic_load.png" alt="动态重定位" /></p><p>优点:</p><ul><li><strong>程序不必连续存放在内存中</strong>，可分散存储，<strong>可移动</strong></li><li>便于共享</li><li>有利于紧凑、碎片问题的解决</li></ul><p>缺点:</p><ul><li>需要硬件支持，实现存储管理的软件算法比较复杂</li><li>同一地址，可能多次转换</li></ul><h3 id="内存管理的需求"><a class="markdownIt-Anchor" href="#内存管理的需求"></a> 内存管理的需求</h3><h4 id="重定位"><a class="markdownIt-Anchor" href="#重定位"></a> 重定位</h4><p>因为程序员事先并不知道在某个程序执行期间会有其他哪些程序驻留在内存中，也不知道下一次装入内存的物理地址，因此需要将程序写为逻辑地址来表明程序功能，而OS需要将程序的逻辑地址转换为内存中的物理地址才能对程序进行执行<br />而<strong>将逻辑地址转为物理地址就叫重定位</strong></p><h4 id="保护"><a class="markdownIt-Anchor" href="#保护"></a> 保护</h4><p>指: <strong>进程以外的其他进程中的程序不能未经授权地访问</strong>(进行读操作或写操作)该进程的<strong>内存单元</strong><br />因此需要既支持重定位也支持保护的<strong>硬件</strong></p><h4 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h4><p>多个进程正在执行同一程序时，<strong>允许每个进程访问该程序的同一个副本</strong>，要比让每个进程有自己独立的副本更有利<br />因此需要既支持重定位也支持共享的机制</p><h4 id="逻辑组织"><a class="markdownIt-Anchor" href="#逻辑组织"></a> 逻辑组织</h4><p>内存被组织成一维线性空间，而没有外存的存在，在编写程序时不需要管理内外存交换</p><h4 id="物理组织"><a class="markdownIt-Anchor" href="#物理组织"></a> 物理组织</h4><p>而真实的物理组织是内外存的差异的，OS需要满足逻辑组织的需求，将两层存储结构间进行数据移动</p><h3 id="内存分区"><a class="markdownIt-Anchor" href="#内存分区"></a> 内存分区</h3><p>内存管理的主要操作是处理器把程序加载内存中执行<br />在基本内存管理中主要有4种分区方法，加上虚存技术后共6种分区方法，但总的来说只有<strong>2种分区思想</strong>: <strong>固定分区(分页是固定分区的升级思想)和动态分区(分段是动态分区的升级思想)</strong><br /><img src="partition.png" alt="分区方法" /></p><h4 id="固定分区"><a class="markdownIt-Anchor" href="#固定分区"></a> 固定分区</h4><p>固定分区的思想: 将除操作系统占用的内存，<strong>按照固定的大小分为不同的区域</strong>，<strong>区域的大小可以是均匀的也可以是不均的</strong><br /><img src="fixed_partition.png" alt="固定分区" /></p><p>如果每个区域大小相同:</p><ul><li><strong>程序可能太大而不能放到一个分区中</strong></li><li>内存的利用率非常低，因为<strong>小程序占用了比需求大的空间</strong>，从而产生<strong>内部碎片</strong>(区域内的空闲空间)</li></ul><p>不等大分区可以缓解内部碎片问题，同样如果将区域划分为很小，并且将进程也划分为与区域一样小的块，则可以将多个进程块装入不同区域(<strong>分页思路的来源</strong>)</p><p>固定分区存在的问题: 分区的数量在系统生成阶段已经确定，因而<strong>限制了系统活动(未挂起)进程的数量</strong></p><h4 id="动态分区"><a class="markdownIt-Anchor" href="#动态分区"></a> 动态分区</h4><p>动态分区就是<strong>分配与进程需求完全一致的空闲内存空间</strong>，因此分区大小和数量不固定<br />分段思路的来源: 将进程分为不同的模块，每个模块都由OS进行动态分区，这一个分区就是段</p><p><img src="dynamic_partition.png" alt="动态分区" /><br />动态分区方法在内存中产生越来越多的<strong>外部碎片</strong>(不同分区间的内存区域，但是由于太小而无法满足任何一个进程的需求从而浪费)</p><p>外部碎片的解决方法: 压缩技术: 在一段时间后或内存不能找出任何一块区域来满足需求时，<strong>OS将所有进程进行移动</strong>，将外部碎片全部清除掉从而得到新的一大块空间</p><h5 id="匹配算法"><a class="markdownIt-Anchor" href="#匹配算法"></a> 匹配算法</h5><p>动态分区会产生很多块空闲的空间，如果很多空间都能满足需求，<strong>如何选择哪块空间来满足需求</strong>则需要匹配算法</p><p><strong>首次匹配</strong><br />思想: <strong>从头开始扫描内存，选择大小足够的第一个可用块</strong><br />评价:</p><ul><li>为大作业分配大的内存空间创造条件</li><li>内存前端出现很多小的空闲分区，且每次查找都要经过这些分区</li></ul><p><strong>循环匹配</strong><br />思想: 从<strong>上一次放置的位置开始</strong>扫描内存，选择第一个大小足够的可用块<br />评价:</p><ul><li>比首次匹配性能差，常常在内存末尾分配空间，导致空闲的分区分布均匀</li><li>缺少大的空闲块，需要更多次数紧凑</li></ul><p><strong>最佳匹配</strong><br />思想: <strong>选择空间大小与需求最接近的空闲块分配</strong><br />评价:</p><ul><li>产生的外部碎片都很小</li><li>内存中形成很多小到无法满足任何分配需求的块，需要更频繁的进行内存压缩</li></ul><p><strong>最差匹配</strong><br />思想: <strong>选择满足需求的最大的空闲分区分配</strong><br />评价:</p><ul><li>每次分配留下的空闲空间较大，便于再次利用</li><li>大的空间不容易保留，对大作业不利</li></ul><p><img src="dynamic_partition_example.png" alt="匹配算法示例" /></p><h4 id="伙伴系统"><a class="markdownIt-Anchor" href="#伙伴系统"></a> 伙伴系统</h4><p>固定分区方案限制了活跃进程的数量。并且，如果分区大小与进程大小不匹配，则内存空间的利用率非常低<br />动态分区方案维护复杂，并且引入了紧凑的额外开销</p><p>因此出现了<strong>伙伴系统</strong>，其<strong>结合了固定分区与动态分区思想</strong>，<strong>每一次分区都是固定分区，但分的大小是根据需求来定的</strong></p><p>伙伴系统: 内存空间被视为一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>的块，每次分配的块的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>，L ≤ K ≤ U，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">2^L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span></span></span></span> = 分配的<strong>最小块的大小</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> =分配的<strong>最大块的大小</strong></p><p><img src="partner_system.png" alt="伙伴系统" /></p><h3 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h3><p>分页: <strong>将内存划分成大小固定、相等的块(称为页框)，且块相对较小，进程也划分成同样大小的块(称为页)</strong><br />页表: 操作系统为<strong>每个进程维护一个页表</strong>，<strong>页表固定存放在内存中</strong>，起始地址由PCB进行保存，并且由页表寄存器存放当前运行进程的页表的起始地址</p><p><img src="page.jpg" alt="页表" /><br />页表中记录了从逻辑地址到物理地址转换需要的<strong>对应关系——页号与页框号的映射</strong><br /><img src="logical_address.png" alt="分页逻辑地址" /><br />逻辑地址由<strong>页号</strong>和<strong>页内偏移</strong>组成，在<strong>进行逻辑地址转为物理地址过程中</strong>，根据页面将页号映射为页框号即可<br /><img src="page_mapping.png" alt="逻辑地址转物理地址" /></p><p><strong>逻辑地址的计算</strong><br />若给定一个<strong>逻辑地址空间中的地址为A</strong>，<strong>页面的大小为L</strong>，则<strong>页号P</strong>和<strong>页内地址d</strong>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>A</mi><mi>L</mi></mfrac><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mi>A</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>l</mi><mtext> </mtext><mi>L</mi></mrow><annotation encoding="application/x-tex">P = \lfloor \frac{A}{L} \rfloor, d = A \: mol \: L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p><p>如: 某系统的页面大小为1KB，设A = 2170 B，试计算其页号P与页内地址d</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mn>2170</mn><mn>1024</mn></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mn>2170</mn><mtext> </mtext><mi>m</mi><mi>o</mi><mi>l</mi><mtext> </mtext><mn>1024</mn><mo>=</mo><mn>122</mn></mrow><annotation encoding="application/x-tex">P = \lfloor \frac{2170}{1024} \rfloor = 2, d = 2170 \: mol \: 1024 = 122</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span></span></span></span></span></p><p>将结果转为二进制: 2 = <code>00 0010</code>，122 = <code>00 0111 1010</code>，因此逻辑地址为<code>0000 1000 0111 1010</code></p><p>分页的<strong>优点</strong>:</p><ul><li>存在页内碎片，但碎片相对较小，<strong>内存利用率较高</strong></li><li>实现了离散分配</li><li>无外部碎片</li></ul><p>分页的<strong>缺点</strong>:</p><ul><li>需要专门的硬件支持，尤其是<strong>快表(页面项放在cache中)</strong></li><li>不支持动态链接，不易实现共享</li></ul><h3 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3><p>分段: 将程序划分为几段，<strong>每段长度可以不相等</strong>但有最长限制，每个段都从0开始编址，并<strong>占用一段连续的地址空间</strong><br />段表: <strong>记录逻辑段和物理段的映射关系</strong></p><p><img src="segment.png" alt="段表" /><br />段表中同样也记录了记录了从逻辑地址到物理地址转换需要的<strong>对应关系——段号与段首址的映射关系</strong>，但段表比页表多了一个项，段长，<strong>如果段内偏移大于段长则出现了地址错误</strong><br /><img src="logical_address_2.png" alt="分段逻辑地址" /><br />逻辑地址由<strong>段号</strong>和<strong>段内偏移</strong>组成，在<strong>进行逻辑地址转为物理地址过程中</strong>，根据段号找到对应段首址，如果段内偏移小于段长，则将<strong>段首址加上段内偏移即可得到物理地址</strong>(相加时段内偏移高位补零)<br /><img src="segment_mapping.png" alt="逻辑地址转物理地址" /></p><p>分段的<strong>优点</strong>:</p><ul><li>便于程序模块化设计</li><li>便于动态链接</li><li>便于保护和共享</li><li>无内部碎片</li></ul><p>分段的<strong>缺点</strong>:</p><ul><li>地址转换需要硬件的支持——<strong>段表寄存器</strong></li><li>分段的最大尺寸受到主存可用空间的限制(可用虚存技术)</li><li>有外部碎片</li></ul><h3 id="分段与分页的比较"><a class="markdownIt-Anchor" href="#分段与分页的比较"></a> 分段与分页的比较</h3><ul><li><strong>页是信息的物理单位</strong>，分页的目的是实现离散分配，减少内存的外部碎片，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是<strong>信息的逻辑单位</strong>，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要</li><li><strong>页的大小固定且由系统决定</strong>，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而<strong>段的长度却不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li><li><strong>分页的作业地址空间是一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符(逻辑地址)，即可表示一个地址；而<strong>分段的作业地址空间则是二维的</strong>，程序员在标识一个地址时，既需给出<strong>段号</strong>，又需给出<strong>段内地址</strong></li><li><strong>分页存储管理系统不易实现共享，不支持运行时动态链接，而分段系统易于实现共享和动态链接</strong></li></ul><h2 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h2><p><strong>虚拟内存</strong>: 在存储分配机制中，辅<strong>存可被看作主存的一部分来完成寻址</strong>，<strong>程序使用的地址与内存物理存储的地址不同</strong>，程序生成的地址会自动转换为物理地址。虚拟存储的大小受计算机系统寻址机制和可用辅存容量的限制，<strong>而不受主存实际大小限制</strong><br /><strong>虚拟地址</strong>: 在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存的一部分那样，有时也称为逻辑地址(与基本内存管理逻辑地址相同)<br /><strong>虚拟地址空间</strong>: 分配给进程的<strong>虚拟存储</strong><br /><strong>地址空间</strong>: 用于某进程的<strong>内存地址范围</strong><br /><strong>实地址(物理地址)</strong>: <strong>内存中</strong>存储位置的地址</p><p><img src="page_segment.png" alt="分页和分段的特点" /></p><p>虚存技术最重要的是<span style="color:#ff562b"><b>无需将全部程序装入内存，而是只装入部分，其他部分在需要使用时再装入</b></span></p><p><strong>抖动: 即将要用到的块被换出，系统又得很快将它取回，导致页面被频繁地换入换出，缺页率急剧增加</strong><br />当内存空间几乎被进程块占据时，每读取一块，必须把另一块换出，<strong>如果出现抖动，处理器的大部分时间都用于交换而非执行指令</strong>，因此需要选择合适的<a href="#%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5">置换策略</a></p><h3 id="虚存的硬件与控制结构"><a class="markdownIt-Anchor" href="#虚存的硬件与控制结构"></a> 虚存的硬件与控制结构</h3><h4 id="局部性原理虚存的合理性"><a class="markdownIt-Anchor" href="#局部性原理虚存的合理性"></a> 局部性原理(虚存的合理性)</h4><p><strong>局部性原理</strong>: 存储器的访问呈簇(cluster)性(簇：一组程序或数据的集合)，在很长一段时间内，使用的簇会发生变化，但<strong>在很短的时间内，处理器基本上只与固定的簇打交道</strong></p><p><strong>如果发生缺页则进行中断，将页面从外存中调入内容</strong></p><p>解释:</p><ul><li>描述了进程中程序和数据引用的集簇倾向</li><li>在很短的时间内仅需要进程的一部分块</li><li>对将来可能会访问的块进行猜测，以避免抖动</li></ul><h4 id="虚拟分页"><a class="markdownIt-Anchor" href="#虚拟分页"></a> 虚拟分页</h4><p>虚拟内存通常与使用分页的系统联系在一起，并且分页的虚存方案中，<strong>页表项变得更复杂</strong></p><p>分页逻辑地址仍然为<strong>页号</strong>和<strong>页内偏移</strong>组成，其转换方法也仍然为将页号映射为页框号，<strong>但页表项发生了改变</strong><br /><img src="virtual_page_table_item.png" alt="页表项" /></p><ul><li><strong>P</strong>: <strong>存在位</strong>，表明对应的页是否在内存</li><li><strong>M</strong>: <strong>修改位</strong>，表明相应页上次装入内存到现在是否修改过</li></ul><p>然而虚拟分页的逻辑地址转为物理地址的过程仍与<a href="#%E5%88%86%E9%A1%B5">基本内存</a>中相同</p><h4 id="多级分页"><a class="markdownIt-Anchor" href="#多级分页"></a> 多级分页</h4><p>每个进程一个页表，如果<strong>进程的逻辑地址空间大，则页表庞大</strong>，例如每个进程虚存空间可达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>=4GB，若每个页大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>=1K字节，则需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个页表项，每个页表项为4字节，页表大小则总共需要4MB</p><p>因此可以将页表再次进行分级，<strong>次页表也放置于虚存中</strong>，可以减少对内存的占用，<strong>只有顶层页表放置在内存中以便查询</strong><br /><img src="two_level_page.png" alt="两级页表" /><br /><strong>因此逻辑地址的含义也发生了变化，高10位作为页表页号，中间10位作为页号，低12位作为页内偏移</strong><br /><img src="virtual_page_address.png" alt="两级页表逻辑地址" /></p><p>在逻辑地址转为物理地址时，则需要<strong>先根据根页表将页表页号转为页表的物理地址</strong>，再<strong>从页表中将页号转为页框号</strong>，最后得到物理地址<br /><img src="two_level_page_mapping.png" alt="两级页表逻辑地址转为物理地址" /></p><p>例题:<br />32位逻辑地址空间、4KB页面、4B页表项、求逻辑地址4197721的物理地址？<br /><img src="two_level_page_example.png" alt="根页表与页表" /><br />首先将<strong>逻辑地址</strong>4197721转为二进制<code>0000000001 0000000000 110101011001</code>，高10位为页表页号=1，中间10位为页表号为0，低12位为页内偏移<br />查表得，页表页号1转202，在202的页表内查询，页表号0转为505，将结果转为二进制505=<code>0111111001</code>，因此结果为<code>00000000000111111001 110101011001</code>=<strong>物理地址</strong>2071897</p><p><strong>注意最后的505是高22位！(因为505是页框号，是代表除页面偏移地址外的所有物理地址)</strong></p><p>当两级页表也十分大时，可以<strong>再次分级</strong>，形成多级页表，原理与二级页表相同，<strong>但会增加额外的存储空间，页表的级数越多，地址转换过程越复杂，转换的速度也越慢</strong></p><h4 id="倒置页表"><a class="markdownIt-Anchor" href="#倒置页表"></a> 倒置页表</h4><p><strong>倒置页表</strong>: 虚拟地址的<strong>页号部分使用一个简单的散列函数(hash)映射到散列表中，即将页号hash成页框号</strong><br />页表结构称为倒排的原因是，它<strong>使用页框号而非虚拟页号来索引页表项</strong><br />无论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分(即页框数量的部分)<br /><img src="hash_page.png" alt="倒置页表" /></p><h4 id="tlb快表"><a class="markdownIt-Anchor" href="#tlb快表"></a> TLB(快表)</h4><p>将一部分页表项放入cache中，以便快速使用<br />具体访存在<a href="https://thm-lab.github.io/2022/06/12/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%8Bcpu%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B">组成原理</a>中有所介绍<br /><img src="TLB.png" alt="带快表的地址转换" /></p><h4 id="页面大小"><a class="markdownIt-Anchor" href="#页面大小"></a> 页面大小</h4><p><strong>缺页率: 发生缺页的次数与总访问次数的比值</strong></p><p>在<strong>基本内存管理</strong>中，因为没有虚存技术，因此程序执行时所有的页都必须在内存中，页面小并不会带来什么严重后果，反而<strong>页面越小，内部碎片的总量越少</strong><br />然而在虚存中，页面越小，每个进程需要的页的数量越多，而页表也越大，<strong>一次内存访问可能产生两次缺页中断</strong>，因此页面大小会影响缺页率</p><p><img src="page_size.png" alt="缺页率" /><br /><img src="normal_page_size.png" alt="常见页面大小" /></p><h4 id="虚拟分段"><a class="markdownIt-Anchor" href="#虚拟分段"></a> 虚拟分段</h4><p>虚拟分段与基本内存<a href="#%E5%88%86%E6%AE%B5">分段</a>几乎没有区别，仅仅段表项进行了一点改变，增加修改位、存在位等属性<br /><strong>分段式逐渐被淘汰，虚拟分页为现代操作系统主流方式</strong></p><h4 id="段页式"><a class="markdownIt-Anchor" href="#段页式"></a> 段页式</h4><p><strong>段页式</strong>: 用户的地址空间<strong>被程序员划分为许多段</strong>，<strong>每段划分为许多固定大小的页</strong></p><ul><li>支持数据结构增长: 段长可变</li><li>支持共享和保护</li><li>消除外部碎片</li><li>有效利用内存</li></ul><b>每个进程一个段表、一个页表程序员的角度: 逻辑地址 = 段号 + 段内偏移量系统的角度: 段内偏移量 = 页号 + 页内偏移量</b><p><img src="page_segment_combination.png" alt="段页式" /></p><ol><li>先根据<strong>段表起始地址(段寄存器)<strong>和</strong>段号</strong>查找段表，得到<strong>对应段的页表起始地址</strong></li><li>根据页表起始地址和页号查找页表，得到<strong>页框号</strong></li><li>页框号和偏移量构成物理地址</li></ol><p>因此段页式需要<strong>访存3次</strong>:</p><ul><li>第一次，访问段表，从中获得该段的页表首址</li><li>第二次，访问页表，从中取出逻辑地址指定的页面所在的页框号，并将该页框号和页内偏移量相加，形成物理地址</li><li>第三次，根据物理地址，取出对应存储单元的指令或数据</li></ul><p><img src="page_segment_combination_mapping.png" alt="段页式逻辑地址转物理地址" /></p><h4 id="保护与共享"><a class="markdownIt-Anchor" href="#保护与共享"></a> 保护与共享</h4><p>分段有助于实现保护和共享机制:</p><ul><li><strong>保护</strong>: <strong>每个段都包括一个长度和一个基地址</strong>，可以控制非法访问(超出段长度会产生内存错误，不被处理器允许)</li><li><strong>共享</strong>: <strong>一个段可以在多个进程的段表中被引用</strong>，实现共享</li></ul><p>而分页对保护和共享并不友好:<br />假定每个页面4KB，160KB的共享代码需要40个页面<br />每个进程需要40个<strong>页表项</strong>来存储相应信息，开销160B(设定每个页表项4B)<br />共享部分作为一个段，每个进程仅需1个<strong>段表项</strong>来存放共享段信息，开销4B</p><h3 id="操作系统对虚存的管理"><a class="markdownIt-Anchor" href="#操作系统对虚存的管理"></a> 操作系统对虚存的管理</h3><h4 id="读取策略"><a class="markdownIt-Anchor" href="#读取策略"></a> 读取策略</h4><p><strong>读取策略: 决定某页何时进入内存</strong></p><ul><li><strong>请求调页(Demand Paging)</strong>:<ul><li><strong>仅在引用页面时</strong>，才把相应的页面调入内存</li><li>进程<strong>首次启动时</strong>，<strong>会发生很多缺页中断</strong></li><li>局部性原则表明，大多数将来访问的页面都是最近读取的页面，<strong>一段时间后，缺页中断会降低到很低的水平</strong></li></ul></li><li><strong>预调页(Prepaging)</strong>:<ul><li><strong>额外读取所缺页面以外的页面</strong></li><li><strong>考虑大多数辅助储设备</strong>的特性: 寻道、旋转延迟等</li><li>若进程的页面<strong>连续存储在辅存</strong>中，则一次读取多个页面会<strong>更有效</strong></li><li>如果额外读取的页面未使用，则低效</li></ul></li></ul><h4 id="放置策略"><a class="markdownIt-Anchor" href="#放置策略"></a> 放置策略</h4><p><strong>放置策略: 确定进程驻留在内存中的位置</strong><br />是分段系统中的重要设计内容，放置策略即动态分区中的<a href="#%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">匹配算法</a></p><h4 id="置换策略"><a class="markdownIt-Anchor" href="#置换策略"></a> 置换策略</h4><p><strong>置换策略: 读取新页时，若内存页面不足，具体淘汰哪个页面用以置换</strong></p><p>需要说明的是，OS提供<strong>页框锁定</strong>功能(对页框锁定位进行标记)，当页框被锁定时，当前存储在该页框中的页面不能被置换，一般用于保存<strong>操作系统内核</strong>和<strong>重要的数据结构</strong>，<strong>I/O缓冲区和时间要求严格的区域也可能保存在锁定的页框中</strong></p><p>常见置换策略:</p><ul><li>最优(OPT)</li><li>最近最少使用(LRU)</li><li>先进先出(FIFO)</li><li>时钟(Clock)</li></ul><h5 id="opt"><a class="markdownIt-Anchor" href="#opt"></a> OPT</h5><p>思想: <strong>置换下次访问距当前时间最长的页面</strong><br /><img src="OPT.png" alt="F表示所分配的页框在初始填满后产生缺页中断" /><br />但是在实际情况中很难得知页的访问顺序，因此OPT策略几乎无法使用</p><h5 id="lru"><a class="markdownIt-Anchor" href="#lru"></a> LRU</h5><p>思想: <strong>置换内存中最长时间未引用的页面</strong>(原理为局部性原理)<br /><img src="LRU.png" alt="F表示所分配的页框在初始填满后产生缺页中断" /><br /><strong>LRU的最大问题在于其开销大</strong>，需要每页添加最近访问时间戳或建立链表来<strong>记录访问</strong></p><h5 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h5><p>思想: <strong>将页框视为队列，置换驻留在内存中时间最长的页面</strong><br /><img src="FIFO.png" alt="F表示所分配的页框在初始填满后产生缺页中断" /><br />实现简单</p><h5 id="clock"><a class="markdownIt-Anchor" href="#clock"></a> Clock</h5><p>思想: <strong>是一种最近未使用算法，置换的页面都是最近没有使用的那个</strong><br />方法:</p><ul><li>每个页框关联一个使用位U(也称访问位)</li><li>当页面<strong>首次加载</strong>到内存中或<strong>被引用</strong>时，<strong>使用位U设置为1</strong></li><li>发生缺页中断时，检查表针指向页面<ul><li>如果使用位为0，则<strong>新页面替换之</strong>，<strong>表针前移一个位置</strong></li><li>如果使用位为1，则<strong>清0</strong>，<strong>表针前移一个位置</strong></li><li><strong>一直循环，直到置换完成</strong></li></ul></li></ul><p><img src="Clock.png" alt="F表示所分配的页框在初始填满后产生缺页中断，*表示使用位为1" /></p><p>改进的Clock策略<br />除了使用位U，每个页框还有修改位M</p><ol><li>从指针当前位置开始扫描，这次扫描对使用位不作任何修改，选择遇到的第一个页框(U = 0, M = 0)置换</li><li>若第1步失败，重新扫描，选择遇到的第一个(U = 0, M = 1)的页框置换。这一过程中，将使每个扫描过的页框U置0</li><li>若第2步失败，则再次重新扫描，重复第1步，并在必要时重复第2步</li></ol><p>改进Clock置换的优先级(从高到低):</p><ul><li>(U = 0, M = 0)</li><li>(U = 1, M = 0)</li><li>(U = 0, M = 1)</li><li>(U = 1, M = 1)</li></ul><p><img src="efficiency.png" alt="页框数与缺页率在不同置换策略下的关系" /><br />可以看出LRU在实际情况中效果最好，FIFO效果最差并且可能出现Belay异常</p><h5 id="页缓冲"><a class="markdownIt-Anchor" href="#页缓冲"></a> 页缓冲</h5><p>置换的页，如果要写回辅存，代价较大，因此在内存中有一批专用页框，分别为<strong>空闲页</strong>和<strong>修改页</strong><br /><strong>当有页需要被置换时，如果页未被修改，则放入空闲页链表的尾部，如果页已被修改，则放入修改页链表的尾部</strong><br /><strong>空闲页链表满后仍然按照一定的置换策略进行置换，而修改页链表满后成批写回辅存</strong></p><p>对于较大的cache，如果置换页在cache中则会对性能产生影响，因为cache及内存中所对应的页<strong>都将失效</strong><br />因此在使用页缓冲的系统中，可以<strong>从页缓冲区中选择任意页框来放置从而提高高速缓存性能</strong></p><h4 id="驻留集管理"><a class="markdownIt-Anchor" href="#驻留集管理"></a> 驻留集管理</h4><h5 id="驻留集大小"><a class="markdownIt-Anchor" href="#驻留集大小"></a> 驻留集大小</h5><p><strong>页框分配</strong>: 即给每个活动进行分配多少个页框</p><ul><li><strong>分配给每个进程的内存越小，可以驻留在内存中的进程越多</strong></li><li><strong>一个进程在内存中的页面少，则缺页率相对较高</strong></li><li>进程分配的页框数超出一定大小后，由于局部性原理，<strong>缺页率下降到稳定水平</strong></li></ul><p>页框分配有<strong>2种方式</strong>:</p><ul><li><strong>固定分配</strong>: 在内存中为进程提供<strong>固定数量的页框</strong>，发生缺页时，<strong>必须替换该进程的其中一个页面</strong></li><li><strong>可变分配</strong>: 允许分配给进程的页框数在进程的生命周期内变化，发生缺页时<strong>可以通过增加驻留集大小(即置换掉其他进程的页面)来调入页面</strong></li></ul><h5 id="置换范围"><a class="markdownIt-Anchor" href="#置换范围"></a> 置换范围</h5><p>置换范围: 计划置换的页集局限于产生<strong>缺页的进程本身(局部)</strong>，还是<strong>内存内的所有非锁定进程(全局)</strong></p><p><img src="residence_replace.png" alt="组合" /></p><p><strong>固定分配，局部置换</strong></p><ul><li><strong>页框数大</strong><ul><li><strong>增加了处理器的空闲时间</strong>(内存中进程少)</li><li><strong>增加了花在交换上(swapping)的时间</strong></li></ul></li><li><strong>页框数小</strong><ul><li><strong>缺页率高</strong></li></ul></li></ul><p><strong>可变分配，全局置换</strong>，是主流方法</p><ul><li>实现容易</li><li>选择置换对象不当，将容易再次产生缺页中断(<strong>页缓冲可以缓解问题</strong>)</li></ul><p><strong>可变分配，局部置换</strong></p><ul><li>当缺页中断发生时，<strong>从进程驻留集中选择一页用于置换</strong></li><li>不时重新评估进程的页框分配情况，增加或减少分配的页框，以提高整体性能</li></ul><h5 id="工作集"><a class="markdownIt-Anchor" href="#工作集"></a> 工作集</h5><p><strong>工作集</strong>: 进程在虚拟时间t的参数为Δ的工作集W(t, Δ)，表示<strong>该进程在从t开始往前的的Δ个虚拟时间单位被访问到的页集合</strong><br />虚拟时间窗口Δ越大，则工作集越大</p><p><img src="working_set.png" alt="工作集示例" /></p><p>对于固定的Δ，工作集大小随时间变化的情况: <strong>稳定阶段和快速变化阶段交替出现</strong><br /><img src="time_working_set.png" alt="工作集大小变化" /></p><p>根据工作集来决定驻留集的大小: <strong>周期性的从驻留集中移去不在工作集中的页(近似LRU)</strong></p><h4 id="清除策略"><a class="markdownIt-Anchor" href="#清除策略"></a> 清除策略</h4><p><strong>清除策略: 用于确定何时将修改过的页写回辅存</strong></p><ul><li><strong>按需清除(Demand Cleaning)</strong>: <strong>只有当一页被选择用于置换时才被写回辅存</strong>，发生缺页中断的进程在解除阻塞前需等待两次页传送(没有页缓冲): 写回修改页+读入新页</li><li><strong>预清除(Precleaning)</strong>: 将<strong>修改的多页</strong>在需要使用它们占据页框之前，<strong>成批写回辅存</strong>，但预先写回辅存的页，在置换前可能又会被修改，使得预清除意义不大</li></ul><p><strong>结合页缓冲技术后，只清除用于置换的页，已修改表中的页可以成批写回辅存</strong></p><h4 id="负载控制"><a class="markdownIt-Anchor" href="#负载控制"></a> 负载控制</h4><p><strong>负载控制: 决定驻留在内存中的进程的数量</strong></p><ul><li><strong>L=S准则</strong>: <strong>发生缺页的平均时间L等于处理缺页故障的平均时间S，此时处理器的利用率最大</strong></li><li><strong>监测Clock算法中指针扫描的速度</strong>:<ul><li>速度低，缺页率低，增加多道程序度</li><li>速度高，缺页率高或多道程序度高，降低多道程序度</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程管理</title>
    <link href="/2023/02/10/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/10/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1><h2 id="描述与控制"><a class="markdownIt-Anchor" href="#描述与控制"></a> 描述与控制</h2><p>进程的<strong>定义</strong>:</p><ul><li>一个<strong>正在执行的程序</strong></li><li>一个<strong>正在</strong>计算机上执行的<strong>程序实例</strong></li><li>能<strong>分配给处理器并由处理器执行的实体</strong></li><li>由一组执行的<strong>指令</strong>、一个<strong>当前状态</strong>和一组相关的<strong>系统资源</strong>表征的活动单元</li></ul><p>进程的<strong>基本特征</strong>:</p><ul><li><strong>动态性(本质特性)</strong>: 正在计算机上执行的程序实例，<strong>存在生命周期</strong></li><li><strong>并发性(重要特性)</strong>: 任何进程都可以同其他进程<strong>一起</strong>向前推进</li><li><strong>独立性</strong>: 各进程的<strong>地址空间相互独立</strong>，除非采用进程间通信手段</li><li><strong>异步性</strong>: 按<strong>各自独立的、不可预知</strong>的速度向前推进</li></ul><p>进程与程序的<strong>区别</strong>:<br /><b></p><ul><li>程序是静态的，而进程是动态的</li><li>进程包括了程序相关的数据</li><li>一个应用程序的执行可能有多个进程</li></ul></b><h3 id="进程结构"><a class="markdownIt-Anchor" href="#进程结构"></a> 进程结构</h3><p><strong>进程 = 程序代码 + 相关数据 + 进程控制块(PCB, Process Control Block)</strong><br /><strong>进程映像(Process Image) = 程序代码段 + 数据 + PCB + 栈</strong><br /><img src="process_image.png" alt="进程映像在虚存中结构" /></p><h4 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h4><p>进程控制块<strong>包含了充分的信息</strong>， 因此可以中断一个进程的执行，并在后来恢复进程的执行，就好像进程未被中断过那样，PCB是OS<strong>支持多进程并提供多重处理技术</strong>的关键工具</p><p><strong>PCB的内容</strong>:<br /><b></p><ul><li>进程标识信息</li><li>处理器状态信息</li><li>进程控制信息</li></ul></b><h5 id="进程标识信息"><a class="markdownIt-Anchor" href="#进程标识信息"></a> 进程标识信息</h5><p>操作系统控制的许多表可以使用<strong>进程标识符</strong>来引用进程表</p><ul><li>说明内存、I/O设备和文件分配给了<strong>哪个进程</strong></li><li>内存表、I/O和文件表都可以引用进程标识符，进而交叉引用<strong>进程表</strong></li><li>进程通信时，标识通信目标</li><li>指明每个进程的父进程和子进程</li></ul><p><strong>典型进程标识信息</strong>:</p><ul><li><strong>唯一的进程ID</strong></li><li><strong>父进程(创建该进程的进程)ID</strong></li><li><strong>用户ID</strong></li></ul><h5 id="处理器状态信息"><a class="markdownIt-Anchor" href="#处理器状态信息"></a> 处理器状态信息</h5><p>包括<strong>通用寄存器内容</strong>与<strong>标志寄存器内容</strong>，可以帮助处理器<strong>恢复现场</strong></p><p><strong>典型处理器状态信息</strong>:</p><ul><li><strong>用户可见寄存器</strong>内容: 部分通用寄存器(<strong>IA-32的EAX、EBX、ECX、EDX、ESI、EDI</strong>)</li><li><strong>栈寄存器</strong>内容: 每个进程有一个或多个与之相关联的后进先出(LIFO)系统栈，栈用于保存参数和过程调用或系统调用的地址(<strong>IA-32的ESP、EBP</strong>)</li><li><strong>标志寄存器</strong>内容: 程序计数器(<strong>EIP</strong>)和条件码寄存器(<strong>EFLAGS</strong>)</li></ul><h5 id="进程控制信息"><a class="markdownIt-Anchor" href="#进程控制信息"></a> 进程控制信息</h5><p>是操作系统<strong>控制和协调各种活动进程所需的额外信息</strong></p><p><strong>典型进程控制信息</strong>:</p><ul><li><strong>调度和状态</strong>信息:<ul><li><strong>进程状态</strong>：如运行态、就绪态、等待态、停止态</li><li><strong>优先级</strong>：描述进程调度优先级的一个或多个域</li><li><strong>调度相关信息</strong>：具体取决于所用的调度算法，如进程等待的时间总量和进程上次运行的执行时间总量</li><li><strong>事件</strong>：进程在继续执行前等待的事件标识</li></ul></li><li><strong>数据结构</strong>信息: 进程可以以排队、环或其他数据结构链接到其他进程(如链表指向的下一个进程ID)</li><li><strong>进程间通信</strong>: 各种标记、信号和信息可与两个无关进程间的通信关联</li><li><strong>进程特权</strong>: 进程根据其可以访问的内存和可执行的指令类型来赋予特权</li><li><strong>存储管理</strong>: 包括指向描述分配给该进程的虚存的段表和/或页表的指针</li><li><strong>资源所有权和使用情况</strong>: 指示进程控制的资源(IO资源等)</li></ul><h3 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h3><h4 id="两状态模型"><a class="markdownIt-Anchor" href="#两状态模型"></a> 两状态模型</h4><p><img src="two_state_process_model.png" alt="两状态模型" /></p><ul><li><strong>创建</strong>: 一个新进程添加到正被管理的进程集时，操作系统需要<strong>建立用于管理该进程的数据结构(PCB)</strong>，并<strong>在内存中给它分配地址空间</strong>，这些行为构成了一个新进程的创建过程<br /><img src="enter.png" alt="创建进程原因" /></li><li><strong>终止</strong>: 由<strong>批处理程序显式调用</strong>或<strong>用户指出进程</strong>何时结束，或<strong>进程进行非法操作时由OS进行终止</strong><br /><img src="exit.png" alt="终止进程原因" /></li></ul><p><img src="two_state_process_queuing.png" alt="两状态模型排队" /><br />当多进程需要处理时，未运行进程在<strong>创建队列进行排队</strong></p><h4 id="五状态模型"><a class="markdownIt-Anchor" href="#五状态模型"></a> 五状态模型</h4><p><img src="five_state_process_model.png" alt="五状态模型" /></p><ul><li><strong>新建(New)</strong>: 刚刚创建的进程，操作系统还<strong>未把它加入可执行进程组</strong>，它通常是<strong>进程控制块己经创建但还未加载到内存中的新进程</strong></li><li><strong>就绪(Ready)</strong>: 进程做好了准备，<strong>只要有机会就开始执行</strong></li><li><strong>阻塞(Blocked)</strong>: 进程<strong>在某些事件发生前不能执行</strong>，如I/O操作完成</li><li><strong>运行(Runing)</strong>: 处理器<strong>正在执行该进程</strong></li><li><strong>退出(Eixt)</strong>: 操作系统<strong>从可执行进程组中释放出的进程</strong>，要么它自身<strong>已停止</strong>，要么它因某种原因<strong>被取消</strong></li></ul><p><img src="single_blocked_queue.png" alt="单阻塞队列" /><br /><strong>单阻塞队列: 所有阻塞进程位于一个阻塞队列</strong></p><p><img src="multiple_blocked_queue.png" alt="多阻塞队列" /><br /><strong>多阻塞队列: 不同事件对应一个阻塞队列</strong></p><p><img src="five_state_process_model_example.png" alt="五状态模型转换示例" /></p><p><span style="color:#ff562b"><b>多队列思想同样可以用于就绪队列！从而对就绪进程进行优先级分级</b></span></p><h4 id="带挂起状态模型"><a class="markdownIt-Anchor" href="#带挂起状态模型"></a> 带挂起状态模型</h4><p><img src="one_suspended_model.png" alt="单挂起态模型" /><br /><img src="two_suspended_model.png" alt="双挂起态模型" /></p><ul><li><strong>就绪/挂起(Ready/Suspended)</strong>: 进程<strong>己在外存</strong>中，但只要<strong>载入内存就可执行</strong></li><li><strong>阻塞/挂起(Blocked/Suspended)</strong>: 进程<strong>己在外存中并等待一个事件</strong></li></ul><p><img src="suspend.png" alt="挂起进程原因" /></p><h3 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h3><p>操作系统采用表格(或数据结构)来<strong>记载各资源的信息</strong>，从而实现对资源的管理、维护、更新等，同时进程表必须能被操作系统所访问，因此其<strong>受制于内存管理</strong><br /><img src="process_table.png" alt="进程表" /></p><h4 id="操作系统内核"><a class="markdownIt-Anchor" href="#操作系统内核"></a> 操作系统内核</h4><p>OS内核是<strong>操作系统中包含重要系统功能的部分</strong>，并且需要<strong>常驻内存，便于提高操作系统运行效能</strong></p><p><strong>内核功能</strong>:</p><ul><li><strong>资源管理功能</strong><ul><li>进程管理: 进程的创建、终止、调度、分派、切换、通信等</li><li>存储管理: 内存管理和内外存交换</li><li>I/O设备管理: 缓冲区管理和I/O通道的分配</li></ul></li><li><strong>支撑功能</strong><ul><li>中断处理</li><li>时钟管理</li><li>记账功能</li></ul></li></ul><p><strong>处理器模式</strong>:</p><ul><li><strong>用户模式</strong>: 具有较少优先权的模式，运行用户程序</li><li><strong>内核模式</strong>: 运行操作系统的内核，执行某些特权指令，访问某些内存空间</li></ul><p>使用两种模式可以<strong>保护操作系统和重要的操作系统表(如PCB)不受程序干扰</strong></p><h4 id="进程创建"><a class="markdownIt-Anchor" href="#进程创建"></a> 进程创建</h4><p>当出现了需要创建进程的情况时，操作系统将按以下步骤创建一个新进程<br /><img src="creat_process.png" alt="进程创建" /></p><h4 id="进程切换"><a class="markdownIt-Anchor" href="#进程切换"></a> 进程切换</h4><p>进程切换指的是<strong>操作系统中断一个正在运行的进程，将另一个进程置于运行模式，并把控制权交给后者</strong></p><p><img src="process_switch_reason.png" alt="进程切换原因" /></p><p><a href="https://thm-lab.github.io/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/#cpu%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86">异常和中断的区别</a>详见计组</p><p>但是！<strong>中断不一定会引起进程切换</strong>，例如I/O中断由CPU执行中断处理程序后仍然有可能切换为原进程<br />然而<strong>进程切换一定会引起模式切换</strong>，因为<strong>进程切换需要切换到内核模式下完成进程调度</strong></p><p>进程切换的<strong>步骤</strong>:</p><ol><li><strong>保存处理器上下文环境</strong>，包括程序计数器和其它寄存器</li><li><strong>更新当前处于运行状态进程的进程控制块</strong></li><li>将进程的<strong>进程控制块移至相应队列</strong>(就绪、阻塞、就绪/挂起等)</li><li><strong>选择另一进程执行</strong></li><li><strong>更新其进程控制块信息</strong></li><li><strong>更新内存管理数据结构</strong></li><li><strong>恢复</strong>被选择进程的<strong>上下文环境</strong>，如载入程序计数器和其他寄存器先前的值</li></ol><h4 id="模式切换"><a class="markdownIt-Anchor" href="#模式切换"></a> 模式切换</h4><p>模式切换指<strong>用户模式和内核模式之间的相互转换</strong></p><p>由用户模式切到内核模式的原因:</p><ul><li><strong>系统调用</strong>: 是操作系统提供给用户程序<strong>访问系统内核功能的接口</strong>，用户程序通过调用系统调用来获取操作系统提供的服务，服务完成后返回应用程序</li><li><strong>中断</strong>: 以便中断处理能执行特权指令</li></ul><p>然而<strong>模式切换不一定会引起进程切换</strong>，某些系统调用(如getpid)就不会导致进程切换</p><h3 id="unix-svr4的进程管理"><a class="markdownIt-Anchor" href="#unix-svr4的进程管理"></a> Unix SVR4的进程管理</h3><p><img src="unix_process_state_model.png" alt="Unix进程状态转换" /></p><p><strong>进程创建</strong>由<strong>内核系统调用fork()实现</strong><br />fork()调用后的步骤:</p><ol><li>在<strong>进程表中</strong>为新进程<strong>分配一个空项</strong></li><li>为子进程<strong>分配一个唯一的进程标识符</strong></li><li><strong>复制</strong>父进程的<strong>进程映象</strong>，但共享内存除外</li><li><strong>增加父进程</strong>所拥有的<strong>文件的计数器</strong>，反映另一个进程现在也拥有这些文件的事实</li><li><strong>将子进程设置为就绪态</strong></li><li><strong>将子进程的ID号返回给父进程，将0值返回给子进程</strong></li></ol><p><strong>fork()创建子进程之后，父进程和子进程均在下一条语句上继续运行</strong><br /><strong>fork()创建子进程之后，执行返回父进程，或调度切换到子进程或其他进程(与OS的调度算法有关)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br>#Include&lt;sys/types.h&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>  fork(); <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bye\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello<br>Bye<br>Bye<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出: 共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>个<code>hello, world</code>(8个进程，每个进程打印一个)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, world<br>hello, world<br>hello, world<br>hello, world<br>hello, world<br>hello, world<br>hello, world<br>hello, world<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> global = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span>  pid;<br>  <span class="hljs-type">int</span> vari = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before fork\n&quot;</span>);<br><br>  <span class="hljs-keyword">if</span> ((pid = fork()) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>      <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>  global++;<br>  vari--;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child\n&quot;</span>);<br>  &#125;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;global=%d,vari=%d\n&quot;</span>, global, vari);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出: 因为子进程是<strong>复制</strong>了父进程的<strong>进程映像</strong>(除共享空间外)，因此<strong>不会影响父进程的数据</strong>，<strong>子进程数据为自己独有</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">before fork<br>global=4,vari=5<br>child<br>global=5,vari=4<br></code></pre></td></tr></table></figure><h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3><p>进程的<strong>2个基本属性</strong>:</p><ul><li><strong>进程是拥有资源的独立单位</strong></li><li><strong>进程是调度/执行的基本单位</strong>，挂起进程会导致内部所有线程被挂起，终止进程会导致内部所有线程被终止，因此线程只是独立调度和分配的基本单位</li></ul><p><strong>线程</strong>是进程中的一个实体，<strong>是独立调度和分配的基本单位</strong><br /><img src="thread.png" alt="线程" /></p><ul><li>单进程单线程: MS Dos等</li><li>单进程多线程: JVM(Java虚拟机)等</li><li>多进程单线程: 传统Unix等</li><li>多进程多线程: 现在操作系统(Windows、Solaris)等</li></ul><p><img src="multithreaded_process_model.png" alt="多线程模型" /><br />进程内可能有多个线程，每个线程都有<strong>包含线程信息的TCB</strong>(Thread Control Block)、线程<strong>代码</strong>、<strong>局部变量的静态存储空间</strong>、<strong>执行栈</strong>和<strong>与进程内其他线程共享的内存和资源访问</strong></p><p>线程的<strong>优点</strong>:</p><ul><li><strong>创建时间短</strong></li><li><strong>终止时间短</strong></li><li><strong>切换时间短</strong></li><li>执行程序间的通信效率高(<strong>进程通信难度大于线程通信</strong>)</li></ul><p><img src="multithreaded_process_example.png" alt="多线程示例" /></p><h4 id="线程分类"><a class="markdownIt-Anchor" href="#线程分类"></a> 线程分类</h4><p>可以分为:</p><ul><li><strong>用户级线程(ULT)</strong></li><li><strong>内核级线程(KLT)</strong></li><li>混合方法</li></ul><h5 id="ult"><a class="markdownIt-Anchor" href="#ult"></a> ULT</h5><p><img src="ULT.png" alt="用户级线程" /><br /><strong>线程由用户自己管理(创建、终止、调度、挂起)</strong>，OS不知道有线程存在</p><h5 id="klt"><a class="markdownIt-Anchor" href="#klt"></a> KLT</h5><p><img src="KLT.png" alt="内核级线程" /><br />线程管理由OS进行，应用程序无法参与线程管理</p><h5 id="不同类型线程优缺点"><a class="markdownIt-Anchor" href="#不同类型线程优缺点"></a> 不同类型线程优缺点</h5><table><thead><tr><th>线程类型</th><th>用户级</th><th>内核级</th><th>混合方法</th></tr></thead><tbody><tr><td>优点</td><td><strong>线程切换不需要内核模式特权</strong><br><strong>调度策略因应用程序不同而不同</strong><br><strong>可以运行在任何操作系统上</strong></td><td>内核可以把同一个进程内的<strong>多个线程调度到多处理器上</strong>，<strong>提高并发性</strong><br><strong>当一个线程阻塞时，内核可以调度同一进程内的其他线程</strong><br><strong>内核例程本身也可以是多线程的，提高了内核的运行效率</strong></td><td><strong>线程创建在用户空间完成</strong>(开销小，不需要模式切换)<br><strong>线程调度和同步也由应用程序完成</strong>(开销小，不需要模式切换)<br><strong>一个应用程序中的多个线程被映射到一些</strong>(小于或等于用户级线程数)</td></tr><tr><td>缺点</td><td>当用户级线程执行系统调用时，不仅阻塞当前线程，还<strong>将引起同一进程中的其他线程阻塞</strong><br><strong>不能利用多处理器技术</strong></td><td>把控制权从一个线程传递到相同进程内的另一个线程时，需要<strong>切换到内核模式</strong>(<strong>由OS进行线程切换</strong>)</td><td></td></tr></tbody></table><h2 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h2><h3 id="调度类型"><a class="markdownIt-Anchor" href="#调度类型"></a> 调度类型</h3><p>调度的<strong>目的</strong>是以<strong>满足系统目标</strong>(如响应时间、吞吐率、处理器效率)的方式，把进程分配到一个或多个处理器上执行<br />在本节中仅考虑<strong>单处理器</strong>，多处理器的调度复杂度远高于单处理器调度</p><p>首先可以将调度进行分类:</p><ul><li><strong>长程调度</strong>: 长程调度程序决定哪个程序可以进入系统中处理(创建进程)，因此它控制了系统的并发度，常见的调度算法: <strong>先来先服务FCFS</strong>或<strong>根据优先级、期望执行时间等进行调度</strong></li><li><strong>中程调度</strong>: 中程调度是交换功能的一部分(主要是<strong>进程在内存与外存的管理</strong>)，<strong>调度算法与存储管理相关</strong></li><li><strong>短程调度</strong>: <strong>由就绪状态中挑选进程进入执行状态</strong>，调度算法将在下面详细介绍</li></ul><p><img src="scheduling.png" alt="调度层次" /><br /><img src="scheduling_state_transaction.png" alt="状态转变的调度层级" /></p><p><strong>本节也主要关注短程调度</strong></p><h3 id="调度标准"><a class="markdownIt-Anchor" href="#调度标准"></a> 调度标准</h3><ul><li><strong>响应时间</strong>: <strong>从用户提交一个请求开始，到接收到第一个响应之间的时间间隔</strong>，响应时间 = 输入传送时间 + 计算时间 + 响应传送时间</li><li><strong>周转时间</strong>: <strong>从作业提交开始，到作业完成之间的时间间隔</strong></li><li><strong>截止时间</strong>: 某任务<strong>必须开始执行的最迟时间</strong>，或<strong>必须完成的最迟时间</strong></li><li><strong>吞吐量</strong>: <strong>单位时间内完成的进程数量</strong></li><li><strong>处理器利用率</strong>: <strong>处理器处于忙状态的时间百分比</strong></li></ul><p><span style="color:#ff562b"><b>响应时间与周转时间无法比较长短，如果进程只进行一次响应后即结束，则响应时间等于周转时间；如果进程需要响应多次，则响应时间小于周转时间</b></span></p><ul><li><strong>平均周转时间</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T = \frac{1}{n} \sum_{i=1}^{n} T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><strong>带权周转时间</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo>=</mo><mfrac><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">W = \frac{T}{T_{s}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.317431em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其中T为<strong>周转时间</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<strong>系统为进程服务时间</strong></li><li><strong>平均带权周转时间</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>W</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T = \frac{1}{n} \sum_{i=1}^{n} W_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul><h3 id="调度决策"><a class="markdownIt-Anchor" href="#调度决策"></a> 调度决策</h3><h4 id="调度规则"><a class="markdownIt-Anchor" href="#调度规则"></a> 调度规则</h4><p><strong>短程调度</strong>的主要目标: <strong>按照优化系统某些方面的方式，来分配处理器时间</strong></p><p>调度规则的影响因素: <strong>面向用户/面向系统</strong>与<strong>性能相关/性能无关</strong></p><ul><li><strong>面向用户且性能相关</strong>: <strong>周转时间、响应时间、截止时间</strong></li><li><strong>面向用户且性能无关</strong>: <strong>可预测性</strong></li><li><strong>面向系统且性能相关</strong>: <strong>吞吐量、处理器利用率</strong></li><li><strong>面向系统且性能无关</strong>: <strong>公平性、强制优先级、平衡资源</strong></li></ul><p><strong>优先级: 通过多条就绪队列进行实现</strong></p><h4 id="调度模式"><a class="markdownIt-Anchor" href="#调度模式"></a> 调度模式</h4><ul><li>非抢占式: 执行进程只有在<strong>执行完毕</strong>，或因申请I/O或请求某些操作系统服务而<strong>阻塞自己</strong>时，才释放处理器</li><li>抢占式: 执行进程可能被操作系统中断，并转换为<strong>就绪态</strong>，抢占发生原因:<ul><li><strong>新进程到达</strong></li><li><strong>中断发生后把一个阻塞进程置为就绪态</strong></li><li><strong>周期性的时钟中断(防止独占)</strong></li></ul></li></ul><h4 id="调度函数"><a class="markdownIt-Anchor" href="#调度函数"></a> 调度函数</h4><p>关键参数:<br /><b></p><ul><li>w: 目前为止在系统里的等待时间</li><li>e: 目前为止花费的执行时间</li><li>s: 进程所需的总服务时间(用户提供或估计)</li></ul></b><h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3><b><ul><li>先来先服务(First Come First Served, FCFS)</li><li>时间片轮转(Round Robin, RR)</li><li>短作业优先(Shortest Job First, SJF)</li><li>剩余时间最短优先(Shortest Remaining Time, SRT)</li><li>响应比高优先(Highest Response Ratio Next, HRRN)</li><li>反馈(Feedback, FB)</li></ul></b><h4 id="fcfs"><a class="markdownIt-Anchor" href="#fcfs"></a> FCFS</h4><p>说明: 按照<strong>到达的先后顺序来调度，属于非抢占调度方式</strong></p><p>评价:</p><ul><li><strong>有利于CPU繁忙型</strong>的进程，而<strong>不利于I/O繁忙型</strong>的进程(<strong>CPU繁忙型会持续占有CPU</strong>，而<strong>I/O繁忙型进程进行I/O后需要重新排队</strong>)</li><li><strong>平均周转时间长</strong>，<strong>不适合直接用于单处理器系统,通常与其它调度算法混合使用</strong></li></ul><h4 id="rr"><a class="markdownIt-Anchor" href="#rr"></a> RR</h4><p>说明: 每个进程被<strong>分配一个时间片</strong>，周期性产生时钟中断，<strong>中断时当前进程进入就绪队列末尾</strong>，<strong>基于FCFS选择下一个作业运行</strong>，如果进程在时间片内<strong>阻塞或结束</strong>，则<strong>立即切换</strong>进程</p><p>评价:</p><ul><li>属于<strong>抢占调度方式</strong></li><li><strong>时间片的设置</strong>与系统性能、响应时间密切相关<ul><li>当时间片趋于无穷大时: RR变为FCFS，对CPU繁忙型有利，同样会<strong>引起对短的交互请求的响应时间变长</strong></li><li>当时间片为1时，对I/O繁忙型较为有利(<strong>但IO阻塞后仍需排队</strong>)，但<strong>频繁切换进程降低了CPU的效率</strong></li><li>因此时间片最好<strong>略大于一次典型交互的时间</strong>，仍对CPU繁忙型有利</li></ul></li></ul><p>RR算法在<strong>通用的分时系统</strong>或<strong>事务处理系统</strong>中特别有效</p><p><img src="RR_example.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>4</mn><mo>+</mo><mn>16</mn><mo>+</mo><mn>13</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>7</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>10.8</mn></mrow><annotation encoding="application/x-tex">\frac{4+16+13+14+7}{5}=10.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>4</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>16</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>13</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>7</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>2.71</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{4}{3}+\frac{16}{6}+\frac{13}{4}+\frac{14}{5}+\frac{7}{2}}{5}=2.71</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">7</span><span class="mord">1</span></span></span></span></p><p><strong>VRR</strong>: 是对RR的改进，<strong>增加一个辅助队列，接收I/O阻塞完成的进程，调度优先于就绪队列，但占用的处理机时间小于就绪队列的时间片</strong></p><h4 id="sjf"><a class="markdownIt-Anchor" href="#sjf"></a> SJF</h4><p>说明: <strong>根据用户提供的或估算的作业执行时间进行调度，选择执行时间最短的作业交给CPU</strong></p><p>评价:</p><ul><li><strong>属于非抢占调度方式</strong>，短进程跳到队列头，<strong>可能导致长进程饥饿</strong>，因此不适用于分时系统或事务处理环境</li><li>有利于短进程，<strong>减小了平均周转时间</strong>(非抢占调度下，长进程一般会导致短进程的高周转时间，所以有利于短进程能减小平均周转时间)</li><li>进程的长短根据用户所提供的估计执行时间而定，用户估计不准时，导致该算法不一定能真正做到短作业优先调度</li></ul><p><img src="SJF_example.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>11</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>3</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>7.6</mn></mrow><annotation encoding="application/x-tex">\frac{3+7+11+14+3}{5}=7.6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">.</span><span class="mord">6</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>3</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>7</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>11</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>3</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>1.78</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{3}{3}+\frac{7}{6}+\frac{11}{4}+\frac{14}{5}+\frac{3}{2}}{5}=1.78</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">7</span><span class="mord">8</span></span></span></span></p><h4 id="srt"><a class="markdownIt-Anchor" href="#srt"></a> SRT</h4><p>说明: <strong>调度程序总是选择预期剩余时间最短的进程</strong>，当一个新进程加入就绪队列时，如果它比当前运行的进程具有更短的剩余时间，就可能<strong>抢占</strong>当前正在运行的进程</p><p>评价:</p><ul><li><strong>属于抢占式调度方式</strong>，既不像FCFS那样偏爱长进程(非抢占式)，也不像RR算法那样会产生很多额外的中断(因时间片而产生)，从而<strong>减少了开销</strong></li><li>周转时间短，SRT比SJF性能要好，只要就绪，短作业可以立即被选择执行</li><li><strong>需要估计预期的服务时间</strong>(估计可能不准)</li><li><strong>存在长进程饥饿现象</strong></li><li><strong>必须记录进程的已服务时间</strong></li></ul><p><img src="SRT_example.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn><mo>+</mo><mn>13</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>2</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>7.2</mn></mrow><annotation encoding="application/x-tex">\frac{3+13+4+14+2}{5}=7.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">.</span><span class="mord">2</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>3</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>13</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>4</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>2</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>1.59</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{3}{3}+\frac{13}{6}+\frac{4}{4}+\frac{14}{5}+\frac{2}{2}}{5}=1.59</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mord">9</span></span></span></span></p><h4 id="hrrn"><a class="markdownIt-Anchor" href="#hrrn"></a> HRRN</h4><p>说明: <strong>选择就绪队列中响应比最高的进程投入执行</strong><br /><strong>响应比</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><msub><mi>T</mi><mi>w</mi></msub><mo>+</mo><msub><mi>T</mi><mi>s</mi></msub></mrow><msub><mi>T</mi><mi>s</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{T_w + T_s}{T_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3335309999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">T_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为进程等待时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">，T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为估计的作业执行时间</p><p>评价:</p><ul><li><strong>属于非抢占式</strong>调度方法，实质上是一种动态优先权调度算法</li><li>是FCFS和SJF的结合，<strong>既照顾了短进程，又考虑了作业到达的先后次序</strong>，不会使长进程长期得不到服务</li><li>需要计算响应比，<strong>增加系统开销</strong>，且难以准确计算(<strong>需要估计执行时间</strong>)</li></ul><p><img src="HRRN_example.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>9</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>7</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\frac{3+7+9+14+7}{5}=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">9</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>3</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>7</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>9</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>7</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>2.14</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{3}{3}+\frac{7}{6}+\frac{9}{4}+\frac{14}{5}+\frac{7}{2}}{5}=2.14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span></span></span></span></p><h4 id="fb"><a class="markdownIt-Anchor" href="#fb"></a> FB</h4><p>SJF、SRT和HARRN都采用了<strong>进程估计执行时间</strong>这一参数作为调度的因素来<strong>奖励短进程从而降低平均周转时间</strong>，然而该参数很难进行准确估算<br />而FB采用的是惩罚长进程的思想，其关注进程的<strong>已执行时间</strong>参数，该参数可以被精准测量，根据进程执行历史，<strong>调度基于按时间片的抢占原则</strong></p><p>说明:</p><ol><li>设置多个就绪队列，每个队列赋予不同优先级(<strong>第一队列优先级最高，依次递减，各个队列中进程执行的时间片不相同，优先级越高的队列，时间片越小</strong>)</li><li>新进程进入时，首先放入第一个队列尾(<strong>优先级默认最高</strong>)，按FCFS原则排队</li><li>如果进程在当前队列规定的时间片内<strong>完成则退出</strong>，<strong>未完成则抢占</strong>，一般而言，从队列i中调度的进程允许执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>的时间，然后才被抢占，降级到下一个优先级队列(<strong>如果没有其他进程需调度，则当前进程不降级</strong>)</li><li><strong>到达最低优先级队列后，不再降级</strong></li><li><strong>仅当第一队列空闲时，才调度第二队列中的进程，依次类推</strong></li></ol><p>评价:</p><ul><li><strong>属于抢占式调度方式</strong>，能<strong>较好地满足各种类型用户</strong>的需要</li><li><strong>有利于终端型作业用户</strong>: 常为短作业，<strong>能在第一队列所规定的时间片内完</strong></li><li><strong>对短作业用户有利</strong>: <strong>能在前几个队列所规定的时间片内完成</strong></li><li><strong>长进程</strong>: 将依次在第1, 2, ···, n个队列中运行，<strong>随着优先级下降，分配的时间片长度增加，减少了抢占次数，不会发生长进程饥饿</strong></li></ul><p><img src="FB_q=1.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>4</mn><mo>+</mo><mn>18</mn><mo>+</mo><mn>12</mn><mo>+</mo><mn>13</mn><mo>+</mo><mn>3</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">\frac{4+18+12+13+3}{5}=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>4</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>18</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>12</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>13</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>3</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>2.29</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{4}{3}+\frac{18}{6}+\frac{12}{4}+\frac{13}{5}+\frac{3}{2}}{5}=2.29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span><span class="mord">9</span></span></span></span><br /><img src="FB_q=2i.png" alt="示例" /><br /><strong>平均周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>4</mn><mo>+</mo><mn>15</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>14</mn><mo>+</mo><mn>6</mn></mrow><mn>5</mn></mfrac><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\frac{4+15+14+14+6}{5}=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，<strong>平均带权周转时间</strong> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mfrac><mn>4</mn><mn>3</mn></mfrac><mo>+</mo><mfrac><mn>15</mn><mn>6</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>4</mn></mfrac><mo>+</mo><mfrac><mn>14</mn><mn>5</mn></mfrac><mo>+</mo><mfrac><mn>6</mn><mn>2</mn></mfrac></mrow><mn>5</mn></mfrac><mo>=</mo><mn>2.63</mn></mrow><annotation encoding="application/x-tex">\frac{\frac{4}{3}+\frac{15}{6}+\frac{14}{4}+\frac{14}{5}+\frac{6}{2}}{5}=2.63</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.48682em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.14182em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">6</span><span class="mord">3</span></span></span></span></p><h3 id="实时系统与实时调度"><a class="markdownIt-Anchor" href="#实时系统与实时调度"></a> 实时系统与实时调度</h3><h4 id="实时系统"><a class="markdownIt-Anchor" href="#实时系统"></a> 实时系统</h4><p>实时系统要求系统能够<strong>及时(即时)响应外部事件的请求</strong>，在<strong>规定的时间内完成</strong>对该事件的处理，并控制所有实时任务协调一致地运行</p><p>实时任务: 具有<strong>及时性要求</strong>的、常常<strong>被重复执行</strong>的特定进程，在实时系统中习惯称为任务</p><p><a href="#%E8%B0%83%E5%BA%A6%E6%A0%87%E5%87%86">调度标准</a>中有一个标准为<strong>截止时间</strong>，在实时系统中截止时间分为2类:</p><ul><li>开始截止时间: 任务在某时间以前，必须开始执行</li><li>完成截止时间: 任务在某时间以前必须完成</li></ul><p><img src="real_time_task.png" alt="实时任务分类" /></p><p>实时任务的<strong>信息</strong>:</p><ul><li>就绪时间</li><li>开始截止时间</li><li>完成截止时间</li><li>处理时间</li><li>资源需求</li><li>优先级</li><li>子任务结构: 一个任务可分解为<strong>一个必须执行的子任务</strong>和一个可选执行子任务，<strong>前者有硬截止时间</strong></li></ul><p>实时操作系统<strong>特点</strong>:</p><ul><li><strong>可确定性</strong>: 任务按照<strong>固定的、预先确定的时间</strong>或时间间隔进行</li><li><strong>可响应性</strong>: 关注系统在知道中断后<strong>为中断提供服务的时间</strong></li><li><strong>用户控制</strong>: 用户能够区分软、硬实时任务，并<strong>控制任务优先级</strong></li><li><strong>可靠性</strong>: 实时响应和控制事件，保障性能</li><li><strong>失效弱化</strong>: 系统具有稳定性，当不能满足所有任务的实时性时，首先满足优先级高的任务</li></ul><h4 id="实时调度"><a class="markdownIt-Anchor" href="#实时调度"></a> 实时调度</h4><p>实时调度从2个角度进行分类:</p><ul><li><strong>调度方法</strong></li><li><strong>抢占方式</strong></li></ul><h5 id="调度方法"><a class="markdownIt-Anchor" href="#调度方法"></a> 调度方法</h5><ul><li><strong>静态表驱动</strong>调度法</li><li><strong>静态优先级抢占</strong>调度法</li><li><strong>基于动态规划</strong>的调度法</li><li><strong>动态尽力</strong>调度法</li></ul><p><strong>静态表驱动调度法</strong><br />制订<strong>静态调度表</strong>(即固定时间执行固定进程)，用于调度<strong>周期性实时任务</strong><br />任何任务的调度<strong>申请改动都会引起调度表的修改</strong></p><p><strong>EDF(Early Deadline First)调度算法</strong>即是属于静态表驱动调度法<br />说明: 根据任务的截止时间来确定任务的优先级</p><p><img src="edf_example_question.png" alt="示例" /><br /><img src="edf_example_answer.png" alt="示例" /></p><p><strong>静态优先级抢占调度法</strong><br /><strong>根据任务的时间约束确定优先级从而根据优先级进行抢占调度</strong>，多用于非实时多道程序系统</p><p><strong>速度单调算法(RM,Rate Monotonic)<strong>即是根据</strong>任务周期长度</strong>为实时任务赋予<strong>静态优先级</strong><br />说明: 任务周期越短，优先级越高，优先级函数是<strong>任务速度(任务周期的倒数)<strong>的单调</strong>递增</strong>的函数</p><p><img src="RM.png" alt="速率与优先级" /></p><p><strong>基于动态规划的调度法</strong><br />当实时任务到达以后，系统为新到达的任务和正在执行的任务<strong>动态创建一张调度表</strong><br />说明: 在<strong>当前执行进程不会错过其截止时间的条件下</strong>，如果也能<strong>使新到达任务在截止时间内完成，则立即调度执行新任务</strong></p><p><strong>动态尽力调度法</strong><br />当任务到达时，系统<strong>根据其属性赋予优先级</strong>，优先级高的先调度<br />当任务是非周期时，其缺点在于<strong>当任务完成，或截止时间到达时，很难知道该任务是否满足其约束时间</strong></p><p><strong>允许CPU空闲的EDF</strong><br />说明: 优先调度<strong>截止时间最早的还未就绪但是已知道其开始截止时间任务</strong>，并让该任务运行完毕</p><p><img src="edf_idle_time_question.png" alt="示例" /><br /><img src="edf_idle_time_answer.png" alt="示例" /></p><h5 id="抢占方式"><a class="markdownIt-Anchor" href="#抢占方式"></a> 抢占方式</h5><ul><li><strong>基于时间片</strong>的轮转抢占式调度</li><li><strong>基于优先级</strong>的<strong>非抢占式</strong>调度</li><li><strong>基于优先级</strong>的抢<strong>占点抢占</strong>调度</li><li><strong>立即抢占式</strong>调度</li></ul><p><img src="preemption.png" alt="抢占方式" /></p><h2 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h2><p>进程间有以下三种关系:<br /><b></p><ul><li>竞争</li><li>通过共享合作</li><li>通过通信合作</li></ul></b><p><strong>竞争</strong>: 进程间不知道彼此的存在，竞争使用同一资源时会发生冲突，竞争面对的并发控制问题为<strong>互斥、死锁、饥饿</strong><br /><strong>通过共享合作</strong>: 多个进程可能共享一个变量、共享文件或数据库，共享面对的并发控制问题为<strong>互斥、死锁、饥饿、数据一致性</strong><br /><strong>通过通信合作</strong>: 进程间通过通信完成同步和协调彼此活动，通信面对的并发控制问题为<strong>互斥、死锁</strong></p><table><thead><tr><th style="text-align:center"><strong>术语</strong></th><th style="text-align:center"><strong>解释</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>原子操作</strong></td><td style="text-align:center">由一个或多个指令序列实现的动作或函数，对外不可见，一组指令要么都执行，要么都不执行</td></tr><tr><td style="text-align:center"><strong>临界资源</strong></td><td style="text-align:center"><strong>不可同时访问</strong>，必须互斥访问的资源，如打印机</td></tr><tr><td style="text-align:center"><strong>临界区</strong></td><td style="text-align:center">访问临界资源的<strong>代码</strong>，任意时刻只能由一个进程在这段代码中运行</td></tr><tr><td style="text-align:center"><strong>互斥</strong></td><td style="text-align:center">当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问共享资源的情形</td></tr><tr><td style="text-align:center"><strong>活锁</strong></td><td style="text-align:center">两个或两个以上的进程为响应其他进程而<strong>持续改变自己状态</strong>，<strong>但是不做有用工作的情形</strong></td></tr><tr><td style="text-align:center"><strong>死锁</strong></td><td style="text-align:center">两个或两个以上的进程因<strong>等待其他进程做完某些事</strong>而<strong>不能继续执行的情形</strong></td></tr><tr><td style="text-align:center"><strong>竞争条件</strong></td><td style="text-align:center">多个进程或线程读写共享的数据时，结果取决于多个进程的指令执行顺序</td></tr><tr><td style="text-align:center"><strong>饥饿</strong></td><td style="text-align:center"><strong>一个具备执行条件的进程，被调度程序无限期的忽视而不能调度的情形</strong></td></tr></tbody></table><h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3><p>并发指同一时间多个进程需要执行，并发处理为<strong>单处理器的交替执行</strong>和<strong>多处理器的重叠执行</strong><br />但是由于进程是计算机中的独立个体，且具有<strong>异步性、并发性</strong>，并且需要<strong>共享资源稀缺</strong>，并发控制需要进程间的同步来实现</p><p><img src="concurrency_1.png" alt="单处理器并发错误" /><br />如上图所示: 在P1输入x后，CPU接受到中断，在中断处理后调度了P2，按图示顺序进行执行，则<strong>P1输入为x, 输出为y</strong></p><p><img src="concurrency_1.png" alt="多处理器并发错误" /><br />P1和P2分别在单独的处理器上执行，同一行的事件并行，<strong>P1输入为x, 输出为y</strong></p><p>因此OS需要提供并发控制的方法</p><h3 id="互斥"><a class="markdownIt-Anchor" href="#互斥"></a> 互斥</h3><p><strong>互斥: 当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问共享资源的情形</strong></p><p><span style="color:#ff562b"><b>互斥的要求(访问临界区的要求): </b></span></p><ul><li><strong>空闲让进</strong>: 如临界区空闲，则有进程申请就立即进入</li><li><strong>忙则等待</strong>: 每次只允许一个进程处于临界区</li><li><strong>有限等待</strong>: 保证进程在有限时间内能进入临界区</li><li><strong>让权等待</strong>: 进程在临界区不能长时间阻塞等待某事件</li></ul><h3 id="实现进程互斥的方法"><a class="markdownIt-Anchor" href="#实现进程互斥的方法"></a> 实现进程互斥的方法</h3><h4 id="软件方法"><a class="markdownIt-Anchor" href="#软件方法"></a> 软件方法</h4><p>软件方法是通过<strong>在进入区设置和检查一些标志来判断是否有进程在临界区</strong>，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后在退出区修改标志</p><p>思想:</p><ul><li>临界区状态标志</li><li>预先表明进入临界区的态度(谦让/坚持进入)</li></ul><p>软件方法的<strong>评价</strong>:</p><ul><li>软件方法始终不能解决<strong>忙等</strong>现象，降低系统效率</li><li>采用软件方法实现进程互斥使用临界资源比较困难，特别是<strong>多个进程的互斥</strong></li><li>算法设计需要非常小心，否则可能出现<strong>死锁</strong>、<strong>互斥失败</strong>等严重问题</li></ul><h5 id="dekker算法"><a class="markdownIt-Anchor" href="#dekker算法"></a> Dekker算法</h5><p>Dekker算法思路:<br />当p0希望进入自己的临界区时，它把自己的flag值设为true，然后继续 检查P1的flag，如果P1的flag为false,P0可以立即进入自己的临界区，否则 P0检查turn,如果发现turn=0，那么它知道自己该坚持进入，从而周期性的检查P1的flag，P1在某一点将注意到应把turn值赋为0，随后把其flag置为false,允许P0进入，在P0结束其临界区后，把自己的flag置为false。释放其临界区，并把turn值置为1，从而把坚持进入的权利转交给P1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">boolean flag[<span class="hljs-number">2</span>] = &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;        <span class="hljs-comment">// 临界区状态标志(共享的全局变量)</span><br><span class="hljs-type">int</span> turn = <span class="hljs-number">1</span>;                            <span class="hljs-comment">// 进入临界区的态度</span><br><span class="hljs-comment">// 进程P0</span><br><span class="hljs-keyword">do</span> &#123;<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">// 进入区</span><br>    <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>]) &#123;                    <span class="hljs-comment">// P1正在使用或者P1也想使用</span><br>       <span class="hljs-keyword">if</span> (turn == <span class="hljs-number">1</span>)  &#123;<br>           flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>           <span class="hljs-keyword">while</span>  (turn == <span class="hljs-number">1</span>) ;          <span class="hljs-comment">// 轮到P1使用，退让直到轮到P0使用</span><br>           flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>     &#125;                                   <span class="hljs-comment">// P1退让或P1使用完，P0进入临界区</span><br>    进程P0的临界区代码；                  <span class="hljs-comment">// 使用临界区</span><br>    turn = <span class="hljs-number">1</span>;<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;                    <span class="hljs-comment">// 退出区</span><br>    进程P0的其它代码                     <span class="hljs-comment">// 剩余区</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br><br><span class="hljs-comment">// 进程P1</span><br><span class="hljs-keyword">do</span> &#123;<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">// 进入区</span><br>    <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>]) &#123;                    <span class="hljs-comment">// P0正在使用或者P0也想使用</span><br>       <span class="hljs-keyword">if</span> (turn == <span class="hljs-number">0</span>)  &#123;<br>           flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>           <span class="hljs-keyword">while</span>  (turn == <span class="hljs-number">0</span>) ;          <span class="hljs-comment">// 轮到P0使用，退让直到轮到P1使用</span><br>           flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>     &#125;                                   <span class="hljs-comment">// P0退让或P0使用完，P1进入临界区</span><br>    进程P1的临界区代码；                  <span class="hljs-comment">// 使用临界区</span><br>    turn = <span class="hljs-number">0</span>;<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;                    <span class="hljs-comment">// 退出区</span><br>    进程P1的其它代码                     <span class="hljs-comment">// 剩余区</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h5 id="peterson算法"><a class="markdownIt-Anchor" href="#peterson算法"></a> Peterson算法</h5><p>Peterson算法思路:<br />考虑进程P0,一旦它把flag[0]置为true，P1不能进入其临界区，如果P1已经在临界区中，则flag[1]=true，P0被阻止进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">boolean flag[<span class="hljs-number">2</span>] = &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;        <span class="hljs-comment">// 临界区状态标志(共享的全局变量)</span><br><span class="hljs-type">int</span> turn = <span class="hljs-number">1</span>;                            <span class="hljs-comment">// 进入临界区的态度</span><br><span class="hljs-comment">// 进程P0</span><br><span class="hljs-keyword">do</span> &#123;<br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">// 表明想要使用</span><br>    turn = <span class="hljs-number">1</span>;                            <span class="hljs-comment">// 谦让P1</span><br>    <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">1</span>] &amp;&amp; turn == <span class="hljs-number">1</span>);        <span class="hljs-comment">// 等待P1使用完并谦让给P0</span><br>    进程P0的临界区代码；                  <span class="hljs-comment">// 使用临界区</span><br>    flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">// 退出区</span><br>    进程P0的其它代码                     <span class="hljs-comment">// 剩余区</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 进程P1</span><br><span class="hljs-keyword">do</span> &#123;<br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;                      <span class="hljs-comment">// 表明想要使用</span><br>    turn = <span class="hljs-number">0</span>;                            <span class="hljs-comment">// 谦让P0</span><br>    <span class="hljs-keyword">while</span> (flag[<span class="hljs-number">0</span>] &amp;&amp; turn == <span class="hljs-number">0</span>);        <span class="hljs-comment">// 等待P1使用完并谦让给P0</span><br>    进程P0的临界区代码；                  <span class="hljs-comment">// 使用临界区</span><br>    flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">// 退出区</span><br>    进程P1的其它代码                     <span class="hljs-comment">// 剩余区</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><h4 id="硬件方法"><a class="markdownIt-Anchor" href="#硬件方法"></a> 硬件方法</h4><p>硬件方法也主要有<strong>2种</strong>:</p><ul><li><strong>中断禁用</strong></li><li><strong>特殊机器指令</strong></li></ul><h5 id="中断禁用"><a class="markdownIt-Anchor" href="#中断禁用"></a> 中断禁用</h5><p>中断禁用可以解决<strong>单处理器情况下</strong>由<strong>中断引起的并发错误</strong>，但<strong>不能解决多处理器下的互斥问题</strong><br /><strong>通过禁用中断，避免进程切换，实现互斥访问</strong></p><p>但是会造成很多<strong>弊端</strong>:</p><ul><li>无法响应外部请求</li><li>无法切换进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span> ) &#123;<br>  disable interrupt    <span class="hljs-comment">// 屏蔽中断</span><br>  critical section     <span class="hljs-comment">// 临界区</span><br>  enable interrupt     <span class="hljs-comment">// 启用中断</span><br>  remainder            <span class="hljs-comment">// 其余部分</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="特殊机器指令"><a class="markdownIt-Anchor" href="#特殊机器指令"></a> 特殊机器指令</h5><p>特殊机器指令由一条机器指令完成，因此不会被中断或多处理器并发指令影响<br /><b></p><p>优点:</p><ul><li>支持多处理器</li><li>简单、易证明</li><li>支持多临界区</li></ul><p>缺点:</p><ul><li>忙等</li><li>可能饥饿</li><li>可能死锁</li></ul></b><p>这里只介绍其中2条特殊机器指令<br /><b>compare_and_swap()</b>指令: <strong>比较一个内存单元的值和一个测试值，如果相等，则发生交换</strong><br />实现的功能与下面这个函数相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">compare_and_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *word, <span class="hljs-type">int</span> testval, <span class="hljs-type">int</span> newval)</span> &#123;<br>  <span class="hljs-type">int</span> oldval; <br>  oldval = *word;<br>  <span class="hljs-keyword">if</span>(oldval == testval) *word = newval;<br>  <span class="hljs-keyword">return</span> oldval;<br>&#125;<br></code></pre></td></tr></table></figure><p><b>exchange()</b>指令: <strong>原子性地交换寄存器和内存的值</strong><br />实现的功能与下面这个函数相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>  <span class="hljs-type">int</span> tmp;<br>  tmp = *a;<br>  *a = *b;<br>  *b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h4><p><span style="color:#ff562b"><b>信号量是实现进程互斥的最主要方法！</b></span></p><p>信号量: <strong>两个或多个进程可以通过传递信号进行合作</strong>，<strong>迫使进程在某个位置暂时停止执行(阻塞)</strong>，直到<strong>它收到一个可以向前推进的信号(唤醒)</strong>，<strong>通过对信号量操作的原子化即可实现进程互斥</strong></p><p><strong>信号量可视为一个值为整数的变量</strong>，有且仅有具有三个操作:</p><ul><li>初始化: 可以初始化为非负数</li><li>semWait(Wait或P): 使信号量的值<strong>减少1</strong>，若值<strong>变为负数</strong>，则<strong>阻塞执行semWait(Wait或P)操作的进程</strong></li><li>semSignal(Signal或V): 使信号量的值<strong>增加1</strong>，若<strong>值小于等于零(说明有进程在等待增加)，则被semWait(Wait或P)阻塞的进程解除阻塞</strong></li></ul><p><strong>其中信号量可以是二元信号量(只能为0和1)和计数信号量(一般信号量，整数)</strong></p><p>计数信号量和二元信号量，都使用<strong>队列</strong>来组织<strong>等待信号量</strong>的进程:</p><ul><li><strong>强信号量</strong>: 进程以<strong>FIFO(First In First Out)方式</strong>从队列里移除</li><li><strong>弱信号量</strong>: 未规定阻塞进程从队列里移除的顺序</li></ul><p><img src="signal.png" alt="强信号量示例" /></p><h4 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h4><p>信号量提供了方便的机制处理进程同步，但<strong>不正确的使用信号量仍会导致时序错误(死锁)</strong>，且难以检测:</p><ul><li>先对信号量<code>V()</code>再<code>P()</code>违反了互斥请求</li><li>对信号量始终调用<code>P()</code>将导致死锁</li><li>一个进程遗漏了<code>P()</code>或<code>V()</code>将导致死锁且可能破坏互斥</li></ul><p>管程(monitor)类型提供了一组由程序员定义的、在管程内互斥的操作。<strong>管程内定义的子程序只能访问位于管程内的局部变量和形式参数</strong>，管程内的局部变量也只能被管程内部的局部子程序访问，管程结构确保了<strong>同时只能有一个进程在管程内活动</strong></p><p>管程内部可定义<code>condition</code>类型的变量以提供同步机制，称其为<strong>条件变量</strong>。条件变量可执行操作<code>wait()</code>和<code>signal()</code><br />条件变量存在于管程内部，对同一个条件变量调用操作的进程将和条件变量建立一定的联系，或者称之为绑定。对于管程内的条件变量 x，进程 P调用<code>x.wait()</code>将时<strong>自身挂起到条件变量x上</strong>；当另一个进程调用<code>x.signal()</code>时，在x上<strong>悬挂的进程会被重启</strong>，如果此时没有进程悬挂在x上，则<code>x.signal()</code><strong>操作将被忽略</strong></p><p><img src="monitor.png" alt="管程结构图" /></p><p>进程P调用<code>x.signal()</code>，且存在悬挂进程Q与条件变量x关联，根据管程的性质，若进程Q开始执行，则进程P必须等待</p><ul><li><strong>进程Q重启且进程P等待</strong>: 进程P将等待，<strong>直到进程Q离开管程</strong>或者<strong>等待另一个进程调用</strong><code>x.signal()</code></li><li><strong>进程P唤醒进程Q且进程P继续执行</strong>：进程Q被唤醒，但<strong>仍然会等待</strong>，<strong>直到进程P离开管程</strong>，或者另一个触发条件<code>x.wait()</code></li></ul><p><strong>信号量实现管程</strong>:<br />进入管程的外部子程序结构F如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">F</span><span class="hljs-params">()</span> &#123;<br>  wait(mutex);<br>  <span class="hljs-comment">// 子程序执行</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 子程序执行结束</span><br>  <span class="hljs-keyword">if</span> (next_count &gt; <span class="hljs-number">0</span>) &#123;<br>    signal(next);    <span class="hljs-comment">//     此前有进程挂起，重启该进程</span><br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    signal(mutex);   <span class="hljs-comment">//     管程内无进程挂起，释放控制权</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对每个管程内的条件变量 x，引入信号量 x_sem 和整数变量 x_count 记录信号量 x 上挂起的进程数量，均初始化为 0。x.wait() 和 x.signal() 实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> x.wait()&#123;<br>  x_count++;               <span class="hljs-comment">// 将进程挂起到 x 上</span><br>  <span class="hljs-keyword">if</span> (next_count &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 当前仍有进程挂起在管程中</span><br>    signal(next);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    signal(mutex);         <span class="hljs-comment">// 无进程在等待，释放管程控制权</span><br>  &#125;<br>  wait(x_sem);             <span class="hljs-comment">// 等待信号量 x_sem，由信号量决定唤醒哪个挂起进程</span><br>  x_count--;               <span class="hljs-comment">// 等待结束，进程被唤醒</span><br>&#125;<br><br><span class="hljs-type">void</span> x.signal()&#123;<br>  <span class="hljs-keyword">if</span> (x_count &gt; <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 当前有程序挂起在条件变量 x</span><br>      next_count ++;     <span class="hljs-comment">// 自己将要被阻塞，故管程挂起数增加</span><br>      signal(x_sem);     <span class="hljs-comment">// 释放信号量，唤醒一个挂起进程</span><br>      wait(next);        <span class="hljs-comment">// 将自身阻塞到管程中</span><br>      next_count--;      <span class="hljs-comment">// 被唤醒，继续执行</span><br>  &#125;<br>  <span class="hljs-comment">// 没有程序挂起在条件变量 x，不产生任何影响</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h4><p>消息传递的<strong>2条通信原语</strong>:</p><ul><li>Send</li><li>Receive</li></ul><p><img src="message_format.png" alt="消息格式" /></p><p>消息传递的<strong>3种同步方式</strong>:<br /><b></p><ul><li>阻塞发送，阻塞接收</li><li>不阻塞发送，阻塞接收</li><li>不阻塞发送，不阻塞接收</li></ul></b><p><strong>使用消息传递实现互斥</strong></p><ul><li>多个并发执行的发送进程和接收进程共享一个邮箱box，且box的<strong>初始状态为仅包含一条空消息</strong>(好比进入临界区的令牌)</li><li>采用<strong>不阻塞发送，阻塞接收</strong>方式传递消息</li><li>若邮箱中存在一条消息，则允许一个进程进入临界区</li><li>若邮箱为空，则表明有一个进程位于临界区，其它试图进入临界区的进程必须阻塞</li><li><strong>只要保证邮箱中最多只有一条消息，就能保证只允许一个进程进入临界区，从而实现进程互斥使用临界资源</strong></li></ul><p><span style="color:#ff562b"><b>接收即为申请进入临界区，发送即退出临界区</b></span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>  message msg;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    receive(box, msg);    <span class="hljs-comment">/* 从邮箱接收一条消息 */</span><br>    &lt;临界区&gt;;<br>    send(box, msg);       <span class="hljs-comment">/*　将消息发回到邮箱　*/</span><br>    &lt;其余部分&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="互斥问题"><a class="markdownIt-Anchor" href="#互斥问题"></a> 互斥问题</h3><p>均通过信号量方法来进行解决</p><h4 id="生产者与消费者问题"><a class="markdownIt-Anchor" href="#生产者与消费者问题"></a> 生产者与消费者问题</h4><p>问题描述:</p><ul><li><strong>一个或多个生产者产生数据并放入缓冲</strong></li><li><strong>每次只能有一个消费者从缓冲中取出数据(互斥)</strong></li><li><strong>任何时刻只能由一个生产者或消费者访问缓冲(互斥)</strong></li></ul><p>同步问题:</p><ul><li><strong>缓冲区满时，生产者不会往缓冲区增加数据</strong></li><li><strong>缓冲区空时，消费者不能从缓冲区中取走数据</strong></li></ul><p>翻译为流程图形式:<br /><img src="producers_consumers.png" alt="生产者与消费者问题" /><br />一般需要表示<strong>可用资源的信号量、可放资源的信号量、保护放入资源和取出资源操作的信号量</strong><br /><span style="color:#ff562b"><b>应先申请资源信号量，再申请操作互斥信号量</b></span></p><p>例题:</p><ul><li>桌子上有一只盘子，最多可以放入N(N&gt;0)个水果</li><li>爸爸随机向盘中放入苹果或桔子，儿子只吃盘中的桔子，女儿只吃盘中的苹果</li><li>仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果</li><li>每次只能放入或取出一个水果，且不允许多人同时使用盘子</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore plate = N;      <span class="hljs-comment">// 盘子可放水果数，初始为N</span><br>semaphore apple = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 盘中里的苹果数，初始为0</span><br>semaphore orange = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 盘中里的桔子数，初始为0</span><br>semaphore plate_op = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 盘中操作的信号量，初始为1</span><br><br>dad() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    fruit = fruit();    <span class="hljs-comment">// 准备水果，并且得到水果类型</span><br>    P(plate);           <span class="hljs-comment">// 申请放水果</span><br>    P(plate_op);        <span class="hljs-comment">// 申请使用盘子</span><br>    放水果              <span class="hljs-comment">// 放水果</span><br>    V(plate_op);        <span class="hljs-comment">// 释放盘子使用权</span><br>    <span class="hljs-keyword">if</span> (fruit == <span class="hljs-string">&#x27;apple&#x27;</span>) &#123;<br>      V(apple);         <span class="hljs-comment">// 如果放了苹果，则苹果数增加</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (fruit == <span class="hljs-string">&#x27;orange&#x27;</span>) &#123;<br>      V(orange);         <span class="hljs-comment">// 如果放了桔子，则桔子数增加</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>son() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(orange);          <span class="hljs-comment">// 申请吃桔子</span><br>    P(plate_op);        <span class="hljs-comment">// 申请使用盘子</span><br>    拿桔子吃            <span class="hljs-comment">// 吃桔子</span><br>    V(plate_op);       <span class="hljs-comment">// 释放盘子使用权</span><br>    V(plate);           <span class="hljs-comment">// 可放水果数增加</span><br>  &#125;<br>&#125;<br><br>daught() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(apple);          <span class="hljs-comment">// 申请吃苹果</span><br>    P(plate_op);        <span class="hljs-comment">// 申请使用盘子</span><br>    拿苹果吃            <span class="hljs-comment">// 吃苹果</span><br>    V(plate_op);       <span class="hljs-comment">// 释放盘子使用权</span><br>    V(plate);           <span class="hljs-comment">// 可放水果数增加</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>桌子上有一只盘子，爸爸负责向盘中放苹果，妈妈负责向盘中放桔子</li><li>儿子只吃盘中的桔子，女儿只吃盘中的苹果</li><li>只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果</li><li>仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore can_put = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 可以放水果的数量(放了一个后不准放等价于只有空的时候才能放)，初始为1</span><br>semaphore apple = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 盘中里的苹果数，初始为0</span><br>semaphore orange = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 盘中里的桔子数，初始为0</span><br>semaphore plate_op = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 盘中操作的信号量，初始为1</span><br><br>dad() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(can_put);         <span class="hljs-comment">// 申请放水果</span><br>    P(plate_op);        <span class="hljs-comment">// 申请盘子使用权</span><br>    放苹果              <span class="hljs-comment">// 放苹果</span><br>    V(plate_op);        <span class="hljs-comment">// 释放盘子使用权</span><br>    V(apple);           <span class="hljs-comment">// 苹果数增加</span><br>  &#125;<br>&#125;<br><br>mom() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(can_put);       <span class="hljs-comment">// 申请放水果</span><br>    P(plate_op);      <span class="hljs-comment">// 申请盘子使用权</span><br>    放桔子            <span class="hljs-comment">// 放桔子</span><br>    V(plate_op);      <span class="hljs-comment">// 释放盘子使用权</span><br>    V(orange);        <span class="hljs-comment">// 桔子数增加</span><br>  &#125;<br>&#125;<br><br>son() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(orange);          <span class="hljs-comment">// 申请吃桔子</span><br>    P(plate_op);        <span class="hljs-comment">// 申请盘子使用权</span><br>    拿桔子吃            <span class="hljs-comment">// 拿桔子吃 </span><br>    V(plate_op);        <span class="hljs-comment">// 释放盘子使用权</span><br>    V(can_put);         <span class="hljs-comment">// 可以放水果</span><br>  &#125;<br>&#125;<br><br>daught() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(apple);          <span class="hljs-comment">// 申请吃苹果</span><br>    P(plate_op);        <span class="hljs-comment">// 申请盘子使用权</span><br>    拿苹果吃            <span class="hljs-comment">// 拿苹果吃 </span><br>    V(plate_op);        <span class="hljs-comment">// 释放盘子使用权</span><br>    V(can_put);         <span class="hljs-comment">// 可以放水果</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>桌子上有一只盘子，最多可以放入2个水果</li><li>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果，放入者和取出者不允许同时使用盘子</li><li>当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore can_put_apple = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 最多放一个苹果</span><br>semaphore can_put_apple = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 最多放一个苹果</span><br>semaphore apple = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 盘中里的苹果数，初始为0</span><br>semaphore orange = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 盘中里的桔子数，初始为0</span><br>semaphore plate_op = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 盘中操作的信号量，初始为1</span><br><br>dad() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(can_put_apple);         <span class="hljs-comment">// 申请放苹果</span><br>    P(plate_op);              <span class="hljs-comment">// 申请盘子使用权</span><br>    放苹果                    <span class="hljs-comment">// 放苹果</span><br>    V(plate_op);              <span class="hljs-comment">// 释放盘子使用权</span><br>    V(apple);                 <span class="hljs-comment">// 苹果数增加</span><br>  &#125;<br>&#125;<br><br>mom() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(can_put_orange);         <span class="hljs-comment">// 申请放桔子</span><br>    P(plate_op);              <span class="hljs-comment">// 申请盘子使用权</span><br>    放桔子                    <span class="hljs-comment">// 放桔子</span><br>    V(plate_op);              <span class="hljs-comment">// 释放盘子使用权</span><br>    V(orange);                 <span class="hljs-comment">// 桔子数增加</span><br>  &#125;<br>&#125;<br><br>daught() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(apple);               <span class="hljs-comment">// 申请苹果</span><br>    P(orange);              <span class="hljs-comment">// 申请桔子</span><br>    P(plate_op);            <span class="hljs-comment">// 申请盘子使用权</span><br>    拿苹果和桔子吃           <span class="hljs-comment">// 吃苹果和桔子</span><br>    V(plate_op);            <span class="hljs-comment">// 释放盘子使用权</span><br>    V(acan_put_apple);      <span class="hljs-comment">// 允许放苹果</span><br>    V(acan_put_orange);     <span class="hljs-comment">// 允许放桔子</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>女儿负责画画，爸爸、妈妈负责欣赏</li><li>女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore dad_readed = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 爸爸看过，初始为1</span><br>semaphore mom_readed = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 妈妈看过，初始为1</span><br>semaphore dad_can_read = <span class="hljs-number">0</span>; <span class="hljs-comment">// 爸爸可以看了，初始为1</span><br>semaphore mom_can_read = <span class="hljs-number">0</span>; <span class="hljs-comment">// 妈妈可以看了，初始为1</span><br><br>daught() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(dad_readed);        <span class="hljs-comment">// 爸爸看过</span><br>    P(mom_readed);        <span class="hljs-comment">// 妈妈看过</span><br>    画画                <span class="hljs-comment">// 画画</span><br>    V(dad_can_read);    <span class="hljs-comment">// 爸爸可以看</span><br>    V(mom_can_read);    <span class="hljs-comment">// 妈妈可以看</span><br>  &#125;<br>&#125;<br><br>dad() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(dad_can_read);    <span class="hljs-comment">// 爸爸申请看</span><br>    看画                <span class="hljs-comment">// 看画</span><br>    V(dad_readeded);    <span class="hljs-comment">// 爸爸看完</span><br>  &#125;<br>&#125;<br><br>mom() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(mom_can_read);    <span class="hljs-comment">// 妈妈申请看</span><br>    看画                <span class="hljs-comment">// 看画</span><br>    V(mom_readeded);    <span class="hljs-comment">// 妈妈看完</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读者与写者问题"><a class="markdownIt-Anchor" href="#读者与写者问题"></a> 读者与写者问题</h4><p><img src="reader_writer.png" alt="问题描述图" /></p><p>读者与写者问题有<strong>3种解决策略</strong>:<br /><b></p><ul><li>读者优先</li><li>写者优先</li><li>公平读写</li></ul></b><h4 id="读者优先"><a class="markdownIt-Anchor" href="#读者优先"></a> 读者优先</h4><ul><li><strong>一旦有读者正在读数据，则允许随后的读者进入读数据</strong></li><li><strong>只有当全部读者退出，才允许写者进入写数据(可能导致写者饥饿)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> reader_count = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 读者数量，初始为0</span><br>semaphore file = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 文件操作权，初始为1，代表可以操作</span><br>semaphore count_op = <span class="hljs-number">1</span>;   <span class="hljs-comment">// count操作权，初始为1，代表可以操作</span><br><br>reader() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(count_op);                <span class="hljs-comment">// 申请修改count</span><br>    reader_count++;             <span class="hljs-comment">// 读者数量增加</span><br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">1</span>) &#123;<br>      P(file);                  <span class="hljs-comment">// 如果现在没有读者正在读文件，第一个读者则要申请使用文件</span><br>    &#125;                           <span class="hljs-comment">// 没有被count_op堵住，说明有读者在读文件，则不用申请使用文件，直接读即可</span><br>    V(count_op);                <span class="hljs-comment">// 必须在申请到资源后才能释放读者数量操作，这样才能把后来的读者堵住，否则后来读者会自行申请资源</span><br>    读文件                       <span class="hljs-comment">// 读文件</span><br>    P(count_op);<br>    reader_count--;<br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">0</span>) &#123;<br>      V(file);                  <span class="hljs-comment">// 因为是读者优先，因此不能直接释放文件，要确定没有后来的读者后再释放</span><br>    &#125;<br>    V(count_op);                <span class="hljs-comment">// 释放读者数量操作</span><br>  &#125;<br>&#125;<br><br>writer() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(file);        <span class="hljs-comment">// 申请使用文件</span><br>    写文件          <span class="hljs-comment">// 写文件</span><br>    V(file);        <span class="hljs-comment">// 写完释放文件</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题:</p><ul><li>有一座东西方向的独木桥，同一方向的行人可连续过桥</li><li>桥上没有行人过桥时，任何一端的行人均可上桥</li><li>独木桥的最大承重为4人</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> E2W_count = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> W2E_count = <span class="hljs-number">0</span>;<br>semaphore E2W_count_op = <span class="hljs-number">1</span>;<br>semaphore W2E_count_op = <span class="hljs-number">1</span>;<br>semaphore orientation = <span class="hljs-number">1</span>;<br>semaphore people_count = <span class="hljs-number">4</span>;<br><br>E2W() &#123;<br>  P(E2W_count_op);              <span class="hljs-comment">// 申请操作E2W的人数</span><br>  E2W_count++;                  <span class="hljs-comment">// E2W人数增加</span><br>  <span class="hljs-keyword">if</span>(E2W_count == <span class="hljs-number">1</span>) &#123;          <br>    P(bridge);                  <span class="hljs-comment">// 第一个E2W的人要排队</span><br>  &#125;                             <span class="hljs-comment">// 过了操作E2W说明一定有E2W的人占住了桥</span><br>  V(E2W_count_op);              <span class="hljs-comment">// 释放E2W人数操作</span><br>  P(people_count);              <span class="hljs-comment">// 申请上桥，防止桥超载</span><br>  过桥                          <span class="hljs-comment">// 过桥</span><br>  V(people_count);              <span class="hljs-comment">// 释放桥承载</span><br>  P(E2W_count_op);              <span class="hljs-comment">// 申请操作E2W的人数</span><br>  E2W_count--;                  <span class="hljs-comment">// E2W人数减少</span><br>  <span class="hljs-keyword">if</span>(E2W_count == <span class="hljs-number">0</span>) &#123;<br>    V(bridge);                  <span class="hljs-comment">// 后面没人了则释放桥</span><br>  &#125;<br>  V(E2W_count_op);              <span class="hljs-comment">// 释放E2W人数操作</span><br>&#125;<br><br>W2E() &#123;<br>  P(E2W_count_op);              <span class="hljs-comment">// 申请操作W2E的人数</span><br>  E2W_count++;                  <span class="hljs-comment">// W2E人数增加</span><br>  <span class="hljs-keyword">if</span>(E2W_count == <span class="hljs-number">1</span>) &#123;          <br>    P(bridge);                  <span class="hljs-comment">// 第一个W2E的人要排队</span><br>  &#125;                             <span class="hljs-comment">// 过了操作W2E说明一定有W2E的人占住了桥</span><br>  V(E2W_count_op);              <span class="hljs-comment">// 释放W2E人数操作</span><br>  P(people_count);              <span class="hljs-comment">// 申请上桥，防止桥超载</span><br>  过桥                          <span class="hljs-comment">// 过桥</span><br>  V(people_count);              <span class="hljs-comment">// 释放桥承载</span><br>  P(E2W_count_op);              <span class="hljs-comment">// 申请操作W2E的人数</span><br>  E2W_count--;                  <span class="hljs-comment">// W2E人数减少</span><br>  <span class="hljs-keyword">if</span>(E2W_count == <span class="hljs-number">0</span>) &#123;<br>    V(bridge);                  <span class="hljs-comment">// 后面没人了则释放桥</span><br>  &#125;<br>  V(E2W_count_op);              <span class="hljs-comment">// 释放W2E人数操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平读写"><a class="markdownIt-Anchor" href="#公平读写"></a> 公平读写</h4><p><strong>写过程中，若其它读者、写者到来，则按到达顺序处理</strong><br /><strong>公平读写可以由读者优先进行简单改进而得到</strong><br />因为<code>file</code>这个信号量对已经有读者在访问文件时无效，即便前面有写者在排队也会被跳过，因此可以由写者加一个<strong>防插队门锁lock</strong>，即如果读者前面有写者则无法直接插队，而<strong>如果前面的是读者则lock不应该阻止读者一起读</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> reader_count = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 读者数量，初始为0</span><br>semaphore file = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 文件操作权，初始为1，代表可以操作</span><br>semaphore count_op = <span class="hljs-number">1</span>;   <span class="hljs-comment">// count操作权，初始为1，代表可以操作</span><br>semaphore lock = <span class="hljs-number">1</span>;       <span class="hljs-comment">// 防插队锁</span><br><br>reader() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(lock);                    <span class="hljs-comment">// 防插队锁</span><br>    P(count_op);                <span class="hljs-comment">// 申请修改count</span><br>    reader_count++;             <span class="hljs-comment">// 读者数量增加</span><br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">1</span>) &#123;<br>      P(file);                  <span class="hljs-comment">// 如果现在没有读者正在读文件，第一个读者则要申请使用文件</span><br>    &#125;                           <span class="hljs-comment">// 没有被count_op堵住，说明有读者在读文件，则不用申请使用文件，直接读即可</span><br>    V(count_op);                <span class="hljs-comment">// 必须在申请到资源后才能释放读者数量操作，这样才能把后来的读者堵住，否则后来读者会自行申请资源</span><br>    V(lock);                    <span class="hljs-comment">// 读者不能阻止后来的读者，因此在一起读前要释放锁</span><br>    读文件                       <span class="hljs-comment">// 读文件</span><br>    P(count_op);<br>    reader_count--;<br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">0</span>) &#123;<br>      V(file);                  <span class="hljs-comment">// 因为是读者优先(在其基础上改而成的)，因此不能直接释放文件，要确定没有后来的读者后再释放</span><br>    &#125;<br>    V(count_op);                <span class="hljs-comment">// 释放读者数量操作</span><br>  &#125;<br>&#125;<br><br>writer() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(lock);        <span class="hljs-comment">// 防插队锁</span><br>    P(file);        <span class="hljs-comment">// 申请使用文件</span><br>    写文件          <span class="hljs-comment">// 写文件</span><br>    V(file);        <span class="hljs-comment">// 写完释放文件</span><br>    V(lock);        <span class="hljs-comment">// 释放锁</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写者优先"><a class="markdownIt-Anchor" href="#写者优先"></a> 写者优先</h4><p><strong>当至少有一个写者声明想写数据时，则不再允许新的读者进入读数据</strong><br />写者优先也是与读者优先类似，<strong>写者可以插队，因此读者必须排队</strong>，而在读写公平加了lock锁后读者就必须排队了，同样写者也要排队，现在写者优先可以通过对写者的防插队锁<code>lock</code>进行<strong>选择性加锁</strong>来实现，同时如果读者在前面有很长的队列，第一个写者需要慢慢排队过去才能让后面的写者插队，因此需要<strong>限制读者队伍长度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> reader_count = <span class="hljs-number">0</span>;             <span class="hljs-comment">// 读者数量，初始为0</span><br>semaphore file = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 文件操作权，初始为1，代表可以操作</span><br>semaphore reader_count_op = <span class="hljs-number">1</span>;    <span class="hljs-comment">// reader_count操作权，初始为1，代表可以操作</span><br>semaphore lock = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 防插队锁</span><br><span class="hljs-type">int</span> writer_count = <span class="hljs-number">0</span>;             <span class="hljs-comment">// 写者优先也需要计数</span><br>semaphore writer_count_op = <span class="hljs-number">1</span>;    <span class="hljs-comment">// writer_count操作权，初始为1，代表可以操作</span><br>semaphore limit = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 读者队伍长度锁</span><br><br>reader() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(limit);                   <span class="hljs-comment">// 读者队伍长度加锁</span><br>    P(lock);                    <span class="hljs-comment">// 防插队锁</span><br>    P(reader_count_op);         <span class="hljs-comment">// 申请修改count</span><br>    reader_count++;             <span class="hljs-comment">// 读者数量增加</span><br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">1</span>) &#123;<br>      P(file);                  <span class="hljs-comment">// 如果现在没有读者正在读文件，第一个读者则要申请使用文件</span><br>    &#125;                           <span class="hljs-comment">// 没有被count_op堵住，说明有读者在读文件，则不用申请使用文件，直接读即可</span><br>    V(reader_count_op);         <span class="hljs-comment">// 必须在申请到资源后才能释放读者数量操作，这样才能把后来的读者堵住，否则后来读者会自行申请资源</span><br>    V(lock);                    <span class="hljs-comment">// 读者不能阻止后来的读者，因此在一起读前要释放锁</span><br>    V(limit);                   <span class="hljs-comment">// 一起读后允许下一个读者进入，这样读者队伍长度就限制在1以内了</span><br>    读文件                       <span class="hljs-comment">// 读文件</span><br>    P(reader_count_op);<br>    reader_count--;<br>    <span class="hljs-keyword">if</span>(reader_count == <span class="hljs-number">0</span>) &#123;<br>      V(file);                  <span class="hljs-comment">// 因为是读者优先(在其基础上改而成的)，因此不能直接释放文件，要确定没有后来的读者后再释放</span><br>    &#125;<br>    V(reader_count_op);         <span class="hljs-comment">// 释放读者数量操作</span><br>  &#125;<br>&#125;<br><br>writer() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(writer_count_op);       <span class="hljs-comment">// 申请写者数操作</span><br>    writer_count++;           <span class="hljs-comment">// 写者数增加</span><br>    <span class="hljs-keyword">if</span>(writer_count == <span class="hljs-number">1</span>) &#123;<br>      P(lock);                <span class="hljs-comment">// 第一个写者排队加锁</span><br>    &#125;                         <span class="hljs-comment">// 后面写者不需要加排队锁，直接插读者队</span><br>    V(writer_count_op);       <span class="hljs-comment">// 释放写者操作</span><br>    P(file);                  <span class="hljs-comment">// 申请使用文件</span><br>    写文件                    <span class="hljs-comment">// 写文件</span><br>    V(file);                  <span class="hljs-comment">// 写完释放文件</span><br>    P(writer_count_op);       <span class="hljs-comment">// 申请写者数操作</span><br>    writer_count--;           <span class="hljs-comment">// 写者数增加</span><br>    <span class="hljs-keyword">if</span>(writer_count == <span class="hljs-number">0</span>) &#123;<br>      V(lock);                <span class="hljs-comment">// 最后一个写者释放让写者插队的锁</span><br>    &#125;<br>    V(writer_count_op);       <span class="hljs-comment">// 释放写者操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="理发师问题"><a class="markdownIt-Anchor" href="#理发师问题"></a> 理发师问题</h4><p>理发店有1位理发师、1把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客，则理发师睡觉。当一个顾客到来时，他必须叫醒理发师，如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，他就坐下来等。如果没有空椅子，他就离开</p><p><img src="barber.png" alt="理发师睡觉问题" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> customer_count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 店里的顾客,含正在理发的人数</span><br>semaphore count_op = <span class="hljs-number">1</span>;      <span class="hljs-comment">// waiting的互斥信号量</span><br>semaphore barber_chair = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 理发椅的个数</span><br>semaphore wating_chair = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 空椅子的个数</span><br>semaphore ready = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 是否有顾客准备好</span><br>semaphore finish = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 理发师是否完成理发</span><br><br>barber() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(ready);                  <span class="hljs-comment">// 顾客准备好</span><br>    理发                       <span class="hljs-comment">// 理发</span><br>    V(finish);                 <span class="hljs-comment">// 完成理发</span><br>  &#125;<br>&#125;<br><br>customer() &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(customer_count_op);         <span class="hljs-comment">// 需要使用顾客数来判断，因此必须保证互斥</span><br>    <span class="hljs-keyword">if</span>(customer_count &lt;= <span class="hljs-number">6</span>) &#123;<br>      customer_count++;           <span class="hljs-comment">// 留下来，顾客数增加</span><br>      V(customer_count_op);       <span class="hljs-comment">// 释放顾客数操作</span><br>      P(wating_chair);            <span class="hljs-comment">// 找空椅子坐下</span><br>      P(barber_chair);            <span class="hljs-comment">// 准备理发</span><br>      V(ready);                   <span class="hljs-comment">// 通知理发师开始</span><br>      P(finish);                  <span class="hljs-comment">// 等待理发师完成</span><br>      V(barber_chair);            <span class="hljs-comment">// 离开</span><br>      P(customer_count_op);       <span class="hljs-comment">// 申请顾客数操作</span><br>      customer_count--;           <span class="hljs-comment">// 顾客数减少</span><br>      V(customer_count_op);       <span class="hljs-comment">// 释放顾客数操作</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      离开<br>      V(customer_count_op);       <span class="hljs-comment">// 释放顾客数操作</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="哲学家就餐问题"><a class="markdownIt-Anchor" href="#哲学家就餐问题"></a> 哲学家就餐问题</h4><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="philosopher.png" alt="哲学家就餐问题" /></p><p><strong>资源分级一: 为餐叉编号，就餐前，先取用编号较低的餐叉，再取用编号较高的餐叉，就餐毕，先放下编号较高的餐叉，再放下编号较低的餐叉</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chopstick[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//初始化信号量</span><br>semaphore mutex = l;                      <span class="hljs-comment">//设置取筷子的信号量</span><br>P(<span class="hljs-type">int</span> i) &#123;                          <span class="hljs-comment">//i号哲学家的进程</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    P(mutex);                  <span class="hljs-comment">//在取筷子前获得互斥量</span><br>    <span class="hljs-keyword">if</span>(i != <span class="hljs-number">4</span>) &#123;<br>      P(chopstick[i]);           <span class="hljs-comment">//取左边筷子(编号低)</span><br>      P(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);   <span class="hljs-comment">//取右边筷子(编号高)</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      P(chopstick[(i+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]);   <span class="hljs-comment">//取右边筷子(编号低)</span><br>      P(chopstick[i]);           <span class="hljs-comment">//取左边筷子(编号高)</span><br>    &#125;<br>    V(mutex);                  <span class="hljs-comment">//释放取筷子的信号量</span><br>    就餐                       <span class="hljs-comment">//进餐</span><br>    <span class="hljs-keyword">if</span>(i != <span class="hljs-number">4</span>) &#123;<br>      V(chopstick[(i+l) % <span class="hljs-number">5</span>]);   <span class="hljs-comment">//放回右边筷子(编号高)</span><br>      V(chopstick[i]);           <span class="hljs-comment">//放回左边筷子(编号低)</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      V(chopstick[i]);          <span class="hljs-comment">//放回左边筷子(编号高)</span><br>      V(chopstick[(i+l) % <span class="hljs-number">5</span>]);  <span class="hljs-comment">//放回右边筷子(编号低)</span><br>    &#125;<br>    思考                      <span class="hljs-comment">// 思考</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>资源分级二: 为哲学家编号，奇数号的哲学家必须首先拿左边的餐叉，偶数号的哲学家必须首先拿右边的餐叉</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chopstick[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//初始化信号量</span><br>semaphore mutex = l;                      <span class="hljs-comment">//设置取筷子的信号量</span><br><br>P(<span class="hljs-type">int</span> i) &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>      wait(fork[i]); <br>      wait(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);      <span class="hljs-comment">// 先左后右</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      wait(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]); <br>      wait(fork[i]);            <span class="hljs-comment">// 先右后左</span><br>    &#125;<br>    就餐                        <span class="hljs-comment">//进餐</span><br>    signal(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);      <span class="hljs-comment">//先右后左</span><br>    signal(fork[i]);<br>    思考                        <span class="hljs-comment">// 思考</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务生方法: 引入一个餐厅服务生，哲学家必须经过他的允许才能拿起餐叉，并且最多允许4个哲学家同时进食</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore chopstick[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//初始化信号量</span><br>semaphore mutex = l;                      <span class="hljs-comment">//设置取筷子的信号量</span><br>semaphore room = <span class="hljs-number">4</span>;                       <span class="hljs-comment">// 最多4位哲学家</span><br><br><br>P(<span class="hljs-type">int</span> i) &#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    wait(room);                             <span class="hljs-comment">//占据就餐位置</span><br>    wait(fork[i]);                          <span class="hljs-comment">//拿起左边的叉子</span><br>    wait(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);                    <span class="hljs-comment">//拿起右边的叉子</span><br>    就餐                                    <span class="hljs-comment">//进餐</span><br>    signal(fork[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);                  <span class="hljs-comment">//放回右边的叉子</span><br>    signal(fork[i]);                        <span class="hljs-comment">//放回左边的叉子</span><br>    signal(room);                           <span class="hljs-comment">//释放就餐位置</span><br>    思考                                    <span class="hljs-comment">// 思考</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p><strong>定义</strong>: 一组<strong>相互竞争系统资源</strong>或<strong>进行通信</strong>的<strong>进程间</strong>的<strong>永久阻塞</strong></p><p><span style="color:#ff562b"><b>当一组进程中的每个进程都在等待某事件，而只有同组进程中阻塞的其他进程能够促发该事件时，死锁发生</b></span></p><h3 id="死锁原理"><a class="markdownIt-Anchor" href="#死锁原理"></a> 死锁原理</h3><p>资源分为:</p><ul><li><strong>可重用资源</strong>: 一次仅<strong>供一个进程安全使用且不因使用而耗尽</strong>的资源，如CPU、内存外存、设备等</li><li><strong>可消耗资源</strong>: 可消耗资源是指**可被创建(生产)和销毁(消耗)**的资源</li></ul><p>死锁发生的原因正如定义所言: <strong>竞争系统资源</strong>或<strong>进行通信</strong><br /><img src="deadlock_example_1.png" alt="竞争可重用资源" /><br /><img src="deadlock_example_2.png" alt="竞争可消耗资源(通信)" /></p><p><strong>死锁发生的条件</strong>:</p><ul><li>必要条件<ul><li><strong>互斥</strong>: 一次只有一个进程可以使用一个资源</li><li><strong>占有且等待</strong>: 当进程等待其他资源时，继续占有已经分配的资源</li><li><strong>不可抢占</strong>: 不能强行抢占进程已经占有的资源</li></ul></li><li>充分条件: <strong>循环等待</strong>: 存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</li></ul><p><img src="circle_wait.png" alt="循环等待" /></p><p><img src="deadlock_approach.png" alt="死锁解决" /></p><h3 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h3><p>死锁预防的方法就是<strong>防止死锁产生条件的发生</strong>，防止3个必要条件中任意一条发生，也防止循环等待发生</p><p><strong>互斥</strong><br />如果需要对资源互斥访问，那么操作系统必须支持，否则很多OS功能无法实现，因此<strong>无法预防互斥</strong></p><p><strong>占有且等待</strong><br />要求进程<strong>一次性请求所有资源</strong>，并<strong>阻塞这个进程直到所有资源请求能够满足</strong>但进程所需所有资源可能不确定，因此进程可能会阻塞很长时间，并且某些已分配资源可能很久不使用</p><p><strong>不可抢占</strong><br />一个占有某些资源的进程进一步申请资源时若被拒绝，则<strong>释放最初占有的资源</strong>或<strong>操作系统要求另一个进程释放资源</strong></p><p><strong>循环等待</strong><br />定义一个请求资源的顺序，系统把所有资源按类型进行<strong>线性排队</strong>，如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">R_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_k(i&lt;j&lt;k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，所有进程对资源的请求必须严格按资源序号递增的顺序提出</p><h3 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h3><p><strong>死锁避免允许3个必要条件发生</strong>，但在系统运行过程中，检查进程的资源申请，若分配后<strong>系统可能发生死锁则不予分配</strong>，否则予以分配</p><p>判断资源分配是否安全的算法称为<strong>银行家算法</strong>:<br />当用户申请一组资源时，系统必须做出判断: 如果把这些资源分出去，系统是否还处于<strong>安全状态</strong>。若是，就可以分配这些资源，否则，暂时不分配，阻塞进程</p><p><strong>注意</strong>: 安全状态是非死锁状态，而<strong>不安全状态并不一定是死锁状态</strong>，即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态</p><p><img src="safe_sequence.png" alt="安全状态" /></p><p><img src="banker_algorithm.png" alt="银行家算法" /></p><p>数据结构说明:</p><ul><li>Available向量: 系统中可利用的资源数目</li><li>Max矩阵: 每个进程对每种资源的最大需求</li><li>Allocation矩阵: 每个进程已分配的各类资源的数目</li><li>Need矩阵: 每个进程还需要的各类资源数</li><li><strong>Need[i, j] = Max[i, j] - allocation[i, j]</strong></li></ul><p>例题:</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="banker_algorithm_example_table.png" alt="" /></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="banker_algorithm_example_question.png" alt="" /></div></div></div><p><strong>(1)</strong>: 安全，因为存在安全序列: P2 -&gt; P1 -&gt; P3 -&gt; P4<br /><strong>(2)</strong>: 分配资源后如图，仍然安全，因为存在安全序列: P2 -&gt; P1 -&gt; P3 -&gt; P4<br /><img src="banker_algorithm_example_answer_1.png" alt="" /><br /><strong>(3)</strong>: 不能，因为系统剩余资源不足P1要求的资源<br /><strong>(4)</strong>: 分配资源后如图，不安全，因为剩余资源无法使任何进程结束<br /><img src="banker_algorithm_example_answer_2.png" alt="" /></p><p>死锁避免的使用限制</p><ul><li>必须事先声明每个进程请求的最大资源</li><li>进程必须是独立的，它们执行顺序没有同步的要求</li><li>分配资源的数量必须是固定的</li><li>占有资源时，进程不能退出</li></ul><h3 id="死锁检测与解除"><a class="markdownIt-Anchor" href="#死锁检测与解除"></a> 死锁检测与解除</h3><p>死锁检测与解除允许死锁的发生，只要有可能，就给进程分配其所请求的资源，但会<strong>定时进行死锁检测</strong></p><p><strong>死锁检测算法</strong>(<strong>与银行家算法安全性检查中相同</strong>)步骤:</p><ol><li>标记Allocation矩阵中一行全为零的进程</li><li>初始化一个临时向量W，令W等于Available向量</li><li>查找下标i，进程i当前未标记且满足Q(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Q_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示进程i请求j类资源的数量）的第i行小于等于W, 即对所有的k,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>≤</mo><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">Q_{ik}\leq W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 若找不到这样的行，终止算法</li><li>若找到这样的行，标记进程i，并把Allcation矩阵中的相应行加到W中，即对所有k, 令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub><mo>=</mo><msub><mi>W</mi><mi>k</mi></msub><mo>+</mo><msub><mi>A</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_k= W_k+A_{ik}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，返回步骤3</li></ol><p>解除: <strong>检测到死锁后，按照某种可能的策略来解除</strong><br />策略:</p><ul><li>撤消进程: 连续撤消死锁进程直到不再存在死锁</li><li>回退: 把进程回退到前面定义的某些检查点，并重新启动所有进程</li><li>抢占: 连续抢占资源直到不再存在死锁</li></ul><p>选择原则: 目前为止消耗处理器时间少，或输出少，或分配资源少，或剩余时间长，或优先级最低的进程</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概论</title>
    <link href="/2023/02/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <url>/2023/02/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概论"><a class="markdownIt-Anchor" href="#操作系统概论"></a> 操作系统概论</h1><p>操作系统是<strong>控制应用程序执行的程序</strong>，是<strong>应用程序和计算机硬件间的接口</strong><br /><img src="architecture.png" alt="计算机软硬件结构" /></p><h2 id="操作系统目标与功能"><a class="markdownIt-Anchor" href="#操作系统目标与功能"></a> 操作系统目标与功能</h2><h3 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h3><p>其<strong>3个目标</strong>为:</p><ul><li><strong>方便</strong>: 使计算机<strong>更易于使用</strong></li><li><strong>有效</strong>: 允许以<strong>更有效的方式</strong>使用计算机系统<strong>资源</strong></li><li><strong>扩展能力</strong>: 在不妨碍服务的前提下，有效地开发、测试和引入<strong>新的系统功能</strong></li></ul><p>以下介绍计算机是<strong>如何实现</strong>上述的3个目标</p><h4 id="os是用户计算机接口"><a class="markdownIt-Anchor" href="#os是用户计算机接口"></a> OS是用户／计算机接口</h4><p>如果用户开发应用软件时需要完全使用机器指令来进行描述将会使得开发任务复杂且繁重，而OS将一部分机器指令<strong>提供了一定的库函数、实用工具</strong>，从而简化了应用软件的开发过程<br />OS为程序员<strong>屏蔽了硬件细节</strong>，并为程序员使用系统<strong>提供了方便的接口</strong>，使程序员及应用程序更容易地访问与使用这些功能和服务<br /><strong>因此OS实现了使计算机更易于使用</strong></p><h4 id="os是计算机资源管理器"><a class="markdownIt-Anchor" href="#os是计算机资源管理器"></a> OS是计算机资源管理器</h4><p>计算机是由各种不同部件构成的机器，包括CPU、内存、外存、总线等，并由这些部件提供一定的<strong>计算资源、存储资源</strong><br />计算机的资源是有限的，而OS能够进行<strong>资源的调度</strong>，由OS来将不同的资源分配给不同的任务，从而<strong>实现计算机资源的高效利用</strong></p><h4 id="os具有良好的扩展性"><a class="markdownIt-Anchor" href="#os具有良好的扩展性"></a> OS具有良好的扩展性</h4><p>由于<strong>硬件升级和新型硬件的出现</strong>、<strong>新的服务需求的提出</strong>，同时以前的OS被<strong>发现了错误</strong>，OS需要不断地更新从而满足改变，因此OS被设计成了<strong>模块化的结构</strong>，并且具有<strong>详细的模块接口和文档说明</strong>，才能做到具有良好的扩展性</p><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><p>OS的<strong>基本功能</strong>是<strong>提供用户使用计算机系统的接口</strong>:<br /><b></p><ul><li>进程管理</li><li>存储管理</li><li>I/O设备管理</li><li>文件管理</li></ul></b><p>具体功能:</p><ul><li><strong>程序开发</strong>: 如编辑器和调试器</li><li><strong>程序运行</strong>: 如将程序加载到内存</li><li><strong>I/O设备访问</strong>: 隐藏具体的I/O操作指令</li><li><strong>文件访问控制</strong>: 屏蔽存储介质细节</li><li><strong>系统访问</strong>: 提供接口，防止未授权访问行为</li><li><strong>错误检测和响应</strong>: 软硬件错误</li><li><strong>记账</strong>: 收集资源的利用率信息、监控性能特性</li></ul><h2 id="操作系统发展史"><a class="markdownIt-Anchor" href="#操作系统发展史"></a> 操作系统发展史</h2><p><img src="OS_develop.png" alt="操作系统发展史" /></p><h3 id="串行处理"><a class="markdownIt-Anchor" href="#串行处理"></a> 串行处理</h3><p>无操作系统，由<strong>手动将程序输入到计算机内，由计算机执行后得到输出</strong></p><h3 id="简单批处理"><a class="markdownIt-Anchor" href="#简单批处理"></a> 简单批处理</h3><p>出现了监控程序(Monitor)，可以<strong>将一批程序放入计算机，然后由Monitor按顺序将每个程序交给计算机处理，处理完成后再返回Monitor，由Monitor放入下一个程序</strong></p><p>Monitor<strong>功能</strong>:</p><ul><li><strong>自动续接</strong>: 将作业按顺序交给计算机</li><li><strong>内存保护</strong>: 计算机内存中<strong>只能同时存在一道作业</strong>，并且<strong>作业不能修改Monitor的内存空间</strong></li><li><strong>定时器</strong>: 防止某作业独占系统</li><li><strong>特权指令</strong>: 将计算机的运行模式分为了<strong>内核模式</strong>和<strong>用户模式</strong></li><li><strong>中断</strong>: 早期计算机模型无此能力</li></ul><h3 id="多道批处理"><a class="markdownIt-Anchor" href="#多道批处理"></a> 多道批处理</h3><p>I/O设备相对于处理器而言速度太慢，因此对简单的批处理而言，<strong>大多数时间均花费在IO上</strong>，处理器占用率很低<br /><img src="simple_batch_process.png" alt="简单批处理" /><br />多道批处理则是通过<strong>利用IO时间来执行其他作业</strong>的操作系统<br /><img src="multi_batch_process.png" alt="多道批处理" /></p><p>多道批处理<strong>功能</strong>:</p><ul><li><strong>内存管理</strong>: 内存中需要放多个作业</li><li><strong>作业调度</strong>: 需要进行多个作业的调度</li><li><strong>中断</strong>: CPU需要得知IO操作完成</li><li><strong>DMA</strong>: IO操作无需处理器参与</li></ul><h3 id="分时系统"><a class="markdownIt-Anchor" href="#分时系统"></a> 分时系统</h3><p>多道批处理系统提高了对处理器的利用率，但由于只处理批作业而无法进行实时的交互，因此出现了分时系统<br /><img src="time_share_system.png" alt="多道批处理与分时系统比较" /></p><p>分时系统的<strong>特征</strong>:</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul><h3 id="实时系统"><a class="markdownIt-Anchor" href="#实时系统"></a> 实时系统</h3><p>实时系统能够<strong>及时(即时)响应外部事件的请求</strong>，<strong>在规定的时间内开始或完成对该事件的处理</strong>，并控制所有实时任务<strong>协调一致地运行</strong></p><p>实时系统的<strong>特征</strong>:</p><ul><li>可确定性</li><li>可响应性</li><li>用户控制</li><li>可靠性</li><li>故障弱化能力</li></ul><h2 id="操作系统主要成就"><a class="markdownIt-Anchor" href="#操作系统主要成就"></a> 操作系统主要成就</h2><p>操作系统的<strong>4个重要理论进展</strong>，这4个领域包括现代操作系统设计和实现中的关键问题:<br /><b></p><ul><li>进程</li><li>内存管理</li><li>信息保护和安全</li><li>调度和资源管理</li></ul></b><h2 id="操作系统特征"><a class="markdownIt-Anchor" href="#操作系统特征"></a> 操作系统特征</h2><b><ul><li>微内核: 只给内核分配一些最基本的功能，可以简化实现、提供灵活性和适用于分布式环境</li><li>多线程: 把执行一个应用程序的进程划分为可以同时运行的多个线程</li><li>对称多处理: 多个处理器或多核</li><li>分布式操作系统: 使用不同物理机构成一个抽象意义机器</li><li>面向对象设计: 使得操作系统的扩展性更好</li></ul></b><h2 id="操作系统的容错率"><a class="markdownIt-Anchor" href="#操作系统的容错率"></a> 操作系统的容错率</h2><p><strong>容错性指系统或部件发生软/硬件错误时，能够继续正常运行的能力</strong><br />容错性的相关技术:</p><ul><li><strong>进程隔离</strong>: 进程的<strong>内存</strong>、<strong>文件存取</strong>和<strong>执行过程</strong>相互隔离</li><li><strong>并发控制</strong>: 采用并发控制保证进程<strong>通信或协作</strong>时的正确性</li><li><strong>虚拟机</strong>: 提供<strong>更高程度</strong>的应用隔离和错误隔离</li><li><strong>检测点和回滚机制</strong>: 检测点是先前程序状态的一个副本。回滚则从检测点重新开始执行</li></ul><h2 id="多处理器与多核操作系统"><a class="markdownIt-Anchor" href="#多处理器与多核操作系统"></a> 多处理器与多核操作系统</h2><p>多处理器上的操作系统设计不仅要提供<strong>多道系统的所有功能</strong>，而且必须提供适应多处理器的额外功能<br /><img src="multi_processor.png" alt="" /><br />多处理器OS的<strong>并行能力</strong>:</p><ul><li><strong>处理器并行</strong>: 多个软件可以在不同处理器上并行执行</li><li><strong>进程/线程并行</strong>: 每个处理器可以在不同进程/线程上切换，从而实现进行/线程并行</li><li><strong>指令并行</strong>: 核内指令也可以并行</li></ul><h2 id="主流操作系统"><a class="markdownIt-Anchor" href="#主流操作系统"></a> 主流操作系统</h2><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p><img src="windows_architecture.png" alt="Windows模块化体系结构" /><br /><strong>四种基本的用户模式进程</strong></p><ul><li><strong>特殊系统进程</strong>: 管理系统所需的用户模式服务</li><li><strong>服务进程</strong>: 后台打印程序、网络服务程序(Mysql)等</li><li><strong>环境子系统</strong>: 操作系统个性化设置</li><li><strong>用户应用程序</strong>: 为充分利用系统功能而为用户提供的<strong>可执行程序</strong>和<strong>动态链接库</strong>(connect.exe、Win32.dll等)</li></ul><p>Windows的<strong>操作系统服务、受保护子系统和应用程序</strong>都采用客户-服务器模型构建，服务端与客户端<strong>通过RPC通信</strong></p><h3 id="传统unix"><a class="markdownIt-Anchor" href="#传统unix"></a> 传统Unix</h3><p><img src="traditional_unix_architecture.png" alt="传统Unix架构" /><br /><img src="traditional_unix_kernel.png" alt="传统Unix内核" /></p><h3 id="现代unix"><a class="markdownIt-Anchor" href="#现代unix"></a> 现代Unix</h3><p><img src="unix_architecture.png" alt="现代Unix架构" /></p><p><img src="unix_history.png" alt="Unix发展史" /></p><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><p>Linux是<strong>模块化的宏内核</strong>，其在一大块代码中包含了所有的操作系统功能，作为<strong>单个进程运行</strong>，具有唯一的地址空间，并且所有的功能部件都可以访问内核数据结构和例程<br />同时Linux具有很多<strong>可加载模块</strong>，可以在内核在运行时可以链接或断开链接<br /><img src="linux_kernel.png" alt="Linux内核" /></p><h3 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android</h3><p><img src="android_architecture.png" alt="Android架构" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程</title>
    <link href="/2023/01/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/01/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程"><a class="markdownIt-Anchor" href="#软件工程"></a> 软件工程</h1><h2 id="概论"><a class="markdownIt-Anchor" href="#概论"></a> 概论</h2><h3 id="软件的定义"><a class="markdownIt-Anchor" href="#软件的定义"></a> 软件的定义</h3><p><b>软件定义: 软件 = 程序 + 数据 + 文档</b></p><ul><li>程序: 按事先设计的<strong>功能</strong>和<strong>性能</strong>需求执行的<strong>指令序列</strong></li><li>数据: 是程序能正常操纵信息的<strong>数据结构</strong></li><li>文档: 与<strong>程序开发</strong>、<strong>维护</strong>和<strong>使用</strong>有关的<strong>图文材料</strong></li></ul><p><strong>文档的作用</strong></p><ul><li>提高软件开发过程的<strong>能见度</strong>；</li><li><strong>记录</strong>开发过程的<strong>有关信息</strong>，便于使用与维护；</li><li>提高开发<strong>效率</strong>；</li><li>作为开发人员<strong>阶段工作成果和结束标志</strong>；</li><li>提供软件运行、维护、培训有关<strong>资料</strong>；</li><li>便于<strong>用户了解</strong>软件功能和性能；</li></ul><h3 id="软件的特点"><a class="markdownIt-Anchor" href="#软件的特点"></a> 软件的特点</h3><p>软件是逻辑的，而不是物理的，其特点如下:</p><ul><li>软件是<strong>开发的或者是工程化</strong>的，<strong>并不是制造的</strong></li><li>软件<strong>开发环境</strong>对产品影响较大</li><li>软件开发时间和工作量<strong>难以估计</strong></li><li>软件会<strong>多次修改</strong></li><li>软件的开发进度几何<strong>没有客观衡量标准</strong></li><li>软件测试困难</li><li>软件<strong>不会磨损和老化</strong></li><li>软件维护易产生新的问题</li><li>软件生产是简单的拷贝</li></ul><h3 id="软件的双重作用"><a class="markdownIt-Anchor" href="#软件的双重作用"></a> 软件的双重作用</h3><p>软件的双重作用是指软件具有<strong>两种角色</strong>，软件即是一种<strong>产品</strong>，也是<strong>开发其他软件产品的工具</strong></p><ul><li>作为产品，软件扮演着信息转换的角色，产生、管理、查询、修改、显示、传递信息。如应用软件(office)等</li><li>作为产品生产的载体，软件提供了计算机控制、信息通信以及应用程序开发和控制的基础平台。如操作系统(Windows)、软件开发工具(IDE)等</li></ul><h3 id="软件危机"><a class="markdownIt-Anchor" href="#软件危机"></a> 软件危机</h3><p><b>软件危机的定义: 是指在软体开发及维护的过程中所遇到的一系列严重问题，比如软件开发周期长、软件开发成本高、软件质量差、软件维护难</b></p><p>软件危机的<strong>具体表现</strong>为:</p><ul><li>开发成本和进度估计不准，<strong>开发进度难以控制</strong>(开发难)</li><li>软件<strong>开发生产率滞后</strong>于硬件和计算机应用普及(周期长)</li><li>软件成本逐年上升(<strong>成本高</strong>)</li><li><strong>用户对已完成的软件系统不满意(质量差)</strong></li><li>软件质量和可靠性差强人意(<strong>质量差</strong>)</li><li>软件常常是不可维护的(<strong>维护难</strong>)</li><li>软件通常没有适当的文档资料(<strong>维护难、使用难</strong>)</li></ul><h3 id="软件工程-2"><a class="markdownIt-Anchor" href="#软件工程-2"></a> 软件工程</h3><p>软件工程是为了<strong>应对软件危机</strong>在实践中总结出来的<strong>开发软件的成功技术和方法</strong>。其认为软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。</p><h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4><p><b>软件工程的定义: 将系统化的、科学化的、可量化的方法应用于软件的开发、运行和维护，即针对软件的工程应用以及对上述方法的研究。</b></p><h4 id="目标"><a class="markdownIt-Anchor" href="#目标"></a> 目标</h4><p><b>软件工程的目标是在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。</b></p><h4 id="原则"><a class="markdownIt-Anchor" href="#原则"></a> 原则</h4><ol><li>使用<strong>阶段性生命周期计划的管理</strong></li><li>进行<strong>连续的验证</strong></li><li>保证<strong>严格的产品控制</strong></li><li>使用<strong>现代编程工具/工程</strong>实践</li><li>保持清晰的<strong>责任分配</strong></li><li>用<strong>更好更少</strong>的人</li><li>保持<strong>过程改进</strong></li></ol><h4 id="对软件工程的误解"><a class="markdownIt-Anchor" href="#对软件工程的误解"></a> 对软件工程的误解</h4><ol><li>Question: 如果项目进度落后了，可以加入更多的程序员来赶进度？<br />Answer: 软件开发的机制和手工作业不一样。在一个延迟了的软件项目中<strong>加入新的开发人员只会让它延迟更多</strong></li><li>Question: 如果我们将软件项目外包给第三方，我们就轻松了，让那个公司去完成它吧<br />Answer: 如果组织管理方不懂得如何<strong>从内部管理和控制软件项目</strong>，即使将项目外包也无济于事</li><li>Question: 对目标的一般陈述就足以开始编程，我们可以今后再补充细节<br />Answer: 前期糟糕的项目需求定义，是导致软件失败的主要原因。项目需求的确在不断变化,但<strong>变化所产生的影响是根据变化提出的时间不同而不同的</strong></li><li>Question: 一旦我们编程完毕并成功运行，我们的工作就结束了<br />Answer: 越早开始写代码，我们就会花费越长的时间去完成它。工业数据显示，<strong>软件开发60%-80%的精力将耗费在软件首次提交给用户以后</strong></li><li>Question: 当我的程序运行之前，我没有办法评估它的质量<br />Answer: 一个最有效的<strong>软件质量保证机制应当在项目的正式开始启动时</strong>——可以通过技术报告体现</li><li>Question: 唯一可交付的工作成果是一个成功运行的项目程序<br />Answer: 一个可运行的程序<strong>只是软件结构的一部分</strong>，它还包含了许多其它因素<strong>比如开发文档、使用文档等</strong></li><li>Question: 软件工程将会让我们去创建大量不必要的文档，并且总是使我们的进度放慢。软件工程仅仅是文档而已<br />Answer: <strong>所有的文档都是提高团队沟通和质量所必须的</strong></li></ol><h2 id="软件过程"><a class="markdownIt-Anchor" href="#软件过程"></a> 软件过程</h2><p>由软件工程出现的原因可以知道:</p><ul><li>软件工程的<strong>中心</strong>: <strong>质量</strong></li></ul><p>实现软件工程的<strong>三要素</strong>:</p><ul><li><strong>过程</strong></li><li><strong>方法</strong></li><li><strong>工具</strong></li></ul><p>本章节即详细讲述软件工程的要素之一: 过程</p><h3 id="软件过程的概念"><a class="markdownIt-Anchor" href="#软件过程的概念"></a> 软件过程的概念</h3><p>软件过程是指开发和维护软件及其相关产品所涉及的一系列<strong>活动</strong></p><p><strong>术语解读:</strong></p><ul><li><strong>任务: 将输入转化为输出的操作</strong></li><li><strong>活动: 一系列任务的集合</strong></li><li><strong>过程: 不同的活动按一定顺序排列的集合</strong></li></ul><p><img src="process.png" alt="软件过程" /></p><h3 id="基本软件过程"><a class="markdownIt-Anchor" href="#基本软件过程"></a> 基本软件过程</h3><p>软件过程多样，但所有过程都具有以下共同活动:</p><ol><li><strong>沟通</strong>: 包括软件设计者与客户沟通，客户提出要求，软件设计者收集材料，以及其它相关活动</li><li><strong>计划</strong>: 软件开发小组讨论使用何种方法及何种工具来实现客户需求</li><li><strong>建模</strong>: 软件开发小组根据需求讨论选择何种模型来满足需求</li><li><strong>构造</strong>: 编码和测试</li><li><strong>部署</strong>: 软件交付给客户，客户给出建议和反馈，软件实施小组改进软件</li></ol><p>一个典型的基本软件过程:</p><pre><code class="mermaid" >graph LR    RA("需求分析")-->SD("软件设计")    SD-->SC("软件编码")    SC-->ST("软件测试")</code></pre><ul><li>需求分析: 解决现实世界某个问题的软件产品及其约束的描述，要求<strong>输出编制软件需求说明书或初步的系统用户手册</strong></li><li>软件设计: 分为<strong>概要设计</strong>和<strong>详细设计</strong>两个活动，要求<strong>输出概要设计说明书与详细设计说明书</strong><ul><li>概要设计: <strong>把各项需求转换成软件的体系结构</strong>，结构中每个部分都是一个模块，每个模块都与某些需求相对应</li><li>详细设计: <strong>对每个模块要完成的工作进行具体描述</strong>，为源程序编写打下基础</li></ul></li><li>软件编码: 将软件设计转换成结构良好、清晰易读，且与设计相一致的计算机可以运行的<strong>程序代码</strong>，要求<strong>提交源程序清单与可执行程序模块</strong></li><li>软件测试: 通过测试来判断一个软件是否满足规定的功能和性能要求，发现软件所存在的问题，避免出现缺陷导致事故，分为<strong>单元测试</strong>和<strong>组装测试</strong>，要求<strong>提交软件评测报告</strong><ul><li>单元测试: 检测<strong>各模块</strong>在功能和结构上存在的问题并加以纠正</li><li>组装测试: 将已测试通过的模块<strong>按一定顺序组装起来</strong>，<strong>按规定的各项需求，逐项进行有效性测试</strong>，决定已开发的软件是否合格，能否交付给用户使用</li></ul></li></ul><h3 id="软件过程模型"><a class="markdownIt-Anchor" href="#软件过程模型"></a> 软件过程模型</h3><p>定义: 是软件开发<strong>全部过程、活动和任务的结构框架</strong>。<strong>它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略</strong>。</p><p>常见过程模型主要为3类:</p><ul><li>瀑布模型:</li><li>演化模型</li><li>增量过程模型</li></ul><h4 id="瀑布模型"><a class="markdownIt-Anchor" href="#瀑布模型"></a> 瀑布模型</h4><p>瀑布模型的<strong>开发过程与软件生命周期是一致的</strong>，也称经典的生命周期模型。其规定了各项软件工程活动，以及它们<strong>自上而下，相互衔接的固定次序</strong>，如同瀑布流水，逐级下落。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="Waterfall_Model1.jpg" alt="传统瀑布模型" /></div><div class="group-image-wrap"><img src="Waterfall_Model2.jpg" alt="迭代瀑布模型" /></div></div></div><p>瀑布模型的<strong>特点</strong>:</p><ul><li>阶段间具有<strong>顺序性</strong>和<strong>依赖性</strong>，过程<strong>透明性高</strong>，过程<strong>可管理性高</strong></li><li><strong>推迟实现</strong>的观点: 软件实现前必须进行系统分析和设计工作</li><li><strong>质量保证</strong>的观点<ul><li>每个阶段<strong>必须完成规定的文档</strong>，没有交出合格的文档就是没有完成该阶段的任务；</li><li>每个阶段<strong>结束前</strong>都要对所完成的文档进行<strong>评审</strong>，以便尽早发现问题，改正错误；</li></ul></li></ul><p>瀑布模型的<strong>缺点</strong>:</p><ul><li>不够灵活(需求不明确时难以调整)</li><li>整体性太强(风险高)</li><li>严格的文档驱动，比较繁琐</li></ul><p>瀑布模型适用的场景: 系统<strong>需求明确</strong>、<strong>技术成熟</strong>、<strong>工程管理较严格</strong></p><h4 id="演化模型"><a class="markdownIt-Anchor" href="#演化模型"></a> 演化模型</h4><p>由于<strong>准确的需求很难一次获得</strong>、<strong>软件很难一次开发成功</strong>的事实，瀑布模型并不能适用于大部分场景，因此产生了<strong>演化模型</strong>。<br />演化模型的基本思想为: 倡导<strong>多次迭代开发</strong>，前期得到实验性的<strong>原型产品</strong>，探索可行性，理清需求，后期再前期基础上<strong>优化完善</strong>得到满意的产品</p><p>演化模型中可将常见的分为3类:</p><ul><li><strong>快速原型模型</strong></li><li><strong>并行开发模型</strong></li><li><strong>基于构件模型</strong></li></ul><p>本节以<strong>快速原型模型</strong>作为主要内容进行介绍。</p><p>快速原型模型作为演化模型的一种，其生命周期与瀑布模型自然有所不同，由于演化模型的思想在于<strong>多次迭代开发</strong>，因此<strong>快速原型模型的生命周期是一个循环周期</strong>，由某种条件控制循环的结束。<br /><img src="prototype.jfif" alt="快速原型模型" /></p><p>快速原型模型的<strong>优点</strong>:</p><ul><li><strong>强调用户参与和决策</strong>，强化了用户与开发人员的沟通</li><li>可<strong>加快需求的确定</strong>，能够处理需求的不确定性和风险</li><li><strong>简化了项目管理</strong>、<strong>缩短了开发时间</strong>、<strong>降低了风险和开发成本</strong></li></ul><p>快速原型模型的<strong>缺点</strong>:</p><ul><li><strong>不适用于开发大型系统</strong></li><li>软件<strong>可维护性差</strong></li><li><strong>用户合作要求高</strong>，如果合作不好，反而会拖延开发进度</li></ul><p>快速原型模型适用的场景:</p><ul><li><strong>客户或领域专家不熟悉电脑/软件</strong></li><li><strong>需求、技术不明确</strong></li><li><strong>软件人员不熟悉领域,沟通理解困难</strong></li></ul><h4 id="增量过程模型"><a class="markdownIt-Anchor" href="#增量过程模型"></a> 增量过程模型</h4><p>增量过程模型是一种<strong>非整体开发</strong>的模型、<strong>进化式的开发过程</strong>，其允许从<strong>部分需求定义</strong>出发，先建立一个<strong>不完整的系统</strong>，通过测试运行取得经验和反馈，然后进一步<strong>扩充和完善</strong>该系统。反复进行，直至软件人员和用户满意为止。</p><p><strong>演化模型与增量过程模型的异同</strong>:<br />演化模型和增量过程模型都是进行<strong>多次开发</strong>，而瀑布模型是<strong>一次开发</strong>即可完成系统，但演化模型与增量过程模型<strong>不同之处</strong>在于演化模型根据原型每次的开发结果是一个<strong>整系统</strong>，而增量过程模型的阶段开发结果可以是<strong>不完整系统</strong>。</p><p>本节通过<strong>增量模型</strong>和<strong>螺旋模型</strong>来对增量过程模型进行介绍。</p><p><strong>增量模型</strong><br />增量模型结合了<strong>原型模型的基本要素和迭代的特征</strong>，采用了<strong>基于时间的线性序列</strong>，每个确定线性序列都会输出该软件的一个<strong>增量</strong>，每个增量都是小而可用的软件<br /><img src="incremental.png" alt="增量模型" /></p><p>增量模型的<strong>特点</strong>:</p><ul><li>在前面增量的基础上开发后面的增量</li><li>每个增量的开发可用瀑布或快速原型模型</li><li>迭代的思路</li></ul><p>增量模型的<strong>优点</strong>:</p><ul><li>引入增量包概念，<strong>不需要提供完整的需求</strong>。只要有一个增量包出现，开发就可以进行</li><li>在项目的初始阶段<strong>不需要投入太多的人力资源</strong></li><li>增量可以<strong>有效地管理技术风险</strong>，<strong>降低系统失败风险</strong></li><li>有利于增加客户信心，<strong>提高系统可靠性、可维护性和稳定性</strong></li></ul><p>增量模型的<strong>缺点</strong>:</p><ul><li><strong>增量粒度难以选择</strong>，因为每个增量必须提供一些系统功能</li><li>确定所有的基本业务比较困难</li></ul><p>增量模型适用的场景:</p><ul><li><strong>需求比较明确</strong></li><li><strong>架构比较稳定</strong>，每次增量不影响架构</li></ul><p><strong>螺旋模型</strong><br />螺旋模型<strong>结合了瀑布模型</strong>和<strong>原型模型</strong>的特点，并且<strong>强调风险管理</strong><br /><img src="spiral.png" alt="螺旋模型" /><br />螺旋模型沿着螺线旋转，在笛卡尔坐标的四个象限上分别表达了四个方面的活动:</p><ul><li>制定计划: <strong>确定软件目标</strong>，选定实施方案，弄清项目开发的限制条件</li><li>风险分析: <strong>分析所选方案风险</strong>，考虑如何识别和消除风险</li><li>实施工程: 实施<strong>软件开发</strong></li><li>客户评估: <strong>评价开发工作，提出修正建议</strong></li></ul><p>螺旋模型的<strong>优点</strong>:</p><ul><li>支持<strong>用户需求的动态变化</strong></li><li><strong>原型可看作可执行的需求规格说明书</strong></li><li>强调<strong>原型的可扩充性和可修改性</strong></li><li>为项目管理人员及时调整管理决策提供了方便，进而可<strong>降低开发风险</strong></li></ul><p>螺旋模型的<strong>缺点</strong>:</p><ul><li>如果每次<strong>迭代的效率不高</strong>，致使迭代次数过多，将会<strong>增加成本并推迟提交时间</strong></li><li>要求<strong>开发队伍水平较高</strong></li></ul><p>螺旋模型适用的场景:</p><ul><li><strong>需求不明确</strong></li><li><strong>大规模软件开发</strong></li><li><strong>高风险项目</strong></li></ul><h4 id="四种模型总结"><a class="markdownIt-Anchor" href="#四种模型总结"></a> 四种模型总结</h4><table style="border-collapse:collapse;border-color:#9ABAD9;border-spacing:0" class="tg"><thead><tr><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">模型</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">描述</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">优点</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">缺点</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">应用场景</th></tr></thead><tbody><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">瀑布模型<br>Waterfall Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">过程划为计划,需求,设计,编码,测试,维护阶段<br>各阶段自上而下,相互衔接固定次序,如同瀑布流水<br>各阶段评审确认通过,前阶段输出是后阶段输入<br><b>文档驱动(Document Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">利于大型软件项目中人员的组织与管理<br>利于开发方法工具的研究和使用<br>提高大型项目中的高发效率与质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">呈线性,成果未经测试时,用户看不到结果,增加风险<br>前阶段未发现的错误传到后阶段甚至扩散,可导致项目失败<br>需求阶段,完全确定需求比较困难</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">大型软件项目<br>需求明确<br>需求很少变更</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">快速原型模型<br>Rapid Prototype Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">快速建造初步非完整软件原型,实现客户与系统交互<br>客户对原型评价,细化需求<br>逐步调整原型满足要求,原型内部结构不重要<br><b>原型驱动(Prototype Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">确定客户真正需求,减少需求不明确<br>更好和客户沟通,提高客户对软件满意度<br>减少技术,应用风险,缩小成本,提高产品质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">需要尽可能尽快建造软件原型,可能会限制开发人员创新<br>所选技术工具不一定符合主流<br>原型快速建立的内部结构及连续修改可能致产品设计差<br>客户确定真正需求,原型可能被弃</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">客户或领域专家不熟悉电脑/软件<br>软件人员不熟悉领域,沟通理解困难<br></td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">增量模型<br>Incremental Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">分阶段实现,软件增量设计,实现,集成,测试<br>整个产品拆成多个构件,分次逐个构件交付可运行产品<br><b>功能驱动(Function Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">较好适应变化<br>客户看到不断变化软件,降低开发风险<br>鼓舞团队的士气</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">容易退化成边做边改,失去对软件过程的整体控制<br>不破坏现有架构<br>产品,架构不是开放的,维护难度加大</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">需求比较明确<br>架构比较稳定,每次增量不影响架构</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">螺旋模型<br>Spiral Model</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">分成计划,评估,设计实施,用户反馈四个象限<br>沿着螺线进行若干次迭代<br>关注风险,风险分析后决策项目是否继续<br><b>风险驱动(Risk Driven)</b></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">强调可选方案及约束条件支持软件重用<br>助于提升软件质量</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">要求客户接受相信其风险分析,并作出反应不容易<br>风险分析成本&gt;项目利润,项目风险分析无意义<br>要善于识别风险,且准确,否则将带来更大风险</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:left;vertical-align:top;word-break:normal">大规模软件开发<br>高风险项目</td></tr></tbody></table><p><strong>增量模型和螺旋模型的异同点</strong></p><ul><li>相同<ul><li>都是非整体的<strong>迭代式</strong>的开发方式</li></ul></li><li>不同<ul><li>两者迭代的层级不同<ul><li>增量：<strong>活动级</strong>的迭代</li><li>螺旋：<strong>过程级</strong>的迭代</li></ul></li><li>需求分析时间不同<ul><li>增量：先做总体需求分析和设计，在编码和测试<strong>逐个的增量包</strong>开发</li><li>螺旋：开发周期内采用<strong>瀑布模型</strong></li></ul></li><li>交互软件的不同<ul><li>增量：每次增量开发都在上一次增量的基础上提交<strong>新的一部分</strong>的软件</li><li>螺旋：每次迭代都提交一个<strong>新的完整</strong>的软件版本</li></ul></li><li>减少风险的方式不同<ul><li>增量：<strong>避免使用未成熟技术</strong>，和经常的客户反馈减少风险</li><li>螺旋：直接引入<strong>风险分析</strong></li></ul></li></ul></li></ul><h3 id="软件过程成熟度模型capatility-maturity-model"><a class="markdownIt-Anchor" href="#软件过程成熟度模型capatility-maturity-model"></a> 软件过程成熟度模型(Capatility Maturity Model)</h3><p><strong>软件过程成熟度模型</strong>是软件行业标准模型，<strong>用来定义和评价软件企业开发过程的成熟度</strong>，提供如何做才能提高软件质量的指导。<br />该模型可以说明一个特定的<strong>软件过程</strong>被显示地<strong>定义</strong>、<strong>管理</strong>、<strong>度量</strong>、<strong>控制</strong>和<strong>执行</strong>的程度，可用于指示企业加强其<strong>软件过程能力</strong>的潜力<br />CMM分为<strong>5个</strong>层级，分别为:</p><ul><li><strong>初始级: 有能力的人和个人英雄主义</strong></li><li><strong>可重复级: 基本项目管理</strong></li><li><strong>已定义级: 过程标准化</strong></li><li><strong>量化管理级: 量化管理</strong></li><li><strong>优化级: 持续的过程改进</strong></li></ul><p><img src="CMM.png" alt="软件过程成熟度模型" /></p><h3 id="过程与产品关系"><a class="markdownIt-Anchor" href="#过程与产品关系"></a> 过程与产品关系</h3><p>软件开发中有两种倾向:</p><ul><li><strong>以产品为中心</strong>，主要关心最终产品</li><li><strong>以过程为中心</strong>，强调软件过程的重要性(<strong>软件工程强调该倾向</strong>)</li></ul><p>一般来说，软件过程决定了软件产品的质量，不同的项目需要不同的过程模型或模型的组合。</p><h2 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h2><h3 id="需求的定义"><a class="markdownIt-Anchor" href="#需求的定义"></a> 需求的定义</h3><ul><li>软件需求表达了对解决现实世界中某类问题的产品的<strong>要求</strong>和<strong>约束</strong></li><li>确定<strong>系统必须具有的功能和性能</strong>，系统要求的<strong>运行环境</strong>，并且预测系统发展的前景</li><li>需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的<strong>陈述的一个集合</strong></li></ul><h3 id="需求的特性"><a class="markdownIt-Anchor" href="#需求的特性"></a> 需求的特性</h3><ul><li>可验证性: <strong>需求是测试的依据</strong>，因此需求必须具有可以被验证的性质</li><li>可量化性: <strong>需求的表述应该是量化的</strong>，如&quot;软件应该对用户是友好的&quot;即是不可量化的表述，而&quot;在任何营业时间内出现一个致命错误的可能性低于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>8</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1\times 10^{-8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>&quot;则是量化的表述</li><li>优先级: 需求应当根据紧迫程度和现有资源确定<strong>优先级</strong></li></ul><h3 id="需求的分类"><a class="markdownIt-Anchor" href="#需求的分类"></a> 需求的分类</h3><p>需求可以分为<strong>功能性需求</strong>和<strong>非功能性需求</strong>两种</p><ul><li>功能性需求: <strong>描述系统应该做什么</strong>，即为用户和其它系统完成的功能、提供的服务，如<strong>输入</strong>、<strong>输出</strong>、<strong>计算</strong>、<strong>数据存储</strong>等</li><li>非功能性需求: 指解决问题时的<strong>约束</strong>，按约束类型不同可以细分为: <strong>可靠性需求</strong>、<strong>可用性需求</strong>、<strong>性能需求</strong>、<strong>可维护性需求</strong><ul><li>可靠性: 如&quot;机场雷达系统一个月内不能出现2次以上故障&quot;</li><li>可用性: 如&quot;系统出错后可以允许的最大恢复时间&quot;</li><li>性能: 如&quot;应力分析程序必须在一分种内生成任何一个梁的应力报告&quot;</li><li>可维护性: 如&quot;有健全程序的文档&quot;</li></ul></li></ul><h3 id="需求分析过程"><a class="markdownIt-Anchor" href="#需求分析过程"></a> 需求分析过程</h3><p>完整的需求分析过程分为4个步骤:</p><ul><li>需求获取: <strong>收集需求</strong></li><li>需求分析(<strong>也名需求提炼</strong>): <strong>根据需求产生操作规格参数表</strong>，指明与其他系统元件的<strong>软件接口</strong>，确定软件必须遵循的<strong>约束</strong></li><li>需求描述(<strong>也名需求定义</strong>): 撰写需求规格说明书</li><li>需求验证: <strong>检查需求的正确性、完整性、非二义性、内部和外部的连贯性</strong></li></ul><h4 id="需求获取"><a class="markdownIt-Anchor" href="#需求获取"></a> 需求获取</h4><p><strong>需求获取的任务</strong></p><ul><li><strong>发现和分析问题</strong>，并分析问题的原因/结果关系</li><li>与用户进行各种方式的交流，并使用调查研究方法<strong>收集信息</strong></li><li>按照三个成分(即<strong>数据</strong>、<strong>过程</strong>和<strong>接口</strong>)观察问题的不同侧面</li><li>将获取的需求<strong>文档化(用例、决策表、决策树)</strong></li></ul><p><strong>需求获取的方法</strong></p><ul><li>采访: 获取需求的传统手段</li><li>设定情景: 通过<strong>用例图</strong>来设置情景从而获得需求</li><li>原型: 通过<strong>原型</strong>来表示不明确的需求，可将原型视为可执行的需求说明书</li><li>会议: 通过讨论提出更多更全面的多角度需求</li></ul><h4 id="需求分析-2"><a class="markdownIt-Anchor" href="#需求分析-2"></a> 需求分析</h4><p>定义: 对应用问题及环境的<strong>理解和分析</strong>，为问题涉及的信息、功能及系统行为<strong>建立模型</strong>，将用户需求精确化、完全化</p><p>需求分析采用多种形式描述需求，通过<strong>建立需求的多种视图</strong>，揭示出一些更深的问题，并且需要<strong>产生操作规格参数表</strong>，<strong>指明与其他系统元件的软件接口</strong>，确定软件必须遵循的<strong>约束</strong></p><p><strong>需求分析的方法</strong><br />主要有<strong>2种</strong>方法:</p><ul><li><strong>结构化分析模型</strong></li><li><strong>面向对象分析模型</strong></li></ul><p><span style="color:#ff562b"><b>这两种方法是需求分析中最需要掌握的模型！</b></span></p><h5 id="结构化分析模型"><a class="markdownIt-Anchor" href="#结构化分析模型"></a> 结构化分析模型</h5><p>结构化分析可以<strong>分析商业的需求</strong>，<strong>再转换为规格文件</strong>，最后再产生电脑软件、硬件配置及相关的手册及程序。<br /><strong>结构化思维</strong>是软件工程学科中一种典型的<strong>分析系统</strong>、<strong>设计系统</strong>的思维方法，采用<strong>系统科学</strong>思想、依据<strong>层次分解</strong>、 <strong>自顶向下</strong>分析和设计系统</p><p><img src="Structured_Analysis.png" alt="结构化分析模型" /><br />该模型<strong>以数据字典为核心</strong>，通过分别进行<strong>功能建模</strong>、<strong>数据建模</strong>和<strong>行为建模</strong>从而对需求进行分析。</p><ul><li><p><strong>功能建模</strong>: 通过<strong>多层数据流图</strong>来反应系统的数据流通情况<br />首先说明数据流图的基本图形符号:<br /><img src="dfd.png" alt="数据流图基本图形符号" /><br /><img src="data_flow.png" alt="多个数据流之间的关系" /><br />其中多个数据流之间的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>代表要求<strong>同时出现多个输入或输出</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊕</span></span></span></span>代表<strong>必须且只能出现一个输入或输出</strong><br />结构化分析策略是<strong>自顶向下逐步求精</strong>，因此数据流图有多层结构:<br /><img src="data_flow_structure.gif" alt="多层数据流" /></p><ol><li><strong>顶层数据流图(0层数据流图/环境图): 仅包括一个数据处理过程，也就是要开发的目标系统</strong>，其<strong>作用</strong>在于用是<strong>确定系统在其环境中的位置</strong>，通过确定系统的输入和输出与外部实体的关系<strong>确定其边界</strong></li></ol><p><img src="top_data_flow.png" alt="顶层数据流图" /><br />2. <strong>下层数据流图(1层、2层···)</strong>: 对系统中不同功能模块的具体数据流方向进行描述，描述方法与顶层数据流相同</p><p><img src="data_flow_example.png" alt="数据流图实例" /></p></li><li><p><strong>数据建模</strong>: 在结构化分析方法中，使用<strong>实体—关系建模技术来建立数据模型</strong>，通过<strong>实体—关系图</strong>进行可视化<br />实体—关系图仅<strong>包含3种相互关联的元素</strong>: <strong>数据对象(实体)</strong>、<strong>描述数据对象的属性</strong>及<strong>数据对象(实体)彼此间相互连接的关系</strong></p><ol><li><p><strong>数据对象(实体)</strong>: 可以是外部实体、事物、角色、行为或事件、组织单位、地点或结构等</p></li><li><p><strong>属性</strong>: 数据对象的特征，在ER图中用<strong>椭圆或圆角矩形</strong>表示，并用<strong>无向边</strong>将属性与相关的数据对象连接在一起<br /><img src="ER_attribute.png" alt="实体的属性表示" /></p></li><li><p><strong>关系</strong>: 说明两个实体之间的关系，在ER图上用<strong>无向边</strong>表示，同时在无向边的两端<strong>应标识出关联实例的数量</strong>，也称为关联的重数<br /><img src="ER_relationship.png" alt="不同重数的表示" /><br /><strong>关系本身也可能有属性</strong>，这在多对多的关系中尤其常见，在表示关系的无向边上<strong>再加一个菱形框，并在菱形框中标明关系的名字</strong><br /><img src="ER_relationship_attribute.png" alt="关系的属性表示" /></p></li></ol></li><li><p><strong>行为建模</strong>: 行为建模通过<strong>描绘系统的状态及引起系统状态转换的事件</strong>，来表示系统的行为，通过<strong>状态转换图</strong>来可视化<br /><img src="std.png" alt="状态转换图基本图形符号" /></p><ol><li><strong>状态</strong>: <strong>状态是任何可以被观察到的系统行为模式</strong>，一个状态代表系统的一种行为模式，状态规定了系统对事件的响应方式，状态可能有: <strong>初态(初始状态)</strong>、<strong>终态(最终状态)<strong>和</strong>中间态</strong>三种可选值，<strong>在一张状态图中只能有一个初态，而终态则可以有多个，也可以没有</strong></li><li><strong>事件</strong>: 事件是在某个特定时刻发生的事情，它是<strong>对引起系统做动作或从一个状态转换到另一个状态的外部事件的抽象</strong><br /><strong>事件表达式: 事件说明(守卫条件)/动作表达式</strong></li></ol><ul><li><strong>事件说明</strong>: <strong>事件名(参数表)</strong></li><li><strong>守卫条件</strong>: <strong>布尔表达式</strong>(如果同时使用守卫条件和事件说明，则当且仅当事件发生且布尔表达式成立时，状态转换才发生。如果只有守卫条件没有事件说明，则只要守卫条件为真，状态转换就发生)</li><li><strong>动作表达式</strong>: 是一个过程表达式，当状态转换开始时执行该表达式</li></ul><p><img src="std_example.png" alt="状态转换图实例" /></p></li></ul><h5 id="面向对象分析模型"><a class="markdownIt-Anchor" href="#面向对象分析模型"></a> 面向对象分析模型</h5><p>结构化分析方法的基本点是<strong>面向过程</strong>，<strong>系统被分解成若干个过程</strong>。而<strong>面向对象的方法是采用构造模型的观点</strong>，在系统的开发过程中，各个步骤的共同的目标是建造一个问题域的模型。在面向对象的设计中，<strong>初始元素是对象，然后将具有共同特征的对象归纳成类，组织类之间的等级关系</strong>，构造类库。在应用时，在类库中选择相应的类</p><p>面向对象的建模语言很多，目前使用最广泛的是<strong>统一建模语言</strong>(Unified Modeling Language, <strong>UML</strong>)，本节也以UML作为面向对象分析的基本模型</p><p><img src="UML.png" alt="UML模型" /></p><ul><li><strong>事物(Things)</strong>: UML模型中最基本的构成元素，是具有代表性的成分的<strong>抽象</strong></li><li><strong>关系(Relationships)</strong>: 关系<strong>把事物紧密联系在一起</strong></li><li><strong>图(Diagrams)</strong>: 是<strong>事物和关系的可视化表示</strong></li></ul><p>对于简单的系统，可以将OOA(Object-Oriented Analysis)划分为三个模型:</p><ul><li><p>用例模型: 是对功能进行建模得到的<strong>功能模型</strong>，<strong>对应图为用例图</strong></p></li><li><p>对象模型: 用类和对象表示的<strong>静态模型</strong>，<strong>对应图为类图</strong></p></li><li><p>动态模型: 表示交互行为的<strong>交互模型</strong>，<strong>对应图为状态图和交互图</strong></p></li><li><p><strong>用例模型</strong>: 在UML中，用例模型通过<strong>若干个用例图</strong>来进行描述<br />用例图: 主要元素为<strong>用例</strong>、<strong>参与者</strong>、<strong>用例与参与者之间的关系</strong><br />建立用例模型的过程:</p><ol><li>确定业务<strong>参与者</strong></li><li>确定业务<strong>用例</strong></li><li>标识<strong>关系</strong></li><li>书写<strong>用例规格说明</strong></li></ol><ul><li><p><strong>用例</strong>: <strong>系统执行的一系列动作(可以理解为系统的一个功能)</strong>，动作结果能被参与者察觉到</p></li><li><p><strong>参与者</strong>: 与系统交互的人或物，它代表<strong>外部实体</strong></p></li><li><p><strong>关系</strong>: 包括三种关系:</p><ol><li><strong>用例与参与者</strong>的关系: <strong>关联</strong>关系</li><li><strong>用例与用例</strong>的关系: <strong>泛化</strong>、<strong>包含</strong>、<strong>扩展</strong>关系</li><li><strong>参与者与参与者</strong>的关系: <strong>泛化</strong>关系</li></ol><ul><li><strong>关联</strong>关系: <strong>表示参与者与用例之间的通信</strong>，使用<strong>无箭头的实线</strong>表示</li><li><strong>泛化</strong>关系: 即<strong>继承关系</strong>，父类为父用例，子类为子用例，使用<strong>箭头指向父用例的实线</strong>表示</li><li><strong>包含</strong>关系: <strong>复杂用例与其分解出的小用例的关系</strong>，使用<strong>箭头指向被包含用例的虚线</strong>表示</li><li><strong>扩展</strong>关系: 是用例功能的延伸，相当于<strong>为基础用例提供一个附加功能</strong>，使用<strong>箭头指向基础用例的虚线</strong>表示</li></ul></li></ul></li></ul><p><img src="use_case_example.png" alt="用例图实例" /></p><ul><li><strong>对象模型</strong>: 对象建模的主要任务是<strong>建立问题域的概念模型</strong>，这个模型描述了现实世界中的&quot;类与对象&quot;以及它们之间的关系，而非实际的软件类或实际构件<br />对象模型<strong>共有5个层次</strong>:<ul><li><strong>主题层</strong></li><li><strong>类-对象层</strong></li><li><strong>结构层</strong></li><li><strong>属性层</strong></li><li><strong>服务层</strong><br />上述5个层次对应着建立对象模型的<strong>5项主要活动</strong>: <strong>识别主题</strong>、<strong>确定类与对象</strong>、<strong>定义关联</strong>、<strong>定义属性</strong>、<strong>定义服务</strong>。在实际建模中，这5项工作完全没有必要顺序完成，也无需彻底完成一项工作后再开始另外一项工作</li></ul><ol><li><strong>识别主题</strong>: 在开发大型、复杂系统的过程中，<strong>为了降低复杂程度</strong>，人们习惯于把系统再进一步划分成几个不同的主题，在UML中<strong>主题</strong>可以采用&quot;包&quot;来展现，<strong>对于很小的系统，可能根本无需引入主题层</strong></li><li><strong>确定类与对象</strong>: 类与对象是对问题域中有意义的事物的抽象，它们既<strong>可能是可见的物理实体</strong>，也<strong>可能是抽象的概念</strong>，因此首先列出<strong>候选</strong>的类与对象，再进行<strong>筛选</strong>、<strong>分类</strong>得到类与对象</li><li><strong>定义关联</strong>: 确定不同类与对象之间的关系(<strong>聚合、泛化、依赖、实现、组合等</strong>)</li><li><strong>定义属性</strong>: 确定每个类与对象应具有的属性</li><li><strong>定义服务</strong>: 确定每个类与对象应提供的方法</li></ol></li></ul><p><img src="class_diagram.gif" alt="类图实例" /></p><ul><li><strong>动态模型</strong>:  动态模型着重于<strong>系统的控制逻辑</strong>，<strong>考察在任何时候对象及其关系的改变</strong>，<strong>描述这些涉及时序和改变的状态</strong><br />在UML中动态模型的描述工具有<strong>交互图(包括顺序图、协作图)<strong>和</strong>状态图</strong><ul><li><p><strong>交互图</strong>: <strong>是用例的具体实现</strong>，其<strong>实现是以对象和对象间协作为基础的</strong></p><ul><li><strong>顺序图</strong>: 对象下面的<strong>垂直虚线</strong>是对象的<strong>生命线</strong>，对象间的<strong>通信</strong>用对象生命线之间的<strong>水平消息线</strong>表示</li></ul><p><img src="sequence_diagram_example.jpg" alt="顺序图实例" /></p><ul><li><strong>协作图</strong>: 协作图又称<strong>通信图</strong>，<strong>是顺序图的另一种表视图</strong>，<strong>以图或网格格式描述对象交互，其中对象可以置于图中任何位置</strong></li></ul><p><img src="collaboration_diagram_example.png" alt="协作图实例" /></p></li><li><p><strong>状态图</strong>: <strong>描述一个特定对象的所有可能的状态以及引起状态转换的事件</strong>，面向对象模型的状态图与<strong>结构化分析模型中行为建模形成的状态图相同</strong></p></li></ul></li></ul><h4 id="需求描述"><a class="markdownIt-Anchor" href="#需求描述"></a> 需求描述</h4><p>软件需求规格说明书(SRS)是<strong>对待开发系统的行为的完整描述</strong>，包含了描述用户与软件交互的<strong>用例的集合</strong>。用例通常描述功能性需求，除了用例之外，SRS还包含非功能性需求</p><p>需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书，其中<strong>需求描述步骤即是根据需求分析出的模型来撰写需求规格说明书的过程</strong>。</p><p><strong>需求规格说明的特征</strong></p><ul><li>应该只具有固定的、已知的和同意交付的系统的<strong>基本特征</strong></li><li>应该包含<strong>交付什么</strong></li><li>应该<strong>使用客户能理解的词汇</strong></li><li>应该是<strong>正确的</strong></li><li>应该是<strong>准确的</strong></li><li>应该是<strong>明确的</strong></li><li>应该是<strong>完整的</strong></li><li>应该是<strong>可验证的</strong></li><li>应该是<strong>能确认的</strong></li><li>应该是<strong>一致的</strong></li><li>应该是<strong>可更改的</strong></li><li>应该是<strong>可以追踪的</strong></li></ul><p><strong>需求规格说明的原则</strong></p><ul><li>从现实中分离功能(<strong>描述要&quot;做什么&quot;而不是&quot;怎样实现&quot;</strong>)</li><li>要求使用<strong>面向处理的规格说明语言</strong></li><li><strong>如果被开发软件只是一个大系统中的一个元素，那么整个大系统也包括在规格说明的描述之中</strong></li><li>规格说明必须包括<strong>系统运行环境</strong></li><li>规格说明必须是一个<strong>认识模型</strong></li><li>规格说明必须是<strong>可操作的</strong></li><li>规格说明必须<strong>容许不完备性并允许扩充</strong></li><li>规格说明必须<strong>局部化和松散耦合</strong></li></ul><p><strong>需求规格说明的内容</strong></p><ul><li><strong>功能性需求(核心部分)</strong></li><li><strong>非功能性需求(功能约束)</strong></li><li><strong>环境描述和系统目标</strong></li><li><strong>项目管理</strong></li><li><strong>生命周期需求</strong></li><li><strong>系统交付和安装说明</strong></li><li><strong>数据和传输协议需求</strong></li></ul><p><a href="https://personal.utdallas.edu/~chung/RE/IEEE830-1993.pdf">IEEE 830</a>为软件需求说明书定义了一种格式，仅作为<strong>参考</strong><br /><a href="https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=84C42B6277D2714B7176B10C6E6B1A44">GB/T 8567-2006</a>为中国《计算机软件文档编制规范》标准，其中涉及需求规格说明文档</p><h4 id="需求验证"><a class="markdownIt-Anchor" href="#需求验证"></a> 需求验证</h4><p>定义: 需求验证即检查需求的<strong>正确性</strong>、<strong>完整性</strong>、<strong>非二义性</strong>、<strong>内部和外部的连贯性</strong>。</p><p>需求文档需要验证，以表明它真实地定义了客户想要的系统，因此需求通常是同时从<strong>客户</strong>和<strong>开发人员</strong>的角度来进行检查的</p><ul><li>客户角度:<ul><li>有效性检查: 检查<strong>不同用户使用不同功能的有效性</strong></li><li>一致性检查: 在文档中，<strong>需求不应该冲突</strong></li><li>完备性检查: 需求文档应该<strong>包括所有用户想要的功能和约束</strong></li><li>现实性检查: 检查保证能<strong>利用现有技术实现需求</strong></li></ul></li><li>开发人员角度:<ul><li>可验证性: 需求<strong>可被验证的能力</strong></li><li>可理解性: 需求<strong>被理解的能力</strong></li><li>可追踪性: 有关每一个元件存在原因的说明(<strong>需求不变的概率</strong>)</li><li>适应性(修改性): 文档<strong>可被修改的程度</strong></li></ul></li></ul><p><strong>需求验证的方法</strong></p><ul><li>利用<strong>原型检验系统</strong>是否符合用户的真正需要</li><li>对每个需求编写概念性的<strong>测试用例</strong></li><li>编写用户手册</li><li>自动的一致性分析: 可用CASE工具检验需求模型的一致性</li></ul><h2 id="软件设计"><a class="markdownIt-Anchor" href="#软件设计"></a> 软件设计</h2><p>软件设计的定义: <strong>根据需求分析结果</strong>，生成<strong>如何构造软件的相关技术文档和模型的过程</strong>，其告诉了软件构造者具体的构造方法，即软件的<strong>架构、构件、接口和其他特性的定义过程及该过程的结果</strong></p><p>软件设计的<strong>方法</strong>主要有:</p><ul><li><strong>结构化设计</strong></li><li><strong>面向对象的设计</strong></li></ul><h3 id="软件设计的活动"><a class="markdownIt-Anchor" href="#软件设计的活动"></a> 软件设计的活动</h3><p>软件设计包含以下两类活动:</p><ul><li><strong>概要设计</strong>: 描述软件的<strong>顶层架构和组织</strong>，划分不同的组件，将软件需求转化为数据结构和软件的系统结构，需要完成<strong>数据设计</strong>、<strong>体系结构设计</strong>和<strong>接口设计</strong></li><li><strong>详细设计</strong>: 详细描述各组件以便能够编码实现，需要完成<strong>组件设计</strong></li></ul><p>由软件设计的活动来看，软件设计是一种<strong>分解设计</strong>，通过<strong>概要设计将软件划分为不同的组件模块</strong>，再通过<strong>详细设计对每个组件模块进行详细说明</strong>，因此<span style="color:#ff562b"><b>创新设计不属于软件设计过程，而是属于需求分析过程</b></span></p><p><img src="software_design.jpeg" alt="软件设计活动" /></p><h3 id="软件质量"><a class="markdownIt-Anchor" href="#软件质量"></a> 软件质量</h3><p>软件设计的目的是得到具有高质量的软件，因此软件质量的评估十分重要，而<strong>软件质量可以通过质量属性来描述</strong><br /><b></p><ul><li>功能性</li><li>易用性</li><li>可靠性</li><li>性能</li><li>可支持性:<ol><li>扩展性</li><li>适应性</li><li>可维护性</li></ol></li></ul></b><h3 id="软件设计技术"><a class="markdownIt-Anchor" href="#软件设计技术"></a> 软件设计技术</h3><p>共有<strong>7种</strong>技术需要理解和掌握:<br /><b></p><ul><li>抽象</li><li>细化</li><li>设计模式</li><li>模块化</li><li>信息隐藏</li><li>功能独立</li><li>重构</li></ul></b><h4 id="抽象"><a class="markdownIt-Anchor" href="#抽象"></a> 抽象</h4><p>定义: <strong>发现实物本质特征和方法的过程</strong><br />抽象方式: <strong>参数化</strong>和<strong>规范化</strong><br />抽象需要将<strong>过程抽象</strong>、<strong>数据抽象</strong>、<strong>控制抽象</strong></p><h4 id="细化"><a class="markdownIt-Anchor" href="#细化"></a> 细化</h4><p>定义: <strong>逐步求精的过程</strong><br />细化与抽象是对应关系，抽象将实体提取出概念，不关注细节，而细化需要对抽象出的概念进行细化分析来<strong>描述细节</strong>，<strong>在设计时更关注抽象，在实现时更注重细化</strong></p><h4 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h4><p>定义: 是对软件设计中普遍存在(反复出现)的各种问题，所提出的<strong>解决方案</strong><br /><a href="https://pan.baidu.com/s/1CAjfBDMuwOmyLYu_-FOI4g?pwd=aj94">《设计模式：可复用面向对象软件的基础》</a>中提出了<strong>23种设计模式</strong>，这23种设计模式可以分为三类:</p><ul><li><strong>创建型模式</strong></li><li><strong>结构型模式</strong></li><li><strong>行为型模式</strong></li></ul><p><img src="design_pattern.png" alt="23种设计模式" /></p><h4 id="模块化"><a class="markdownIt-Anchor" href="#模块化"></a> 模块化</h4><p>定义: 软件被划分为命名和功能相对独立的多个<strong>组件</strong>(<strong>通常称为模块</strong>)，通过这些组件的集成来满足问题的需求<br /><span style="color:#ff562b"><b>但是模块化不能无限划分模块！<br />因为随着模块数增加，单个模块的规模减小了，但是模块之间的关系复杂程度会增加，设计模块间接口的工作量也将增大</b></span><br /><img src="modular.png" alt="模块化和软件成本" /></p><p>模块化设计标准(<strong>模块化评价指标</strong>)如下:</p><ul><li>模块化<strong>分解性</strong>: 一个设计方法提供了分解成子问题的系统机制</li><li>模块化<strong>组合性</strong>: 一个设计方法能够使现有的(可重用的)组件组装成新系统</li><li>模块化<strong>可理解性</strong>: 一个模块可以作为一个独立单元使用</li><li>模块化<strong>连续性</strong>: 系统需求的小变化只引起单个模块变化，而不是整个系统范围内的改变</li><li>模块化<strong>保护</strong>: 模块内的异常情况只影响自身模块</li></ul><h4 id="信息隐藏"><a class="markdownIt-Anchor" href="#信息隐藏"></a> 信息隐藏</h4><p>信息隐藏原则: 模块应该具有彼此相互隐藏的特性(模块定义和设计时应当保证模块内的信息(过程和数据)<strong>不可以被不需要这些信息的其他模块访问</strong>)<br />意义:</p><ul><li>信息隐藏意味着<strong>有效的模块划分可以通过定义一些相对独立的模块来实现</strong></li><li>信息隐藏原则定义和<strong>隐藏了模块内的过程细节和模块内的本地数据结构</strong></li></ul><h4 id="功能独立"><a class="markdownIt-Anchor" href="#功能独立"></a> 功能独立</h4><p>定义: 每个模块<strong>只解决了需求中特定的子功能</strong>并从程序结构的其他部分看该<strong>模块具有简单的接口</strong><br />衡量标准: <strong>内聚性</strong>和<strong>耦合性</strong><br /><img src="cohesion.png" alt="内聚性" /><br /><img src="coupling.png" alt="耦合性" /></p><h4 id="重构"><a class="markdownIt-Anchor" href="#重构"></a> 重构</h4><p>定义: 不改变组件功能和行为条件下<strong>简化组件设计(或代码)<strong>的一种重组技术<br />重构时往往检查现有设计的</strong>冗余情况、未使用的设计元素、无效或不必要的算法、较差的构建方式或不恰当的数据结构</strong>，或<strong>任何其他可更改并导致更好设计的错误</strong></p><h3 id="数据设计"><a class="markdownIt-Anchor" href="#数据设计"></a> 数据设计</h3><p>数据设计构建高层抽象(客户/用户的数据视图)的<strong>数据模型</strong>、<strong>信息模型</strong>，数据设计在不同层级上有不同的设计方案:</p><ul><li>程序组件层面: 具体的程序需要使用一定的<strong>数据结构</strong>来对数据进行建模</li><li>程序应用层面: 应用层面需要使用<strong>数据库</strong>对数据模型进行描述</li><li>业务层面: <strong>不同数据库</strong>的信息进行收集并重组成<strong>数据仓库</strong>可以实现数据挖掘、知识发现</li></ul><h3 id="体系结构设计"><a class="markdownIt-Anchor" href="#体系结构设计"></a> 体系结构设计</h3><p>体系结构设计是指系统的一个或者多个<strong>结构</strong>，结构中包括软件的<strong>构件</strong>、<strong>构件的外部可见属性</strong>以及<strong>它们之间的相互关系</strong>，外部可见属性是指软件构件提供的<strong>服务</strong>、<strong>性能</strong>、<strong>使用特性</strong>、<strong>错误处理</strong>、<strong>共享资源使用</strong>等</p><p>体系结构设计有多种分类方式，其中最常见的有<strong>根据数据</strong>进行分类的、<strong>根据设备</strong>进行分类的</p><h4 id="根据数据分类的架构"><a class="markdownIt-Anchor" href="#根据数据分类的架构"></a> 根据数据分类的架构</h4><p>主要有<strong>5类</strong>:<br /><b></p><ul><li>数据中心架构</li><li>数据流架构</li><li>调用和返回架构</li><li>面向对象架构</li><li>层次架构</li></ul></b><h5 id="数据中心架构"><a class="markdownIt-Anchor" href="#数据中心架构"></a> 数据中心架构</h5><p>数据中心架构是<strong>以数据存储为整个系统的核心</strong>，其他组件对数据存储进行访问从而实现系统功能，其中各客户端操作的<strong>数据相互独立</strong><br /><img src="data_center.png" alt="数据中心架构" /></p><h5 id="数据流架构"><a class="markdownIt-Anchor" href="#数据流架构"></a> 数据流架构</h5><p>适用于<strong>输入数据通过计算或组件转换为一系列输出数据</strong>，可分为<strong>管道和过滤器模式</strong>、<strong>批处理序列模式</strong>两类:</p><ul><li><strong>管道和过滤器模式</strong>: 管道和过滤器模式强调数据的<strong>连续组件的增量转换</strong>。在这种方法中，数据流由数据驱动，整个系统被分解为数据源，过滤器，管道和数据接收器的组件<ul><li><strong>过滤器</strong>: 过滤器<strong>转换输入数据流的数据，对其进行处理</strong>，并通过<strong>管道</strong>将变换的数据流写入下一个过滤器进行处理，它以增量模式工作，一旦数据通过连接的管道到达，它将开始工作</li><li>有源滤波器: 有源滤波器使连接的管道将数据<strong>拉入并推出</strong>已转换的数据</li><li>被动滤波器: 无源滤波器使连接的管道将数据<strong>推入并拉出</strong>数据</li></ul></li></ul><p><img src="passive_filter.jpg" alt="管道和过滤器模式" /></p><ul><li><strong>批处理序列模式</strong>: 批次顺序是一种经典的数据处理模型，其中数据转换子系统只有在其先前的子系统完全通过之后才能启动其进程</li></ul><p><img src="batch_sequential.jpg" alt="批处理序列模式" /></p><h5 id="调用和返回架构"><a class="markdownIt-Anchor" href="#调用和返回架构"></a> 调用和返回架构</h5><p>调用和返回框架是将系统分为多个层次，其中<strong>上层模块调用下层模块，不同层模块存在主从关系</strong><br /><span style="color:#ff562b"><b>这里说明几个概念:<br /><img src="design_struct.png" alt="结构图" /></p><ul><li>程序结构的深度: 程序结构的层次数称为结构的深度</li><li>程序结构的宽度: 层次结构中同一层模块的最大模块个数称为结构的宽度</li><li>扇入数: 一个模块被其他模块调用的次数</li><li>扇出数: 一个模块调用其他模块的次数<br /></b></span><br />如上图所示: 该程序的<strong>深度为5</strong>、<strong>宽度为7</strong>、<strong>M的扇入数为1、扇出数为4</strong></li></ul><h5 id="面向对象架构"><a class="markdownIt-Anchor" href="#面向对象架构"></a> 面向对象架构</h5><p><strong>构件是对象</strong>，对象是抽象数据类型的实例。在抽象数据类型中，<strong>数据的表示和它们的相应操作被封装起来</strong>，对象的行为体现在其接受和请求的动作。<strong>连接件即是对象间交互的方式，对象是通过函数和过程的调用来交互的</strong><br /><img src="OO.jpeg" alt="面向对象架构" /></p><ul><li><strong>完整性</strong>: 每个对象独立负责维护其本身的完整性，比主程序子程序的紧耦合方式，更容易实现应用体完整性。</li><li><strong>隐蔽性</strong>: 对象的表示对其他对象而言是隐蔽的，对象可以不影响它的客户就能改变其实现方法。</li></ul><h5 id="层次架构"><a class="markdownIt-Anchor" href="#层次架构"></a> 层次架构</h5><p><strong>每一层为上层提供服务，并作为下一层的客户，每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的内外层，因此允许每层用不同的方法实现，为软件复用提供了强大的支持</strong><br /><img src="hierarchy.png" alt="层次架构" /></p><h4 id="根据设备分类的架构"><a class="markdownIt-Anchor" href="#根据设备分类的架构"></a> 根据设备分类的架构</h4><p>可以分为集中式架构和分布式架构:<br /><b></p><ul><li>集中式架构: 单一主机作为服务提供机器</li><li>分布式架构:<ol><li>多处理器架构</li><li>C/S和B/S架构</li><li>分布式对象架构</li><li>代理</li></ol></li></ul></b><h5 id="cs架构"><a class="markdownIt-Anchor" href="#cs架构"></a> C/S架构</h5><p>在C/S(Client/Server)架构中，客户机可以通过远程调用来获取服务器提供的服务<br /><img src="two-layer_CS_architecture.png" alt="两层C/S架构" /><br />其中客户机可能有两种形态:</p><ul><li>瘦客户机模型：在瘦客户机模型中，<strong>数据管理部分和应用逻辑都在服务器上执行，客户机只负责表示部分</strong></li><li>胖客户机模型: <strong>服务器只负责对数据的管理</strong>，客户机上的软件实现应用逻辑和与系统用户的交互</li></ul><p><img src="three-layer_CS_architecture.png" alt="三层C/S架构" /><br />表示层: 表示层是应用系统的<strong>用户界面部分</strong>，担负着用户与应用程序之间的对话功能<br />应用逻辑层: 应用逻辑层为应用系统的主体部分，<strong>包含具体的业务处理逻辑</strong><br />数据层: 数据层主要包括<strong>数据的存储及对数据的操作</strong>，一般选择关系型数据库管理系统</p><h5 id="bs架构"><a class="markdownIt-Anchor" href="#bs架构"></a> B/S架构</h5><p>B/S(Browser/Server)架构，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。B/S 结构应用程序相对于传统的 C/S 结构应用程序是一个非常大的进步。B/S结构的主要优点是<strong>分布性强</strong>、<strong>维护方便</strong>、<strong>开发简单且共享性强</strong>、<strong>总体拥有成本低</strong>。<br />缺点: <strong>数据安全性问题</strong>、<strong>对服务器要求过高</strong>、<strong>数据传输速度慢</strong>、<strong>软件的个性化特点明显降低</strong>、<strong>难以实现传统模式下的特殊功能要求</strong><br /><img src="bs_architechtrue.webp" alt="B/S架构" /></p><h3 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h3><p>接口设计主要包括<strong>3个方面</strong>:</p><ul><li><strong>模块与模块</strong>之间的接口设计</li><li><strong>软件与其他软硬件</strong>之间的接口设计</li><li><strong>软件与人</strong>之间的接口设计</li></ul><p>这里主要介绍软件与人之间的接口设计，其中很重要的一部分是<strong>用户界面设计</strong><br />高效用户界面设计的<strong>3条重要原则</strong>:<br /><b></p><ul><li>用户控制系统(以用户为中心)</li><li>减少用户记忆</li><li>保存界面一致</li></ul></b><p>设计用户界面应当包括以下<strong>3种分析</strong>:</p><ul><li><strong>环境分析</strong>: 确定了<strong>用户接口操作的物理结构和社会结构</strong></li><li><strong>特性分析</strong>:<ul><li><strong>易使用性</strong>: 包括使用简单、界面一致、拥有HELP帮助功能、快速的系统响应、具有容错能力等</li><li><strong>灵活性</strong>: 考虑到用户的特点、能力和知识水平，应当使用户界面满足不同用户的要求</li><li><strong>可靠性</strong>: 用户界面应能保证用户正确、可靠地使用系统，并保证有关程序和数据的安全性</li></ul></li><li><strong>用户分析</strong>: 研究使用软件的用户:<ul><li><strong>外行型</strong>: 以前从未使用过计算机系统的用户</li><li><strong>初学型</strong>: 尽管对新的系统不熟悉，但对计算机还有一些使用经验的用户</li><li><strong>熟练型</strong>: 对一个系统有相当多的经验，能够熟练操作的用户</li><li><strong>专家型</strong>: 了解系统内部的构造，有关于系统工作机制的专业知识的用户</li></ul></li></ul><h3 id="组件设计"><a class="markdownIt-Anchor" href="#组件设计"></a> 组件设计</h3><p>定义: <strong>接近代码层次的软件抽象描述</strong>，包括了逐渐减少软件抽象层次的一系列任务</p><p>设计方法主要有两种:</p><ul><li><strong>结构化设计</strong>: 是一种<strong>基于过程设计</strong>的理念，其限制了算法表示细节的逻辑结构数量和类型</li><li><strong>面向对象设计</strong>: <strong>以类与对象设计为基础</strong>的设计方法，需要遵循<strong>开闭原则</strong>、<strong>依赖倒置原则</strong>、<strong>Liskov替换原则</strong>、<strong>接口隔离原则</strong>、<strong>内聚性原则等原则</strong></li></ul><h3 id="结构化设计模型"><a class="markdownIt-Anchor" href="#结构化设计模型"></a> 结构化设计模型</h3><p><span style="color:#ff562b"><b>这里采用结构化分析模型转换为结构化软件设计模型为例进行说明！</b></span><br /><img src="OOD.png" alt="结构化设计" /></p><h4 id="结构化设计的模块与数据"><a class="markdownIt-Anchor" href="#结构化设计的模块与数据"></a> 结构化设计的模块与数据</h4><h5 id="模块结构和表示"><a class="markdownIt-Anchor" href="#模块结构和表示"></a> 模块结构和表示</h5><p>一个软件系统通常由很多<strong>模块组成</strong>，结构化程序设计中的<strong>函数</strong>和<strong>子程序</strong>都可称为模块，它是程序语句<strong>按逻辑关系建立起来的组合体</strong><br />模块可以分为<strong>4种</strong>类型:</p><ul><li>传入模块</li><li>传出模块</li><li>变换模块</li><li>协调模块</li></ul><p><img src="modular_struct.png" alt="模块的两种表示" /></p><ul><li><strong>树状结构: 只有一个顶层模块，上层模块调用下层模块，同一层模块之间互不调用</strong></li><li><strong>网状结构: 任意两个模块之间都可以有调用关系</strong></li></ul><h5 id="数据结构和表示"><a class="markdownIt-Anchor" href="#数据结构和表示"></a> 数据结构和表示</h5><p>数据结构是数据的各个元素之间逻辑关系的一种表示，数据结构设计应确定<strong>数据的组织、存取方式、相关程度，以及信息的不同处理方法</strong><br />结构化设计中使用的数据结构即为常见的数据结构，如链表、向量、树、堆栈、图等，以及基本数据结构构建成的复杂数据结构</p><h4 id="结构化数据设计"><a class="markdownIt-Anchor" href="#结构化数据设计"></a> 结构化数据设计</h4><p>在结构化设计方法中，数据设计是将ER图中描述的对象和关系，以及数据字典中描述的详细数据内容转化为软件的数据结构定义(即软件涉及的<strong>文件系统的结构</strong>以及<strong>数据库的表结构</strong>)</p><p>对数据进行存储有两种方式:</p><ul><li>文件存储: 适合文件存储的情况:<ul><li><strong>数据量较大</strong>的<strong>非结构化数据</strong>，如多媒体信息</li><li><strong>数据量大</strong>，<strong>信息松散</strong>，如历史记录、档案文件等</li><li><strong>非关系层次化数据</strong>，如系统配置文件</li><li><strong>对数据的存取速度要求极高的情况</strong></li><li><strong>临时存放</strong>的数据</li></ul></li><li>数据库存储: 数据库可以分为<strong>网状数据库、层次数据库、关系数据库、面向对象数据库、文档数据库、多维数据库等</strong>，目前最常用且最适合结构化设计方法的仍旧是<strong>关系型数据库</strong></li></ul><h4 id="结构化架构设计"><a class="markdownIt-Anchor" href="#结构化架构设计"></a> 结构化架构设计</h4><p>在结构化设计方法中，软件的结构元素是模块，因此通常也称为<strong>模块设计</strong>，该设计表示<strong>可以从分析模型(如数据流图)导出</strong>，这种设计方法称为<strong>基于数据流方法的设计过程</strong></p><p>基于数据流的设计方法也称为<strong>过程驱动</strong>的设计方法，典型的数据流类型可以分为<strong>变换型</strong>和<strong>事务型</strong></p><p>大型的软件系统通常是变换型结构和事务型结构的<strong>混合结构</strong>，一般利用<strong>以变换分析为主，事务分析为辅</strong>的方式进行软件结构设计</p><h5 id="变换型映射方法"><a class="markdownIt-Anchor" href="#变换型映射方法"></a> 变换型映射方法</h5><p>变换数据流所体现出的是<strong>数据从输入到加工再到输出的一般步骤</strong><br /><img src="transform_flow.png" alt="变换流" /></p><p><strong>设计步骤</strong>:</p><ol><li><strong>重画数据流图</strong>: 重新描述系统中的数据是如何流动的</li><li>在数据流图上<strong>区分系统的逻辑输入、逻辑输出和中心变换部分</strong></li><li>进行<strong>一级分解</strong>，设计系统模块结构的顶层和第一层(<strong>自顶向下</strong>)</li><li>进行<strong>二级分解</strong>，<strong>逐层细化</strong>，直到不能细分或模块不宜再分解</li></ol><p>由变换数据流特性可以知道，<strong>变换型系统的结构图由输入、中心变换和输出3部分组成</strong><br /><img src="transform_flow_struct.png" alt="变换流结构图" /></p><h5 id="事务型映射方法"><a class="markdownIt-Anchor" href="#事务型映射方法"></a> 事务型映射方法</h5><p>通常<strong>接受一项事务，根据事务处理的特点和性质，选择分派一个适当的处理单元，然后给出结果</strong><br /><img src="transaction_flow.png" alt="事务流" /></p><p><strong>设计步骤</strong>:</p><ol><li><strong>识别事务源</strong>: 利用数据流图和数据词典，找出各种需要处理的事务</li><li><strong>规定适当的事务型结构</strong>: 根据模块划分理论，建立适当的事务型结构</li><li><strong>识别各种事务和它们定义的操作</strong></li><li><strong>利用公用模块</strong>: 不同事务的一些中间模块可以由类似的若干个下层模块组成，则可以把这些下层模块构造成公用模块</li><li><strong>建立事务处理模块</strong>: 对每种事务建立一个事务处理模块(<strong>由不同公有模块和每种事务的私有模块组合</strong>)</li><li>对事务处理模块<strong>规定它们全部的下层操作模块</strong></li><li>对操作模块<strong>规定它们的全部细节模块</strong></li></ol><p>由事务数据流特性可以知道，<strong>事务型系统的结构图由接受事务和事务活动2部分组成</strong><br /><img src="transaction_flow_struct.png" alt="事务流结构图" /></p><h5 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h5><p>银行储蓄系统的结构化设计:<br /><strong>第一步</strong>: 重画数据流图<br /><img src="./desgin_example/data_flow.png" alt="数据流图" /></p><p><strong>第二步</strong>: 确定数据流图具有变换特性还是事务特性——是<strong>事务型</strong></p><p><strong>第三步</strong>: 确定输入流和输出流的边界<br /><img src="./desgin_example/split.png" alt="划分边界" /></p><p><strong>第四步</strong>: 一级分解<br /><img src="./desgin_example/first_split.png" alt="一级分解" /></p><p><strong>第五步</strong>: 二级分解<br /><img src="./desgin_example/input.png" alt="输入二级分解" /><br /><img src="./desgin_example/output.png" alt="输出二级分解" /><br /><img src="./desgin_example/scheduling.png" alt="调度二级分解" /></p><p>直接合并得到<strong>初始架构</strong><br /><img src="./desgin_example/version1.png" alt="初始架构" /></p><p><strong>精化结构(调度模块合并到上级模块、调整控制范围)</strong><br /><img src="./desgin_example/version2.png" alt="精化架构" /></p><p><strong>提高模块独立性</strong><br /><img src="./desgin_example/version3.png" alt="精化架构" /></p><h4 id="结构化接口设计"><a class="markdownIt-Anchor" href="#结构化接口设计"></a> 结构化接口设计</h4><p>课程未介绍</p><h4 id="结构化组件设计"><a class="markdownIt-Anchor" href="#结构化组件设计"></a> 结构化组件设计</h4><p>组件设计属于详细设计中的内容，在结构化设计方法中，组件是<strong>面向过程</strong>的，因此结构化组件设计也叫<strong>过程设计</strong>，过程设计要<strong>决定各个模块的实现算法</strong>，并<strong>使用过程描述工具精确地描述这些算法</strong></p><p>描述工具有:</p><ul><li><strong>程序流程图</strong></li><li><strong>N-S图(盒图)</strong></li><li><strong>PAD图</strong></li><li><strong>伪代码</strong></li></ul><h5 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h5><p>程序流程图也称为<strong>程序框图</strong>，程序流程图使用<strong>5种基本控制结构</strong>，分别是:<br /><img src="flow_chart.png" alt="五种基本控制结构" /></p><p><img src="flow_chart_example.png" alt="示例" /></p><h5 id="n-s图"><a class="markdownIt-Anchor" href="#n-s图"></a> N-S图</h5><p>N-S图也叫做盒图，其五种基本控制结构由<strong>5种图形构件</strong>表示，分别是:<br /><img src="NS.png" alt="五种图形构件" /></p><p><img src="NS_example.png" alt="示例" /></p><h5 id="pad图"><a class="markdownIt-Anchor" href="#pad图"></a> PAD图</h5><p>PAD也设置了<strong>5种基本控制结构</strong>的图式，并允许递归使用。分别是:<br /><img src="PAD.png" alt="五种基本控制结构" /><br />此外，PAD还具有<strong>2种扩充控制结构</strong><br /><img src="PAD_extend.png" alt="扩充控制结构" /></p><p><img src="PAD_example.png" alt="示例" /></p><h5 id="伪代码"><a class="markdownIt-Anchor" href="#伪代码"></a> 伪代码</h5><p>伪代码，及程序设计语言，也称PDL(Program Design Language)<br />PDL是一种用于<strong>描述功能模块的算法设计和加工细节的语言</strong>，称为程序设计语言，它是一种伪码<br />伪码的语法规则分为<strong>外语法</strong>和<strong>内语法</strong><br />PDL具有严格的关键字外语法，用于定义控制结构和数据结构，同时它表示实际操作和条件的内语法时可使用自然语言的词汇。</p><p><strong>特点</strong>:</p><ul><li>为了区别关键字，规定关键字一律大写，其它单词一律小写。或者规定关键字加下划线，或者规定它们为黑体字。</li><li>固定的<strong>关键字外语法</strong>提供<strong>全部结构化控制结构、数据说明和模块特征</strong></li><li><strong>内语法</strong>使用自然语言来<strong>描述处理特性</strong>，内语法比较灵活，只要写清楚就可以，不必考虑语法错误，以利于人们可把主要精力放在描述算法的逻辑上。</li><li>有<strong>数据说明机制</strong>，包括简单的(如标量和数组)与复杂的(如链表和层次结构)的数据结构。</li><li>有<strong>子程序定义与调用机制</strong>，用以表达各种方式的接口说明</li></ul><h2 id="生产率和工作量度量"><a class="markdownIt-Anchor" href="#生产率和工作量度量"></a> 生产率和工作量度量</h2><p><strong>度量</strong>是一种<strong>量化衡量方法</strong>，使得人们可以理解和把握软件项目的<strong>生产效率</strong>和所需要的劳动量(<strong>工作量</strong>)</p><h3 id="生产率度量"><a class="markdownIt-Anchor" href="#生产率度量"></a> 生产率度量</h3><p><strong>工作量</strong>: 一人工作一个月为单位，记为<strong>人月</strong></p><p>生产率的度量方法:</p><ul><li><strong>基于LOC(Line Of Code)度量</strong>: 直接测量在一个特定时间内产生的<strong>代码行数(LOC)</strong>，其中LOC为可测量量</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">生</mi><mi mathvariant="normal">产</mi><mi mathvariant="normal">率</mi><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">人</mi><mi mathvariant="normal">月</mi></mrow><annotation encoding="application/x-tex">生产率 = LOC / 人月</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">产</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord cjk_fallback">人</span><span class="mord cjk_fallback">月</span></span></span></span></span></p><p><img src="LOC_example.png" alt="例题" /></p><table><thead><tr><th style="text-align:center">项目编号</th><th style="text-align:center">每KLOC的错误数</th><th style="text-align:center">每KLOC的缺陷数</th><th style="text-align:center">每KLOC的文档页数</th><th style="text-align:center">每KLOC的成本</th><th style="text-align:center">每人月代码行数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">11.6</td><td style="text-align:center">1.6</td><td style="text-align:center">46.5</td><td style="text-align:center">16363.6</td><td style="text-align:center">2750</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">11.1</td><td style="text-align:center">1.4</td><td style="text-align:center">44.5</td><td style="text-align:center">11304.3</td><td style="text-align:center">4600</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">9.5</td><td style="text-align:center">1.4</td><td style="text-align:center">62.3</td><td style="text-align:center">10606</td><td style="text-align:center">4125</td></tr></tbody></table><ul><li><strong>基于功能点(FP)度量</strong>: 一个给定时间内生产出的<strong>功能点和目标点</strong></li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">生</mi><mi mathvariant="normal">产</mi><mi mathvariant="normal">率</mi><mo>=</mo><mi>F</mi><mi>P</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">人</mi><mi mathvariant="normal">月</mi></mrow><annotation encoding="application/x-tex">生产率 = FP / 人月</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">生</span><span class="mord cjk_fallback">产</span><span class="mord cjk_fallback">率</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">/</span><span class="mord cjk_fallback">人</span><span class="mord cjk_fallback">月</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>0.65</mn><mo>+</mo><mn>0.01</mn><mo>×</mo><mo>∑</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FP = (total\_counts) \times (0.65 + 0.01 \times \sum F_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中total_count由<strong>功能数量乘以功能复杂性</strong>得到，对不同项目，<strong>功能复杂性表可能不同</strong><br /><img src="total_counts.webp" alt="total_counts计算" /><br />其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<strong>复杂度校正值</strong>，需回答14个问题来得到14个F的值，从而求和，其分别为:</p><ol><li>系统是否需要可靠的备份和恢复？</li><li>是否需要数据通信？</li><li>是否有分布处理的功能？</li><li>是否性能成为关键？</li><li>系统是否运行在现存的高度实用化的操作环境中？</li><li>系统是否需要联机数据项？</li><li>联机数据项是否需要建立多重窗口显示和操作，以处理输入处理？</li><li>主文件是否联机更新？</li><li>输入、输出、文件、查询是否复杂？</li><li>内部处理过程是否复杂？</li><li>程序代码是否可复用？</li><li>设计中是否包括了转移和安装？</li><li>系统是否设计成可以重复安装在不同机构中?</li><li>系统是否设计成易修改和易使用？</li></ol><table><thead><tr><th style="text-align:center">文字描述</th><th style="text-align:center">没有影响</th><th style="text-align:center">偶有影响</th><th style="text-align:center">轻微影响</th><th style="text-align:center">平均影响</th><th style="text-align:center">较大影响</th><th style="text-align:center">严重影响</th></tr></thead><tbody><tr><td style="text-align:center">Fi</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p><img src="FP_example.png" alt="例题" /><br /><b>(1)</b>已知该项目的复杂性调整值： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><msub><mi>F</mi><mn>2</mn></msub><mo>=</mo><msub><mi>F</mi><mn>3</mn></msub><mo>=</mo><msub><mi>F</mi><mn>4</mn></msub><mo>=</mo><msub><mi>F</mi><mn>5</mn></msub><mo>=</mo><msub><mi>F</mi><mn>6</mn></msub><mo>=</mo><msub><mi>F</mi><mn>7</mn></msub><mo>=</mo><msub><mi>F</mi><mn>8</mn></msub><mo>=</mo><msub><mi>F</mi><mn>9</mn></msub><mo>=</mo><msub><mi>F</mi><mn>10</mn></msub><mo>=</mo><mn>5</mn><mo separator="true">,</mo><msub><mi>F</mi><mn>11</mn></msub><mo>=</mo><msub><mi>F</mi><mn>12</mn></msub><mo>=</mo><msub><mi>F</mi><mn>13</mn></msub><mo>=</mo><msub><mi>F</mi><mn>14</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">F_1=F_2=F_3=F_4=F_5=F_6=F_7=F_8=F_9=F_{10}=5, F_{11}=F_{12}=F_{13}=F_{14}=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，计算该项目的功能点个数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>5</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>×</mo><mn>73</mn><mo>×</mo><mn>6</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>0.65</mn><mo>+</mo><mn>0.01</mn><mo stretchy="false">(</mo><mn>5</mn><mo>×</mo><mn>10</mn><mo>+</mo><mn>3</mn><mo>×</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>88.9</mn></mrow><annotation encoding="application/x-tex">FP = (4 \times 3 + 5 \times 4 + 3 \times 2 + 2 \times 7 3 \times 6) \times (0.65 + 0.01 (5 \times 10 + 3 \times 4)) = 88.9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mord">.</span><span class="mord">9</span></span></span></span></span></p><p><b>(2)</b>若该项目采用Pascal作为编程语言，其中Pascal实现单个功能点平均代码行数为90 LOC/FP，估算该项目的代码行数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">数</mi><mo>=</mo><mi>F</mi><mi>P</mi><mo>×</mo><mi>L</mi><mi>O</mi><mi>C</mi><mi mathvariant="normal">/</mi><mi>F</mi><mi>P</mi><mo>=</mo><mn>88.9</mn><mo>×</mo><mn>90</mn><mo>=</mo><mn>8001</mn></mrow><annotation encoding="application/x-tex">代码行数 = FP \times LOC/FP = 88.9 \times 90 = 8001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mord">8</span><span class="mord">.</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span></span></p><p>两种度量方法比较:</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">LOC</td><td style="text-align:center">LOC、KLOC和相关度量容易计算<br>许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入<br>有大量的关于LOC的文献和数据</td><td style="text-align:center">LOC依赖于使用的语言，这对短小精悍的程序不利<br>软件开发初期很难估算出最终软件的代码行数<br>不太适用于非过程化语言</td></tr><tr><td style="text-align:center">FP</td><td style="text-align:center">与程序设计语言无关 在开发前就可以估算出软件项目的规模</td><td style="text-align:center">没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统<br>功能点计算主要靠经验公式，主观因素比较多</td></tr></tbody></table><h3 id="工作量度量"><a class="markdownIt-Anchor" href="#工作量度量"></a> 工作量度量</h3><p>通过<strong>任务分解度量</strong>项目工作量<br /><img src="workload.png" alt="任务分解" /></p><h3 id="成本估算"><a class="markdownIt-Anchor" href="#成本估算"></a> 成本估算</h3><h4 id="分解技术"><a class="markdownIt-Anchor" href="#分解技术"></a> 分解技术</h4><p>分解技术有<strong>2种</strong>方法:</p><ul><li><strong>基于问题分解</strong>: 将问题分为不同的子模块，然后用<strong>基于LOC或基于FP方法进行工作量度量</strong></li><li><strong>基于过程分解</strong>: 将软件开发按<strong>开发过程</strong>进行分解，对<strong>每个过程</strong>进行成本估计</li></ul><h4 id="经验模型"><a class="markdownIt-Anchor" href="#经验模型"></a> 经验模型</h4><p><a href="https://blog.csdn.net/weixin_44803753/article/details/121610472">COCOMO模型</a></p><h2 id="软件测试"><a class="markdownIt-Anchor" href="#软件测试"></a> 软件测试</h2><p>软件测试定义:</p><ul><li>在<strong>特定的条件</strong>下对<strong>系统或组件进行观察或记录结果</strong>，<strong>对系统或组件的某些方面进行评估的过程</strong></li><li>分析软件各项目以检测现有的结果和应有结果之间的差异(即<strong>软件缺陷</strong>)，并评估软件各项目特征的过程</li></ul><p>软件缺陷的<strong>条件</strong>(<strong>满足任一即为缺陷</strong>):<br /><b></p><ul><li>未完成: 软件未实现产品说明书要求的功能</li><li>有错误: 软件出现了产品说明书指明不能出现的错误</li><li>画蛇添足: 软件实现了产品说明书未提到的功能</li><li>隐含需求未实现: 软件未实现产品说明书虽未明确提及但应该实现的目标</li><li>不好用: 软件难以理解、不易使用、运行缓慢</li></ul></b><h3 id="测试与质量保证"><a class="markdownIt-Anchor" href="#测试与质量保证"></a> 测试与质量保证</h3><p><strong>软件测试人员的目标</strong>: 尽早找出软件缺陷，并确保缺陷得以修复<br /><strong>软件质量保证人员(Software Quality Assurance)的主要职责</strong>: 创建和执行<strong>改进软件开发过程并防止软件缺陷发生</strong></p><p><span style="color:#ff562b"><b>因此，软件测试是软件开发过程中的一个环节，而质量保证则贯穿软件开发的全过程的</b></span><br />质量的评价标准:</p><ul><li>功能性(functionality)</li><li>可靠性(reliability)</li><li>可用性(usability)</li><li>效率(efficiency)</li><li>可维护性(maintainability)</li><li>可移植性(portability)</li></ul><h3 id="软件调试与测试"><a class="markdownIt-Anchor" href="#软件调试与测试"></a> 软件调试与测试</h3><div style="text-align:center;display:inline;margin: 0 auto;"><table style="border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:auto" class="tg"><thead><tr><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">相同点</th><th style="background-color:#2f4154;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">不同点</th></tr></thead><tbody><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">调试</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" rowspan="2"><br>都包含有处理软件缺陷和查看代码的过程<br></td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">目标是定位与修复缺陷</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">测试</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">目标是发现软件缺陷的存在</td></tr></tbody></table></div><h3 id="软件测试的目标-基本原则和评价准则"><a class="markdownIt-Anchor" href="#软件测试的目标-基本原则和评价准则"></a> 软件测试的目标、基本原则和评价准则</h3><h4 id="目标-2"><a class="markdownIt-Anchor" href="#目标-2"></a> 目标</h4><ul><li>确认系统<strong>满足其预期</strong>的使用和用户的需要</li><li>确认<strong>解决了所需解决的问题</strong></li><li>为测试的过程<strong>建立责任和可解释性</strong></li><li>便于<strong>及早发现</strong>软件和系统的<strong>异常</strong></li><li>及早提供软件和系统的<strong>性能评估</strong></li><li>为管理<strong>提供真实信息</strong>，<strong>评估风险</strong></li><li>鉴别出程序在功能等方面的<strong>异常集聚之处</strong></li></ul><h4 id="基本原则"><a class="markdownIt-Anchor" href="#基本原则"></a> 基本原则</h4><ul><li><strong>穷尽测试是不可能的</strong>: 因此测试需要选择</li><li>测试<strong>无法显示潜在的软件缺陷</strong>: 进行测试也不能保证没有错误</li><li>测试活动应<strong>尽早进行</strong>: 越早发现修改成本越低</li><li>软件缺陷具有<strong>群聚性</strong>: 一个问题出错导致多个错误现象出现</li><li>注意<strong>杀虫剂</strong>现象: 用<strong>一样的测试用例是不可取的</strong></li><li>应尽量由<strong>独立的测试团队进行测试</strong>: 自我测试效率低</li></ul><h4 id="评价准则"><a class="markdownIt-Anchor" href="#评价准则"></a> 评价准则</h4><ul><li><strong>覆盖率</strong>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><mrow><mi>s</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">test coverage = \frac{executed code}{source code}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，即测试用例运行时被执行的语句比上所有语句，覆盖率越高越好</li><li><strong>故障插入</strong>: 在测试前被<strong>有意地插入一些故障到程序中</strong>，发现率为被发现的故障数比上插入的故障数，发现率越高越好</li><li><strong>变异分值</strong>: 程序进行两个或更多个变异，然后用<strong>同样的测试用例执行测试</strong>，可以评估这些<strong>测试用例探测程序变异间差异的能力</strong></li></ul><h3 id="软件测试的方法"><a class="markdownIt-Anchor" href="#软件测试的方法"></a> 软件测试的方法</h3><p>主要可以分为3种方法:</p><ul><li>白盒测试</li><li>黑盒测试</li><li>灰盒测试</li><li>静态测试</li></ul><p>其中灰盒测试为黑盒测试与白盒测试的<strong>混合测试方法</strong></p><p>测试用例(test case)是<strong>测试输入</strong>、<strong>执行条件</strong>以及<strong>预期结果</strong>的集合，是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合</p><h4 id="白盒测试"><a class="markdownIt-Anchor" href="#白盒测试"></a> 白盒测试</h4><p>白盒测试(又称为结构测试或逻辑驱动测试)是把测试对象看做一个<strong>透明的盒子</strong>，测试人员<strong>利用程序内部的逻辑结构及有关信息</strong>，<strong>设计</strong>或<strong>选择测试用例</strong>，对程序<strong>所有逻辑路径</strong>进行测试</p><p>白盒测试的<strong>内容</strong>:</p><ul><li>对程序模块的所有独立的执行路径<strong>至少测试一次</strong></li><li>对所有的<strong>逻辑判定</strong>，取<strong>真</strong>与取<strong>假</strong>的两种情况都至少测试一次</li><li>在循环的<strong>边界</strong>和<strong>运行界限</strong>内执行循环体</li><li>测试<strong>内部数据结构的有效性</strong>等</li></ul><h5 id="逻辑覆盖测试"><a class="markdownIt-Anchor" href="#逻辑覆盖测试"></a> 逻辑覆盖测试</h5><p>实现逻辑覆盖测试有不同的覆盖方法，一般根据实际情况进行选择，主要包括:</p><ul><li>语句覆盖</li><li>分支覆盖</li><li>条件覆盖</li><li>判定/条件覆盖</li><li>条件组合覆盖</li></ul><p><strong>强度由弱到强依次是：语句覆盖、分值覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖</strong></p><p>以一段代码为例进行说明:</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">function</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>  <span class="hljs-keyword">if</span> ((a &gt; <span class="hljs-number">1</span>) &amp;&amp; (b == <span class="hljs-number">0</span>)) &#123;<br>  c /= a;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((a == <span class="hljs-number">5</span>) || (c &gt; <span class="hljs-number">1</span>)) &#123;<br>  c += <span class="hljs-number">1</span>;<br>  &#125;<br>  c = a + b + c;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="test_case.png" alt="程序流程图" /></p><ul><li><p><strong>语句覆盖</strong>: 设计足够多的的用例来使程序中的<strong>可执行语句至少被执行一次</strong><br />可以看出如果程序按照<strong>A -&gt; C -&gt; E</strong>执行的话，那么就能满足语句覆盖<br />因此仅需要一个用例即可完成语句覆盖测试<br /><img src="statement_coverage.png" alt="语句覆盖" /></p></li><li><p><strong>分支覆盖</strong>: 设计足够多的用例来使程序中的<strong>每个判定的真、假分支至少被执行一次</strong><br />Judge1的两个分支为B和C，Judge2的两个分支为D和E，于是我们可以组合出BD，BE，CD，CE四条路径，要完成分支覆盖只需要选择{BD, CE}或{BE, CD}即可<br />以{BD, CE}为例:<br /><img src="judgement_coverage.png" alt="分支覆盖" /></p></li><li><p><strong>条件覆盖</strong>: 设计足够多的用例来使程序中<strong>每个判定中的每个条件(判定中的一个布尔表达式)的所有可能取值都至少取了一次</strong><br />Judge1中2个条件可以有4种组合{a&gt;1, b=0}、{a&gt;1, b!=0}、{a&lt;=1, b=0}、{a&lt;=1, b!=0}，按照真假至少满足一次，选取[{a=5，b=0}、{a=1，b=3}]<br />Judge2中2个条件可以有4种组合{a=5, c&gt;1}、{a=5, c&lt;=1}、{a!=5, c&gt;1}、{a!=5, c&lt;=1}，按照真假至少满足一次，选取[{a=5，c=1}、{a=1，c=6}]<br /><img src="condition_coverage.png" alt="条件覆盖" /></p></li><li><p><strong>分支/条件覆盖</strong>: 设计足够多的用例来<strong>同时满足分支覆盖和条件覆盖</strong><br /><img src="judgement_condition_coverage.png" alt="分支/条件覆盖" /></p></li><li><p><strong>条件组合覆盖</strong>: 设计足够多的用例来使<strong>所有条件的可能组合都至少取了一次</strong><br />Judge1中2个条件可以有4种组合[{a&gt;1, b=0}、{a&gt;1，b!=0}、{a&lt;=1，b=0}、{a&lt;=1，b!=0}]，选取[{a=5, b=0}、{a=5, b=1}、{a=1, b=0}、{a=1, b=1}]<br />Judge2中2个条件可以有4种组合[{a=5，c&gt;1}、{a=5，c&lt;=1}、{a!=5，c&gt;1}、{a!=5，c&lt;=1}]，选取[{a=5, c=6}、{a=5, c=1}、{a=1, c=6}、{a=1, c=1}]<br /><img src="condition_combanation_coverage.png" alt="条件组合覆盖" /></p></li></ul><h5 id="控制流图覆盖测试"><a class="markdownIt-Anchor" href="#控制流图覆盖测试"></a> 控制流图覆盖测试</h5><p><strong>控制流图</strong>: 符号⭕为控制流图的一个<strong>节点</strong>，表示一个或多个无分支的PDL语句或源程序语句，箭头(→)为<strong>边</strong>，表示控制流的方向<br /><strong>区域</strong>: 边和节点圈定的区域，当对区域计数时，图形外的区域也应记为一个区域</p><p><strong>控制流图的多分支情况一定有一个统一的交汇节点</strong><br /><img src="control_flow.png" alt="控制流图结构" /><br /><img src="CFG.png" alt="示例程序CFG图" /></p><p><strong>程序环路复杂性</strong>: 程序的环路复杂性给出了程序基本路径集中的独立路径条数，这是确保程序中每个<strong>可执行语句至少执行一次所必需的测试用例数目的上界</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">V(G) = e - n + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p><p>其中<strong>e为边数，n为节点数</strong></p><ul><li><p><strong>节点覆盖</strong>: <strong>与语句覆盖等价</strong></p></li><li><p><strong>边覆盖</strong>: 对于图G中每一个可达的长度小于等于1的路径(即一条边)，测试用例所执行的测试路径集合中<strong>至少存在一条测试路径经过该路径</strong>，<strong>与分支覆盖等价</strong></p></li><li><p><strong>路径覆盖</strong>: 设计足够多的用例来使程序中<strong>所有可能的路径都至少被执行一次</strong><br />所有可能的路径为：{BD, BE, CD, CE}</p><ul><li>BD: {a=1, b=1, c=1}</li><li>BE: {a=1, b=0, c=6}</li><li>CD: {a=2, b=0, c=1}</li><li>CE: {a=5, b=0, c=6}<br /><img src="path_coverage.png" alt="路径覆盖" /></li></ul></li></ul><h4 id="黑盒测试"><a class="markdownIt-Anchor" href="#黑盒测试"></a> 黑盒测试</h4><p>黑盒测试<strong>不考虑程序内部的逻辑结构和内部特性</strong>，只依据程序的需求规格说明书，<strong>检查程序的功能是否符合它的功能说明</strong></p><p>方法:</p><ul><li>等价类划分</li><li>边界值分析</li><li>状态测试</li></ul><h5 id="等价类划分"><a class="markdownIt-Anchor" href="#等价类划分"></a> 等价类划分</h5><p>等价类: <strong>各个输入数据对于揭露程序中的错误都是等效的</strong><br />测试<strong>某</strong>等价类的代表值就等价于对这一类其它值的测试<br />等价类可以分为2种:</p><ul><li><strong>有效等价类</strong>: 是指对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合</li><li><strong>无效等价类</strong>: 是指对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合</li></ul><h5 id="边界值分析"><a class="markdownIt-Anchor" href="#边界值分析"></a> 边界值分析</h5><p>由经验得知，大量的错误是发生在<strong>输入或输出范围的边界上</strong>，而不是在输入范围的内部<br />因此<strong>专门设计用例来测试边界</strong>是黑盒测试的一种方法<br />边界值分析往往与等价类划分一同使用，<strong>将边界值作为等价类的代表值进行测试</strong></p><p><strong>例</strong>:<br />某工资查询系统需要输入工号和年月，<strong>工号为10000-50000之间的整数(不包含10000和50000)</strong>;<strong>年份为2010年1月至2020年12月</strong>。软件运行时，如输入的工号和年月不在上述范围，则不予接收，显示输入无效</p><p><img src="equivalence_class.png" alt="划分等价类" /></p><p><img src="border_test.png" alt="结合边界值作为等价类代表值设计用例" /></p><h5 id="状态测试"><a class="markdownIt-Anchor" href="#状态测试"></a> 状态测试</h5><p>状态测试用于在<strong>向同一功能提供不同的输入值时捕获软件应用程序的行为</strong><br />其适用于那些提供访问应用程序的特定尝试次数的应用程序类型，<strong>例如</strong>: 在指定次数的错误尝试后会锁定应用程序的登录功能。在使用电子邮件和密码的登录功能中，它提供了特定次数的尝试来访问应用程序，在超过最大尝试次数后，它会锁定然后显示错误消息。</p><p>通过状态转换表来记录系统的响应<br /><img src="status_transfer.png" alt="状态转换表示例" /></p><h4 id="静态测试"><a class="markdownIt-Anchor" href="#静态测试"></a> 静态测试</h4><p>静态测试: <strong>不实际运行程序</strong>，通过<strong>检查和阅读</strong>等手段来发现错误并评估代码质量的软件测试技术<br />静态测试的<strong>目的</strong>:<br /><b></p><ul><li>通过对代码标准及质量的监控提高代码可靠性</li><li>尽可能早地通过对源代码的检查发现缺陷</li><li>组织代码审核定位易产生错误的模块</li></ul></b><p>静态测试的<strong>内容</strong>:</p><ul><li>检查<strong>需求</strong></li><li>检查<strong>设计</strong></li><li>检查<strong>代码</strong></li></ul><p>静态测试的主要方法: 评审，有<strong>3种主要评审类型</strong>:</p><ul><li>同事审查: 是非正式审查</li><li>走查: 由开发组内部进行</li><li>审查: 由开发组、测试组、产品经理等联合会议进行审查</li></ul><h2 id="测试策略"><a class="markdownIt-Anchor" href="#测试策略"></a> 测试策略</h2><p>软件测试策略为软件开发人员、质量保证组织、和客户提供了一个路线图，<strong>规定了测试的主要步骤</strong>，最典型即为<strong>V模型</strong><br /><img src="V_model.png" alt="V模型" /></p><h3 id="回归测试"><a class="markdownIt-Anchor" href="#回归测试"></a> 回归测试</h3><p>定义: <strong>有选择</strong>地<strong>重新测试系统或其组件</strong>，以<strong>验证对软件的修改</strong>没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求<br />回归测试一般是在<strong>对软件缺陷进行修改、、功能改变后、新增功能后进行(进行完全回归测试来测试整个系统也是可以的)<strong>的，因此</strong>可以在所有的测试级别执行</strong>，并应用于功能和非功能测试中<br /><strong>回归测试应该尽量采用自动化测试</strong></p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p><strong>单元测试</strong>: 又称<strong>模块测试</strong>，是针对软件设计的最小单位─<strong>程序模块</strong>，进行正确性检验的测试工作<br /><span style="color:#ff562b"><b>以白盒测试为主，黑盒测试为辅</b></span></p><h4 id="主要依据"><a class="markdownIt-Anchor" href="#主要依据"></a> 主要依据</h4><p><strong>是详细设计，而非代码</strong>，因为未测代码可能包含错误和缺陷，如果依照其测试，则可能无法发现一些错误</p><h4 id="主要内容"><a class="markdownIt-Anchor" href="#主要内容"></a> 主要内容</h4><p>单元测试的主要内容有5个方面:<br /><b></p><ul><li>模块接口(模型调用的显性接口和网络等隐形接口): 通过被测模块的数据流进行测试，包括调用被测模块的输入、被测模块调用子模块的输入、全局变量的一致性以及IO等</li><li>局部数据结构: 数据结构匹配、未定义、初始化、全局变量的内容</li><li>边界条件: 数据流、控制流的边界条件是否出错</li><li>出错处理: 错误提示、错误处理</li><li>独立路径: 进行基本路径测试</li></ul></b><h4 id="单元测试环境"><a class="markdownIt-Anchor" href="#单元测试环境"></a> 单元测试环境</h4><p><img src="unit_test.png" alt="单元测试环境" /></p><ul><li><strong>驱动模块</strong>: 用以<strong>调用被测模块</strong>，使被测的模块得到执行</li><li><strong>桩模块</strong>: 用以<strong>替代被测模块所调用的那些模块</strong>，可以<strong>隔离缺陷</strong>(子模块可能的缺陷)</li></ul><h3 id="集成测试"><a class="markdownIt-Anchor" href="#集成测试"></a> 集成测试</h3><p><strong>集成测试</strong>: 将模块集成起来后进行测试，又称为子系统测试、组装测试、部件测试等<br /><span style="color:#ff562b"><b>灰盒测试，既有白盒测试的成分，也有黑盒测试的成分</b></span></p><h4 id="主要依据-2"><a class="markdownIt-Anchor" href="#主要依据-2"></a> 主要依据</h4><p><strong>为概要设计</strong>，因为概要设计涉及到了模块之间的关系(架构设计、接口设计)</p><h4 id="集成测试的方法"><a class="markdownIt-Anchor" href="#集成测试的方法"></a> 集成测试的方法</h4><p>主要为<strong>3种方法</strong>:</p><ul><li><strong>自顶向下的集成方法</strong></li><li><strong>自底向上的集成方法</strong></li><li><strong>smoke方法</strong></li></ul><h5 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h5><p>将模块按系统程序结构，沿控制层次<strong>自顶向下进行集成</strong>，有<strong>深度优先和广度优先2种向下方式</strong></p><p><strong>深度优先</strong><br /><img src="DFS.gif" alt="深度优先" /></p><p><strong>广度优先</strong><br /><img src="BFS.gif" alt="广度优先" /></p><h5 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h5><p>从软件结构最底层的模块开始，<strong>按照接口依赖关系逐层向上集成</strong>以进行测试<br /><img src="down_top.gif" alt="自底向上" /></p><p>在实际工作中，常常是<strong>综合使用</strong>自底向上和自顶向下的集成方法<br />按进度选择<strong>优先测试已经完成的模块</strong>:</p><ul><li>如果已完成的模块所调用的模块没有完成，就采用自顶向下的方法，打桩进行测试</li><li>如果已经完成模块的上层模块没有完成，可以采用自底向上集成方式</li></ul><h5 id="smoke"><a class="markdownIt-Anchor" href="#smoke"></a> smoke</h5><p>Smoke Testing的概念最早源于制造业，用于测试管道。测试时，用鼓风机往管道里灌烟，看管壁外面是否有烟冒出来，以便检验管道是否有缝隙。这一测试显然比较初级，更深层一点的测试至少要进行渗油测试、带压测试等等。Smoke Testing只是一种初级、直观的测试</p><p>因此在软件测试中，smoke测试针对整个系统进行<strong>最基本功能的测试</strong>，保证基本的功能和流程能走通，快速验证基本功能，是一种预测试，检查软件是否具备可测性，也叫做可测性测试</p><h5 id="不同集成测试的优缺点"><a class="markdownIt-Anchor" href="#不同集成测试的优缺点"></a> 不同集成测试的优缺点</h5><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">自顶向下</th><th style="text-align:center">自底向上</th><th style="text-align:center">smoke</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:center">测试过程中较早的验证了主要的控制和判断点<br>可以首先实现和验证完整的软件功能</td><td style="text-align:center">每个底层模块都已测试，无需桩模块</td><td style="text-align:center">节省测试时间，防止构造失败</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">桩的开发量较大</td><td style="text-align:center">每个模块都必须编写驱动模块<br>缺陷的隔离和定位不如自顶向下</td><td style="text-align:center">覆盖率比较低</td></tr></tbody></table><h3 id="系统测试"><a class="markdownIt-Anchor" href="#系统测试"></a> 系统测试</h3><p>是<strong>从用户使用的角度来进行的测试</strong>，主要工作是将完成了集成测试的系统放在真实的运行环境下进行测试，<strong>用于功能确认和验证</strong><br /><span style="color:#ff562b"><b>基本采用黑盒测试</b></span></p><h4 id="主要依据-3"><a class="markdownIt-Anchor" href="#主要依据-3"></a> 主要依据</h4><p><strong>为需求规格</strong>，是根据需求来测试系统是否满足</p><h4 id="主要内容-2"><a class="markdownIt-Anchor" href="#主要内容-2"></a> 主要内容</h4><b><ul><li>功能性测试: 验证需求功能是否正确实现</li><li>性能测试: 评估软件在特定环境下完成任务的若干种指标(时间效率、空间效率、事务操作性能等)</li><li>安全测试: 检测对于用户使用权限进行管理、控制和监督一方非法进入、篡改、窃取和破坏等行为的能力</li><li>压力测试: 检查系统对异常情况的承受能力</li><li>恢复测试: 强制地让系统发生故障并验证其能适当恢复的一种系统测试</li></ul></b>还有其他系统测试如配置测试、兼容性测试、本地化测试、文档测试、易用性测试等<h3 id="验收测试"><a class="markdownIt-Anchor" href="#验收测试"></a> 验收测试</h3><p><strong>是以用户为主的测试并且使用生产中的实际数据进行测试</strong>，软件开发人员和QA(质量保证)人员也应参加，为了评价软件产品的FLURPS(即功能、局域化、可使用性、可靠性、性能和支持)</p><h4 id="主要依据-4"><a class="markdownIt-Anchor" href="#主要依据-4"></a> 主要依据</h4><p>为用户实际需求</p><h4 id="主要形式"><a class="markdownIt-Anchor" href="#主要形式"></a> 主要形式</h4><b><ul><li>根据合同进行的验收测试</li><li>用户验收测试</li><li>现场测试</li></ul></b><h4 id="验收测试方法"><a class="markdownIt-Anchor" href="#验收测试方法"></a> 验收测试方法</h4><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>测试: <strong>一个用户</strong>在<strong>开发环境下</strong>进行的测试，也可以是公司内部的用户在<strong>模拟实际操作环境</strong>下进行的测试，尤其注重<strong>产品的界面和特色</strong></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>测试: <strong>多个用户</strong>在<strong>实际使用环境下</strong>进行的测试，着重于<strong>产品的支持性</strong></li></ul><p><strong>只有当α测试达到一定的可靠程度时，才能开始β测试</strong></p><h2 id="软件维护"><a class="markdownIt-Anchor" href="#软件维护"></a> 软件维护</h2><h3 id="定义与分类"><a class="markdownIt-Anchor" href="#定义与分类"></a> 定义与分类</h3><h4 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h4><p><strong>软件维护</strong>: 是指由于软件产品出现问题或需要改进而对<strong>代码及相关文档的修改</strong>，其目的是对现有软件产品<strong>进行修改的同时保持其完整性</strong></p><h4 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h4><ul><li><strong>纠错性维护</strong>: 因开发时测试的不彻底、不完全，必然会有<strong>部分隐藏的错误遗留到运行阶段</strong>，纠错性维护就是为了<strong>识别和纠正软件错误</strong>、<strong>改正软件性能上的缺陷</strong>、<strong>排除实施中的误使用</strong></li><li><strong>完善性维护</strong>: 用户提出<strong>新的功能与性能要求</strong>，完善性维护就是为了<strong>扩充软件功能</strong>、<strong>增强软件性能</strong>、<strong>改进加工效率</strong>、<strong>提高软件的可维护性</strong></li><li><strong>适应性维护</strong>: 在使用过程中<strong>外部环境</strong>(新的硬、软件配置)，数据环境(数据库、数据格式、数据输入/输出方式、数据存储介质)<strong>可能发生变化</strong>，适应性维护就是为了使软件<strong>适应这种变化</strong></li><li><strong>预防性维护</strong>: 预防性维护就是为了提高软件的<strong>可维护性、可靠性</strong>等，对某一部分(重新)进行设计、编制和测试</li></ul><p><span style="color:#ff562b"><b>在维护阶段的最初一段时期，纠错性维护的工作量较大，随着错误发现率逐渐降低并趋于稳定，适应性维护和完善性维护的工作量逐步增加</b></span><br /><img src="maintain.png" alt="各类维护的比重" /></p><ul><li>在整个软件维护阶段所花费的全部工作量中，<strong>完善性维护占了几乎一半的工作量</strong></li><li>软件维护的费用<strong>占整个生命周期经费开支的大部分</strong></li></ul><p>可见维护的<strong>困难性</strong>，其导致<strong>原因</strong>包括:<br /><b></p><ul><li>配置管理工作不到位</li><li>人员变动造成的影响</li><li>许多软件的的可读性差</li><li>任务紧、时间急的情况下处理维护请求</li></ul></b><p><strong>可维护性</strong>: 是指<strong>纠正软件系统出现的错误和缺陷，以及为满足新要求进行修改、扩充或压缩</strong>的<strong>容易程度</strong></p><p><strong>决定软件可维护性的主要因素</strong>:</p><ul><li>可理解性</li><li>可使用性</li><li>可测试性</li><li>可修改性</li><li>可移植性</li><li>效率</li><li>可靠性</li></ul><p><strong>影响软件可维护性的维护环境的因素</strong>:</p><ul><li>软件维护的文档</li><li>软件的运行环境</li><li>软件的维护组织</li><li>软件维护质量</li></ul><h3 id="维护成本与工作量"><a class="markdownIt-Anchor" href="#维护成本与工作量"></a> 维护成本与工作量</h3><h4 id="维护成本"><a class="markdownIt-Anchor" href="#维护成本"></a> 维护成本</h4><p>维护成本分为两部分成本:</p><ul><li><strong>有形成本</strong>: 有形的软件维护成本是<strong>花费了多少现金</strong></li><li><strong>无形成本</strong>:<ul><li><strong>降低生产率</strong>: 把软件人员抽调到维护工作中，干扰了软件开发工作</li><li><strong>客户不满</strong>: 合理的修复或改请求不能及时安排</li><li><strong>软件质量可能下降</strong>: 可能引入新的故障</li></ul></li></ul><h4 id="工作量"><a class="markdownIt-Anchor" href="#工作量"></a> 工作量</h4><p>维护工作量包括:</p><ul><li><strong>生产性活动</strong>: 如分析和评价、设计修改和实现</li><li><strong>轮转活动</strong>: 如力图理解代码在做什么、试判明数据结构、接口特性、性能界限等</li></ul><p><strong>影响维护工作量的因素</strong>:</p><ul><li>系统大小</li><li>程序设计语言</li><li>系统年龄</li><li>数据库技术的应用</li><li>结构化的软件开发技术</li><li>数学模型、任务难度等</li></ul><p><span style="color:#ff562b"><b>维护工作量估算模型</b></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><mi>P</mi><mo>+</mo><mi>K</mi><mo>×</mo><msup><mi>e</mi><mrow><mi>c</mi><mo>−</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">M = P + K \times e^{c - d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8991079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">d</span></span></span></span></span></span></span></span></span></span></span></span></span></p><div style="color:#ff562b"><b><ul><li>M: 维护的总工作量</li><li>P: 生产性工作量</li><li>K: 经验常数</li><li>c: 复杂程度</li><li>d: 维护人员对软件的熟悉程度</li></ul></b></div><h3 id="软件维护的过程模型"><a class="markdownIt-Anchor" href="#软件维护的过程模型"></a> 软件维护的过程模型</h3><p><img src="maintain_model.png" alt="IEEE维护模型" /></p><h3 id="软件维护技术"><a class="markdownIt-Anchor" href="#软件维护技术"></a> 软件维护技术</h3><ul><li><strong>软件再工程</strong></li><li><strong>软件逆向工程</strong></li></ul><h4 id="软件再工程"><a class="markdownIt-Anchor" href="#软件再工程"></a> 软件再工程</h4><p>定义: 指对<strong>现有软件</strong>进行<strong>仔细审查和改造</strong>，对其进行<strong>重新构造</strong>，使之<strong>成为一个新的形式</strong>，同时包括随之产生的对新形式的实现</p><p><strong>再工程模型</strong>:<br /><img src="software_reengineering.jpg" alt="软件再工程模型" /></p><ol><li><strong>信息库分析</strong>: 应该仔细<strong>分析库存目录</strong>，按照业务重要程度、寿命、当前可维护性等标准，<strong>把库中的应用排序</strong>，从中选出再工程的侯选者。然后<strong>合理地分配再工程所需要的资源</strong></li><li><strong>文档重构</strong>: 根据情况处理文档:<ul><li>废弃: 程序是相对稳定的，正在走向生命的终点，则不再重新建立文档</li><li>部分重构: 只建立系统中<strong>当前正在修改的那些部分的完整文档</strong></li><li>完全重构: 系统是用户完成业务工作的关键</li></ul></li><li><strong>逆向工程</strong>: <strong>根据源程序来恢复设计结果</strong></li><li><strong>代码重构</strong>: 将<strong>个体模块</strong>的设计细节以及在模块中定义的局部数据结构进行一定的重构</li><li><strong>数据重构</strong>: 对程序的<strong>数据结构</strong>进行适当修改</li><li><strong>正向工程</strong>: 由于数据重构的修改导致程序体系结构或代码层的改变，同时为了更改系统的架构设计等，要<strong>重新开发</strong>现有的系统</li></ol><p><strong>软件逆向工程过程</strong><br /><img src="reverse_engineering.png" alt="逆向工程" /></p><p>其中逆向工程需要对<strong>3个方面</strong>进行逆向:</p><ul><li><strong>数据</strong>的逆向工程: 是<strong>多抽象层次</strong>的逆向，包括:<ul><li><strong>内部数据结构的逆向</strong></li><li><strong>数据库结果的逆向</strong></li></ul></li><li><strong>处理</strong>的逆向工程: 即<strong>模块架构</strong>和<strong>模块内部详细设计</strong>的逆向</li><li><strong>用户界面</strong>的逆向工程: 包括<strong>页面的基本处理</strong>、<strong>页面对动作的行为反应</strong>等</li></ul><h2 id="项目管理"><a class="markdownIt-Anchor" href="#项目管理"></a> 项目管理</h2><p>定义: 是计划、协调、度量、监控、控制及报告等<strong>管理方法</strong>在软件开发和维护中<strong>的具体应用</strong></p><p><strong>软件项目管理的4大要素</strong>:<br /><b></p><ul><li>人员(People)</li><li>产品(Product)</li><li>过程(Process)</li><li>项目(Project)</li></ul></b><h3 id="人员"><a class="markdownIt-Anchor" href="#人员"></a> 人员</h3><p><span style="color:#ff562b"><b>人员管理主要体现在团队组织方式上</b></span></p><p><strong>团队组织形式</strong>有:</p><ul><li><strong>民主分权制(DD)</strong>: 该形式<strong>没有永久的领导者</strong>，任务协调员的任期为短工期，然后由其他人谁可以配合不同的任务所取代，存在的问题和方法的<strong>决策都是由小组共识</strong>，团队成员之间的<strong>横向通信</strong></li><li><strong>有控制的分权制(CD)</strong>: 该形式<strong>有明确的领导分配任务</strong>，也有负责子任务的<strong>次要领导人</strong>，解决问题仍然是一个<strong>群体活动</strong>，但解决方案是在由组长来实施。分组和个人之间的<strong>横向沟通</strong>、<strong>垂直控制</strong>层次的沟通都会发生</li><li><strong>有控制的集中制(CC)</strong>: 好的团队内部问题的解决和协调的管理是由一个团队的<strong>领导者</strong>，<strong>领导者和团队之间的沟通是垂直的</strong></li></ul><p><strong>虚拟团队</strong>是利用信息技术<strong>将实际上分散的成员联系起来</strong>，以实现一个共同目标的团队，如团队成员通过Internet、可视电话会议系统、电子邮件等方式沟通</p><ul><li><strong>优点</strong>: <strong>提高生产力，扩大市场机会，知识转移</strong></li><li><strong>缺点</strong>: <strong>沟通不足，领导不力和管理，不称职的团队成员</strong></li></ul><p><strong>人力资源管理成熟度模型(People Capability Maturity Model)</strong><br />PCMM是通过<strong>对人力资源管理</strong>的如人力资源规划、薪酬管理、绩效管理、组织管理、职业规划、培训管理、知识管理等模块，按<strong>初始级、重复级、定义级、定量级和优化级</strong>5个递进层级进行详细描述和分级，分级方式与<a href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8Bcapatility-maturity-model">CMM模型</a>相同</p><h3 id="产品"><a class="markdownIt-Anchor" href="#产品"></a> 产品</h3><p>在策划一个项目以前，应当<strong>建立产品的目标和范围</strong>，应<strong>考虑其他解决办法</strong>，以及<strong>技术和管理应当被约束</strong></p><p><strong>软件范围</strong>:<br /><b></p><ul><li>功能</li><li>性能</li><li>约束</li><li>接口</li><li>可靠性</li></ul></b><h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3><p><strong>是软件开发的一个全面计划</strong>，应当对<a href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B">软件开发过程模型</a>进行合适的选择</p><h3 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h3><p>定义: 把<strong>人力和非人力资源集合在一个临时性组织中来实现一个规定的目标</strong><br />项目管理就是将知识、技能工具和技术应用于项目活动以满足或超过项目干系人对项目的需要和期望，因此需要<strong>理解成功项目管理的关键因素，掌握项目计划、监控和控制的一般方法</strong></p><p><strong>项目的特征</strong>:<br /><b></p><ul><li>有明确的目标</li><li>有生命周期</li><li>项目任务可分解</li><li>需要多种资源</li><li>有不确定因素</li></ul></b><p><strong>项目计划</strong>: 是提供一个框架，使得管理人员对资源、成本和进度做出合理估算<br />项目计划的<strong>步骤</strong>:</p><ol><li>Scoping(范围): 确定软件范围</li><li>Estimation(估算): 估算资源、工作量、成本</li><li>Risk(风险): 风险管理</li><li>Schedule(进度): 进度安排</li><li>Control Strategy(控制策略): 指定控制策略</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Software Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8253</title>
    <link href="/2022/12/08/8253/"/>
    <url>/2022/12/08/8253/</url>
    
    <content type="html"><![CDATA[<h1 id="8253"><a class="markdownIt-Anchor" href="#8253"></a> 8253</h1><p>8253芯片是<strong>可编程计数器/定时器</strong>。8253内部有<strong>三个计数器</strong>，分别称为计数器0、计数器1和计数器2，他们的<strong>结构完全相同</strong>。</p><h2 id="8253的功能与结构"><a class="markdownIt-Anchor" href="#8253的功能与结构"></a> 8253的功能与结构</h2><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><p><strong>8253的主要功能</strong>:<br /><b></p><ul><li>计数器</li><li>定时器(计数脉冲是已知周期的时钟信号)</li><li>频率发生器</li><li>方波发生器<br /></b></li></ul><h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3><p><img src="8253_structure.png" alt="8253内部逻辑图" /><br /><img src="inner_structure.png" alt="计数器内部结构" /><br />8253结构较为简单，从编程者的角度来看是常规IO端口，由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>S</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{CS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>信号控制片选，A1A0选择计数器即可，然后直接使用<code>in</code>或<code>out</code>指令操作。</p><h2 id="8253的工作方式"><a class="markdownIt-Anchor" href="#8253的工作方式"></a> 8253的工作方式</h2><p>对于8253，需要着重了解其<strong>6种工作方式</strong>，每种方式都有特殊的应用。</p><h3 id="方式0-计数结束中断"><a class="markdownIt-Anchor" href="#方式0-计数结束中断"></a> 方式0: 计数结束中断</h3><p><strong>功能: 经过计数初值个时钟周期后out变为高电平</strong><br /><img src="way0.png" alt="工作示意图" /><br />工作流程:</p><ol><li>写入控制字后<strong>OUT变低电平</strong></li><li>写入计数初值后的一个CLK的<strong>下降沿</strong>，计数初值被装入计数器，然后在每个CLK的下降沿做减1计数</li><li>当计数到0时OUT输出变为<strong>高电平</strong></li></ol><p>注意事项:</p><ul><li><strong>GATE为高电平时，计数器工作，为低电平时停止计数</strong></li><li>在计数过程中若重新写了新的计数初值，则<strong>按新值重新工作</strong></li><li><strong>每写一次计数初值只计数一个计数周期(不会重复)</strong></li></ul><h3 id="方式1-可重复触发的单稳态触发器"><a class="markdownIt-Anchor" href="#方式1-可重复触发的单稳态触发器"></a> 方式1: 可重复触发的单稳态触发器</h3><p><strong>功能: 作为GATE信号触发的单稳态触发器</strong><br /><img src="way1.png" alt="工作示意图" /><br />工作流程:</p><ol><li>写入控制字后<strong>OUT变高电平</strong></li><li>当GATE信号出现上升沿时，在CLK的下降沿装入计数初值，<strong>OUT变低电平</strong>，开始计数，在每个CLK的下降沿做减1计数</li><li>当计数到0时OUT输出变为<strong>高电平</strong></li></ol><p>注意事项:</p><ul><li><strong>GATE出现上升沿时，装入计数初值</strong></li><li>在计数过程中若再次出现GATE上升沿，则<strong>按计数初值重新计数</strong></li><li><strong>计数完成后GATE信号再次出现上升沿则重复工作(相同计数初值无需重新写入)</strong></li></ul><h3 id="方式2-频率发生器"><a class="markdownIt-Anchor" href="#方式2-频率发生器"></a> 方式2: 频率发生器</h3><p><strong>功能: 可输出连续负脉冲周期波形，即可做分频器</strong><br /><img src="way2.png" alt="软件触发工作示意图" /><br />工作流程(软件触发):</p><ol><li>写入控制字后<strong>OUT变高电平</strong></li><li>写计数初值后的一个CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数</li><li><strong>计数期间OUT保持为高，当计数到1时OUT输出宽度为1个CLK周期的负脉冲</strong>，然后<strong>重新装入计数初值</strong>开始计数</li></ol><p>注意事项:</p><ul><li>计数中重写计数初值，则<strong>下次计数周期才会以新值开始计数</strong>(必须完成一次完整计数)</li><li>软件触发的情况下，<strong>会自动重复工作(会自动重新装入计数初值)</strong></li><li>软件触发要求GATE信号始终为高电平</li><li>硬件触发流程: 写控制字和计数初值时GATE为低，当其变高后的下一个CLK下降沿计数器装入初值，后面每个CLK下降沿计数</li></ul><h3 id="方式3-方波发生器"><a class="markdownIt-Anchor" href="#方式3-方波发生器"></a> 方式3: 方波发生器</h3><p><strong>功能: 可输出连续方波周期波形，也可做分频器</strong><br /><img src="way3.png" alt="软件触发工作示意图" /><br />工作流程(软件触发):</p><ol><li>写入控制字后<strong>OUT变高电平</strong></li><li>写计数初值后的一个CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数</li><li><strong>计数期间占空比为1:1的方波</strong>，然后<strong>重新装入计数初值</strong>开始计数，<strong>周期为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>C</mi><mi>L</mi><mi>K</mi><mi mathvariant="normal">周</mi><mi mathvariant="normal">期</mi></mrow><mrow><mi mathvariant="normal">计</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">初</mi><mi mathvariant="normal">值</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{CLK周期}{计数初值}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">计</span><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">初</span><span class="mord cjk_fallback mtight">值</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord cjk_fallback mtight">周</span><span class="mord cjk_fallback mtight">期</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></strong></li></ol><p>注意事项:</p><ul><li>方式3与方式2基本相同，<strong>区别在于输出波形</strong></li><li>若计数初值为偶数，则OUT输出是高低电平对称的方波</li><li>若计数初值为奇数，则OUT输出不对称，前面的高比后面的低多1个CLK周期，即近似方波</li><li>计数中重写计数初值，则<strong>下次计数周期才会以新值开始计数</strong>(必须完成一次完整计数)</li><li>软件触发的情况下，<strong>会自动重复工作(会自动重新装入计数初值)</strong></li><li>软件触发要求GATE信号始终为高电平</li></ul><h3 id="方式4-软件触发选通重写计数初值才能触发"><a class="markdownIt-Anchor" href="#方式4-软件触发选通重写计数初值才能触发"></a> 方式4: 软件触发选通(重写计数初值才能触发)</h3><p><strong>功能: 可输出单个负脉冲信号</strong><br /><img src="way4.png" alt="工作示意图" /><br />工作流程(软件触发):</p><ol><li>写入控制字后<strong>OUT变高电平</strong></li><li>写计数初值后的一个CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数</li><li><strong>计数期间OUT保持为高，当计数到0时OUT输出宽度为1个CLK周期的负脉冲</strong></li></ol><p>注意事项:</p><ul><li>类似<strong>方式2的一个周期</strong>，但负脉冲输出推迟了一个CLK周期</li><li>在计数过程中若重新写了新的计数初值，则<strong>按新值重新工作</strong></li><li><strong>GATE为高电平时，计数器工作，为低电平时停止计数</strong></li></ul><h3 id="方式5-硬件触发选通gate上升沿触发"><a class="markdownIt-Anchor" href="#方式5-硬件触发选通gate上升沿触发"></a> 方式5: 硬件触发选通(GATE上升沿触发)</h3><p><strong>功能: 可输出单个负脉冲信号</strong><br /><img src="way5.png" alt="工作示意图" /><br />工作流程(软件触发):</p><ol><li>写入控制字后<strong>OUT变高电平</strong></li><li>GATE信号上跳的CLK的下降沿，初值被装入计数器，然后对每个CLK的下降沿减1计数</li><li><strong>计数期间OUT保持为高，当计数到0时OUT输出宽度为1个CLK周期的负脉冲</strong></li></ol><p>注意事项:</p><ul><li>功能与方式4完全相同，<strong>触发方式改为了GATE信号上升沿</strong></li><li>在计数过程中若出现GATE上升沿，则<strong>重新装入计数初值工作</strong></li><li>一次GATE触发只计数一个周期(<strong>不自动重复</strong>)</li></ul><h2 id="8253的控制字"><a class="markdownIt-Anchor" href="#8253的控制字"></a> 8253的控制字</h2><p><img src="control.png" alt="控制字结构" /><br />8253的控制字也十分简单，只有一个，在确定工作方式和计数器初值后只需确定端口地址并将正确的控制字out出去即可。</p><h2 id="8253的初始化"><a class="markdownIt-Anchor" href="#8253的初始化"></a> 8253的初始化</h2><p>8253初始化方法分为2步:</p><ol><li><strong>向控制端口写入正确控制字(所有通道的控制字都写入同一个控制端口)</strong></li><li><strong>向对应计数器端口写入计数初值</strong></li></ol><p><strong>注意: 计数初值写入的格式和顺序必须按控制字D5和D4规定的格式写入</strong></p><p><strong>初始化示例</strong>:<br />设计数器1工作于方式1，BCD码计数，计数初值为十进制4000。设端口地址为0E0H~0E3H。<br />则控制字为:</p><div class="tg-wrap"><table><thead><tr><th>0</th><th>1</th><th>1</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td colspan="2">计数器1</td><td colspan="2">只写高字节</td><td colspan="3">方式1</td><td>十进制计数</td></tr></tbody></table></div><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">E3H</span><span class="hljs-comment">; 控制端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">63H</span><span class="hljs-comment">; 控制字</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">E1H</span><span class="hljs-comment">; 计数器1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">40H</span><span class="hljs-comment">; 只写高字节为40</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br></code></pre></td></tr></table></figure><h2 id="8253的应用示例"><a class="markdownIt-Anchor" href="#8253的应用示例"></a> 8253的应用示例</h2><p><strong>多级分频器</strong>:<br />IBM/PC微型计算机的某扩展板上使用一片8253，其端口地址为400H～403H。要求从定时器0的输出端OUT0得到250Hz的方波信号，从定时器1的输出端OUT1得到10Hz的连续单拍负脉冲信号。已知系统提供的计数脉冲频率为125kHz，硬件连接如图所示，试编写初始化程序。<br /><img src="example1.png" alt="硬件连接" /><br />out0要求<strong>方波</strong>因此必须<strong>工作在方式3</strong>，out1要求<strong>单拍负脉冲</strong>因此必须<strong>工作在方式2</strong>。<br />计数初值:</p><ul><li>计数器0: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>125</mn><mi>k</mi></mrow><mn>250</mn></mfrac><mo>=</mo><mn>500</mn><mo>=</mo><mn>01</mn><mi>F</mi><mn>4</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">\frac{125k}{250}=500=01F4H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span></li><li>计数器1: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>250</mn><mn>10</mn></mfrac><mo>=</mo><mn>25</mn><mo>=</mo><mn>19</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">\frac{250}{10}=25=19H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span></li></ul><p>控制字0:</p><div class="tg-wrap"><table><thead><tr><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td colspan="2">计数器0</td><td colspan="2">先写低位，再写高位</td><td colspan="3">方式3</td><td>二进制计数</td></tr></tbody></table></div>控制字1: <div class="tg-wrap"><table><thead><tr><th>0</th><th>1</th><th>0</th><th>1</th><th>0</th><th>1</th><th>0</th><th>1</th></tr></thead><tbody><tr><td colspan="2">计数器1</td><td colspan="2">只写低位</td><td colspan="3">方式2</td><td>二进制计数</td></tr></tbody></table></div><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">403H</span><span class="hljs-comment">; 控制端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">36H</span><span class="hljs-comment">; 计数器0控制字</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">400H</span><span class="hljs-comment">; 计数器0端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">F4H</span><span class="hljs-comment">; 计数器0的计数初值</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">01</span><span class="hljs-comment">; 计数器0的计数初值</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">403H</span><span class="hljs-comment">; 控制端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">54H</span><span class="hljs-comment">; 计数器1控制字</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">401H</span><span class="hljs-comment">; 计数器1端口</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">19H</span><span class="hljs-comment">; 计数器1的计数初值</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hardware Interface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8259A</title>
    <link href="/2022/12/08/8259A/"/>
    <url>/2022/12/08/8259A/</url>
    
    <content type="html"><![CDATA[<h1 id="8259a"><a class="markdownIt-Anchor" href="#8259a"></a> 8259A</h1><p>8259A是专门为了对8085A和8086/8088进行中断控制而设计的芯片，它是可以用程序控制的<strong>中断控制器</strong>。</p><h2 id="8259a的功能与结构"><a class="markdownIt-Anchor" href="#8259a的功能与结构"></a> 8259A的功能与结构</h2><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><p><strong>8259A的主要功能</strong>:<br /><b></p><ul><li>记录8个中断源的中断请求</li><li>从有请求的中断源中找出高优先级的中断源，并向CPU发出中断请求</li><li>CPU响应中断时向CPU发送中断类型号</li></ul><p>其主要作用是控制并发的中断请求，由8259A先进行判优再代替中断源向CPU发出中断请求，以实现对中断的处理<br /></b></p><h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3><p><img src="8259a_structure.png" alt="8259A内部逻辑图" /><br />如图所示，8259A由以下几个模块构成:</p><ul><li>数据总线缓冲器: 内部为三态双向8位缓冲器，接数据总线低8位D7~D0，也可通过总线驱动器与总线连接</li><li>读写控制逻辑: 实现对8259A的读写和端口译码<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mi>D</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{RD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 读信号</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>W</mi><mi>R</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{WR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 写信号</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>C</mi><mi>S</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{CS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 片选信号，一般通过多级门电路进行译码，低位直接接入芯片作为端口选择信号</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">A_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 端内部寄存器选择信号，1: 奇地址;0: 偶地址</li></ul></li><li>级联缓冲/比较器: 当中断源多于8个时需要将8259A进行级联，主片的CAS2~CAS0做输出，从片的CAS2~CAS0做输入，从片的INT接主片的IRi</li><li><strong>中断请求寄存器IRR</strong>: 共8位，分别对应IR7~IR0，<strong>当有中断请求出现时，对应位置位，中断响应后复位，允许同时多位为1</strong></li><li><strong>中断屏蔽寄存器IMR</strong>: 共8位，同样对应IR7~IR0，<strong>当置位时中断请求不会进入判优器中，复位时无影响</strong></li><li><strong>优先级判别器PR</strong>: <strong>对未被屏蔽的中断请求寄存器中为1的请求进行优先级判断，将优先级最高的请求发出INTR信号，待收到第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>信号后将ISR对应位置位，对IRR对应位复位</strong></li><li><strong>中断服务寄存器ISR</strong>: 共8位，<strong>如果某中断被执行，对应位置位，直到中断服务完成(执行EOI操作)复位</strong></li><li>控制电路: 根据信号来控制各寄存器的交互(收到第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>对IRR复位和ISR置位，<strong>收到第二个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>送出中断类型号</strong>)</li></ul><p><img src="cascade.png" alt="非缓存级联" /></p><p>8259A工作原理流程</p><pre><code class="mermaid" >flowchart TD    SRC["中断源"]    CPU["CPU"]    BUS["总线"]    subgraph "8259A"        IRR["IRR"]        IMR["IMR"]        ISR["ISR"]        PR["PR"]        Control["控制电路"]        IRR-->|"中断判优"|PR-->|"优先级最高中断"|Control        Control-->|"复位对应位"|IRR        PR<-->|"屏蔽判断"|IMR    end    SRC-->|"中断请求"|IRR    Control-->|"INTR、中断类型号"|BUS    BUS<-->CPU    BUS-->|"INTA1、INTA2、EOI"|Control    Control-->|"置位对应位"|ISR    Control-->|"复位对应位"|ISR</code></pre><h2 id="8259a的工作方式"><a class="markdownIt-Anchor" href="#8259a的工作方式"></a> 8259A的工作方式</h2><p>在6个方面有不同工作方式可以选择:</p><ul><li>中断嵌套方式:<ol><li>普通全嵌套: 当一个中断正被处理时，<strong>只有比它优先级更高的中断请求才会被响应</strong></li><li>特殊全嵌套: <strong>允许同级</strong>中断进行嵌套，<strong>只允许主片使用</strong></li></ol></li><li>优先级变化方式:<ol><li>固定方式: <strong>各中断请求的优先级固定不变，8259A加电后IR0最高，IR7最低</strong></li><li>循环方式: 一个中断源得到中断服务后，它的优先级自动降为最低<ol><li>自动循环: 按照加电时的初始优先级顺序进行优先级循环</li><li>特殊循环: 改变初始优先级顺序后的循环</li></ol></li></ol></li><li>中断源屏蔽方式:<ol><li>常规屏蔽方式: <strong>IMR置位代表屏蔽</strong></li><li>特殊屏蔽方式: <strong>使正在处理的中断所对应的IMR位置1，并使对应的ISR位清零，这样任何优先级的中断都可得到响应</strong></li></ol></li><li>中断结束方式:<br /><strong>多片级联时EOI需要两条，分别用于主片与从片</strong><ol><li>自动结束方式: 在第二个INTA脉冲的后沿，8259A将当前处理的中断所对应的ISR位清零。<strong>当系统正在为某外设进行中断服务，但在8259A的ISR中却没有对应位指示，故该方式只能用于非嵌套方式处理</strong></li><li>正常结束方式: 向8259A的<strong>偶地址</strong>端口输出一个<strong>操作命令字OCW2</strong>来发<strong>EOI命令</strong></li><li>特殊结束方式: 向8259A的<strong>偶地址</strong>端口输出一个<strong>操作命令字OCW2</strong>，其中的L2、L1、L0这三位指出了对ISR中的哪一位进行清除</li></ol></li><li>连接系统总线方式:<ol><li>缓存方式: 在很多片8259A级联的大系统中，8259A需要通过总线驱动器和数据总线相连</li><li>非缓存方式: 当系统中只有单片8259A或有少量几片8259A级联时，一般将8259A直接与数据总线相连</li></ol></li><li>中断触发方式:<ol><li><strong>电平触发</strong></li><li><strong>边沿触发</strong></li></ol></li></ul><h2 id="8259a的初始化命令字"><a class="markdownIt-Anchor" href="#8259a的初始化命令字"></a> 8259A的初始化命令字</h2><p>首先需要了解如何将控制字写入8259A:<br /><img src="in_out.png" alt="8259A读写" /><br />如上图所示: 通过A0与D4、D3配合进行寻址，从而实现控制字的写入。<br /><strong>注意: ICW2、ICW3、ICW4、OCW1地址相同，因此必须按顺序写入</strong></p><h3 id="icw1"><a class="markdownIt-Anchor" href="#icw1"></a> ICW1</h3><p><img src="icw1.png" alt="ICW1格式" /></p><h3 id="icw2"><a class="markdownIt-Anchor" href="#icw2"></a> ICW2</h3><p><img src="icw2.png" alt="ICW2格式" /></p><h3 id="icw3"><a class="markdownIt-Anchor" href="#icw3"></a> ICW3</h3><p><img src="icw3.png" alt="ICW3格式" /></p><h3 id="icw4"><a class="markdownIt-Anchor" href="#icw4"></a> ICW4</h3><p><img src="icw4.png" alt="ICW4格式" /></p><h3 id="8259a的初始化"><a class="markdownIt-Anchor" href="#8259a的初始化"></a> 8259A的初始化</h3><p><img src="initial.png" alt="初始化流程" /><br />如上图所示: 初始化中<strong>ICW1和ICW2必须写入</strong>进行通用性的配置，<strong>为单片时ICW3无需写入</strong>，<strong>根据ICW1内的设置来选择是否写入ICW4。</strong></p><h2 id="8259a的操作命令字"><a class="markdownIt-Anchor" href="#8259a的操作命令字"></a> 8259A的操作命令字</h2><p>在8259A工作期间，可通过<strong>操作命令字(OCW)来使它按不同的方式操作</strong>，<strong>没有写入顺序和时间要求，可独立使用</strong>。</p><h3 id="ocw1"><a class="markdownIt-Anchor" href="#ocw1"></a> OCW1</h3><p><img src="ocw1.png" alt="OCW1格式" /></p><h3 id="ocw2"><a class="markdownIt-Anchor" href="#ocw2"></a> OCW2</h3><p><img src="ocw2.png" alt="OCW2格式" /><br /><strong>Hint</strong>: L2L1L0设定优先级特殊循环方式时表示最低优先级为哪个中断源，如为011时，IR3优先级最低，因此优先级排序从高到低为: IR4 &gt; IR5 &gt; IR6 &gt; IR7 &gt; IR0 &gt; IR1 &gt; IR2 &gt; IR3</p><h3 id="ocw3"><a class="markdownIt-Anchor" href="#ocw3"></a> OCW3</h3><p><img src="ocw3.png" alt="OCW3格式" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hardware Interface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>X86汇编语法</title>
    <link href="/2022/12/08/X86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/12/08/X86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="x86汇编语法"><a class="markdownIt-Anchor" href="#x86汇编语法"></a> X86汇编语法</h1><p>目前支持Intel x86系列微机常用的汇编程序有ASM、MASM、TASM、OPTASM等。<strong>本文以MASM为主要内容。</strong><br />X86汇编语言语句可分为两种语句:</p><ul><li>指令语句: <strong>每一条指令语句在汇编时都要产生一个可供CPU执行的机器目标代码</strong>，它又叫可执行语句。</li><li>伪指令语句: 伪指令语句又叫命令语句，是指示性语句。<strong>伪指令本身不产生自己的机器目标代码</strong>。它指示汇编程序对其后面的指令语句和伪指令语句如何处理(类似C语言中的宏)。</li></ul><h2 id="x86指令语句语法"><a class="markdownIt-Anchor" href="#x86指令语句语法"></a> X86指令语句语法</h2><p>指令语句的一般格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">label:</span> op oprd1, oprd2··· <span class="hljs-comment">;注释</span><br></code></pre></td></tr></table></figure><p><strong>一条指令语句最多可以包含4个字段</strong>:<br /><b></p><ul><li>label(标号): 表明指令地址，一般用于程序跳转，由汇编器计算位移量</li><li>op(指令助记符): 即指令命令本身</li><li>oprd1···oprdn(操作数): 根据指令对操作数的要求，可选项</li><li>;(注释开始标志): <code>;</code>后的行内字符被汇编器忽略<br /></b></li></ul><p>X86具体指令见<a href="https://thm-lab.github.io/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">x86指令系统</a></p><h2 id="x86伪指令语句语法"><a class="markdownIt-Anchor" href="#x86伪指令语句语法"></a> X86伪指令语句语法</h2><p>伪指令语句的一般格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">label:</span> psdop oprd1, oprd2··· <span class="hljs-comment">;注释</span><br></code></pre></td></tr></table></figure><p><strong>一条伪指令语句最多可以包含4个字段</strong>:<br /><b></p><ul><li>label(标号): 表明指令地址，一般用于程序跳转，由汇编器计算位移量</li><li>pseudo op(伪指令符): 伪指令命令</li><li>oprd1···oprdn(操作数): 根据伪指令对操作数的要求，可选项</li><li>;(注释开始标志): <code>;</code>后的行内字符被汇编器忽略<br /></b></li></ul><h2 id="x86数据类型"><a class="markdownIt-Anchor" href="#x86数据类型"></a> X86数据类型</h2><p>X86汇编常用的数据形式有: <strong>常数、变量和标号</strong>，其中变量和标号均需要使用标识符进行命名。<br /><strong>一个数据由数值和属性(比如是字节数据还是字数据)两部分构成。</strong></p><h3 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h3><p>标识符命名规则:</p><ol><li>字符的个数为1~240个</li><li>可以用字母、数字、下划线及符号@、$和?</li><li>第一个字符不能是数字</li><li>不能使用系统专用的保留字(关键字key words)</li></ol><p><img src="keywords.png" alt="常见的保留字" /></p><h3 id="常数"><a class="markdownIt-Anchor" href="#常数"></a> 常数</h3><p><strong>常数</strong>: 经过汇编后其值已完全确定，并且在程序运行过程中，其值不会发生变化。<br /><strong>常数的表达方式</strong>:</p><ul><li>直接通过进制数表示: 如<code>12</code>(十进制)、<code>0101B</code>(二进制)、<code>A8H</code>(十六进制)等</li><li>实数: <code>2.134E +10</code>(±整数部分.小数部分E±指数部分)</li><li>字符串: <code>'ABC'=&gt;41H 42H 43H</code>(用单引号或双引号括起来的一个或多个字符，其值为这些字符的ASCII码值)</li></ul><p><strong>常数的使用场景</strong>:</p><ul><li>做指令的源操作数，是立即寻址</li><li>在指令语句的直接寻址、寄存器相对寻址或基址变址寻址方式中作位移量</li><li>在数据定义伪指令中作为初始化值</li></ul><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p><strong>变量</strong>: 用来表示存放数据的存储单元，这些数据在程序运行期间可以被改变。<br /><strong>程序中以变量名的形式来访问变量。变量名就是存放数据的存储单元地址。</strong><br />定义变量: 给变量在内存中分配一定的存储单元，也就是给<strong>这个存储单元赋与一个符号名</strong>——变量名，同时一般还要给分配的存储单元<strong>预置初值</strong>。<br />如C语言相同，变量被分为全局变量和局部变量。</p><ul><li>全局变量: 全局变量的作用域是整个程序，全局变量定义在<strong>数据段内</strong></li><li>局部变量: 通过伪指令使得变量的作用域限制在子过程中</li></ul><h4 id="变量的定义"><a class="markdownIt-Anchor" href="#变量的定义"></a> 变量的定义</h4><p><strong>全局变量:</strong><br />必须定义在数据段，定义格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.data</span><span class="hljs-comment">; 表明在数据段</span><br>data1 <span class="hljs-built_in">db</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span><span class="hljs-comment">; 字节类型变量，占据了2个字节</span><br>data2 <span class="hljs-built_in">dw</span> <span class="hljs-number">1</span><span class="hljs-comment">; 字类型变量，占据了2个字节</span><br>data3 <span class="hljs-built_in">dd</span> <span class="hljs-number">12</span>, <span class="hljs-number">321</span><span class="hljs-comment">; 双字类型变量，占据了8个字节</span><br>data4 <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ABCD&#x27;</span><span class="hljs-comment">; 字节类型变量，占据了4个字节</span><br>data5 <span class="hljs-built_in">dw</span> <span class="hljs-string">&#x27;AB&#x27;</span>, <span class="hljs-string">&#x27;CD&#x27;</span><span class="hljs-comment">; 字类型变量，占据了4个字节</span><br>data6 <span class="hljs-built_in">dd</span> <span class="hljs-string">&#x27;ABCD&#x27;</span><span class="hljs-comment">; 双字类型变量，占据4个字节</span><br><span class="hljs-meta">.data</span>?<span class="hljs-comment">; 数据段中未被初始化的变量定义在此</span><br>data <span class="hljs-built_in">db</span> <span class="hljs-number">10</span> dup(?)<span class="hljs-comment">; 字节类型变量，未特意初始化则为0</span><br></code></pre></td></tr></table></figure><p>全局变量的<strong>属性</strong>:</p><ul><li>段属性: 表明在哪个段中，<code>.data</code>和<code>.data?</code>表明在数据段</li><li>偏移量属性: 表明变量所在位置与段起始点之间的<strong>字节数</strong></li><li>类型属性: 表明变量占用存储单元的<strong>字节数</strong></li></ul><p><img src="type.png" alt="MASM常见可选类型属性" /><br /><strong>段属性和偏移量属性就构造了变量的逻辑地址。</strong></p><h5 id="特殊的初始化情况"><a class="markdownIt-Anchor" href="#特殊的初始化情况"></a> 特殊的初始化情况</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">string1 <span class="hljs-built_in">dw</span> <span class="hljs-string">&#x27;AB&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-comment">; 定义并初始化变量</span><br>string2 <span class="hljs-built_in">dd</span> <span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-string">&#x27;ABC&#x27;</span><span class="hljs-comment">; 定义并初始化变量</span><br>string3 df <span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-string">&#x27;ABC&#x27;</span><span class="hljs-comment">; 定义并初始化变量</span><br>string4 <span class="hljs-built_in">dq</span> <span class="hljs-string">&#x27;ABCD&#x27;</span>, <span class="hljs-string">&#x27;ABC&#x27;</span><span class="hljs-comment">; 定义并初始化变量</span><br></code></pre></td></tr></table></figure><p><strong>当使用字符串对dw、dd、df、dq类型变量赋初值时，高位字符放在高地址单元，地位字符放在低地址单元，不足时高位补零！并且对df、dq变量赋初值时，字符串不能超过4位(因为寄存器最大为32位)</strong></p><h5 id="dup初始化"><a class="markdownIt-Anchor" href="#dup初始化"></a> dup初始化</h5><p>dup称为重复数据操作符，一般用于变量批量初始化。<br />格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">variable type count dup(value)<span class="hljs-comment">; 通过dup定义变量</span><br></code></pre></td></tr></table></figure><ul><li>variable: 变量名</li><li>type: 变量类型</li><li>count: 重复的次数</li><li>value: 重复的内容，为<code>?</code>时等价于0</li></ul><p>通过dup可以将内存连续的空间赋值为一个特殊的值，通过dup嵌套可以为连续空间赋重复序列。<br />dup嵌套</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">10H</span> dup(<span class="hljs-number">4</span> DUP(<span class="hljs-number">2</span>),<span class="hljs-number">7</span>)<span class="hljs-comment">; 重复10H次的序列: 2, 2, 2, 2, 7</span><br></code></pre></td></tr></table></figure><p><strong>局部变量:</strong><br />通过local伪指令定义局部变量。<br />格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">local 变量名<span class="hljs-number">1</span>[重复数量]:类型,变量名<span class="hljs-number">2</span>[重复数量]:类型 ···<br>local var1[<span class="hljs-number">1024</span>]:<span class="hljs-built_in">byte</span><span class="hljs-comment">; 定义了一个1024字节长的局部变量var1</span><br>local var3, var4:<span class="hljs-built_in">byte</span><span class="hljs-comment">; 定义了dword型局部变量var3，byte型局部变量var4</span><br></code></pre></td></tr></table></figure><ul><li><code>local</code>语句要紧跟在过程定义<code>porc</code>语句之后</li><li>默认的类型是dword，因此定义dword类型的局部变量，则类型可以省略</li><li>当定义数组的时候，元素个数用<code>[]</code>括号括起来</li><li>局部变量不能和已定义的全局变量同名</li><li>局部变量的作用域是当前的子程序，所以在不同的子程序中可以有同名的局部变量</li><li>局部变量的初值是随机的，是其他子程序执行后在堆栈里留下的垃圾，所以使用时一定要对局部变量赋值</li></ul><h4 id="变量的使用"><a class="markdownIt-Anchor" href="#变量的使用"></a> 变量的使用</h4><p>变量一般有两种方式使用:</p><ol><li><strong>给dd和dq类型变量做初始化值</strong>，但不能给其他类型变量做初始化值(<strong>变量本质为32位偏移地址，dq为偏移地址和段地址</strong>)</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">20</span><span class="hljs-comment">;; 定义数据变量</span><br>add1 <span class="hljs-built_in">dd</span>, data<span class="hljs-comment">; data的偏移地址作为add1的初始化值</span><br>add2 <span class="hljs-built_in">dq</span>, data<span class="hljs-comment">; data的偏移地址和段地址组成64位地址作为add2的初始化值</span><br></code></pre></td></tr></table></figure><ol start="2"><li>作为地址给指令直接使用:<ul><li><strong>直接使用变量名: 做直接寻址的地址使用</strong></li></ul> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">2</span><span class="hljs-comment">; 定义数据变量</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 将data内的值与al内容相加送到al中</span><br></code></pre></td></tr></table></figure><ul><li><strong>寄存器相对寻址或基址变址相对寻址时，偏移地址作为基址</strong></li></ul> <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data1 <span class="hljs-built_in">db</span> <span class="hljs-number">10H</span>  DUP(?)<span class="hljs-comment">; 定义数据变量</span><br>data2 <span class="hljs-built_in">dw</span> <span class="hljs-number">10H</span>  DUP(<span class="hljs-number">1</span>)<span class="hljs-comment">; 定义数据变量</span><br><span class="hljs-keyword">mov</span> data1[<span class="hljs-built_in">esi</span>], <span class="hljs-built_in">al</span><span class="hljs-comment">; 将AL的内容送入从data1开始再偏移(ESI)的存储单元中</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>, data2[<span class="hljs-built_in">ebx</span>][<span class="hljs-built_in">edi</span>]<span class="hljs-comment">; 将从data2开始再偏移(EBX)+(EDI)的字存储单元的内容与DX的内容相加，结果送回DX中</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="标号"><a class="markdownIt-Anchor" href="#标号"></a> 标号</h3><p>标号加在一条指令的前面，它就是<strong>该指令在内存的存放地址的符号表示</strong>，<strong>也就是指令地址的别名</strong>。<br />标号主要用在程序中需要改变程序的执行顺序时，用来标记转移的目的地。<br />局部标号格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">buff <span class="hljs-built_in">db</span> <span class="hljs-number">100</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; 100字节的buff</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, buff<span class="hljs-comment">; 取得起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">24H</span><span class="hljs-comment">; 放入端口地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">100</span><span class="hljs-comment">; 设置循环次数</span><br><span class="hljs-symbol">next:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 从buff中取数据到al</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><span class="hljs-comment">; 输出到端口</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><span class="hljs-comment">; 地址自增</span><br><span class="hljs-keyword">loop</span> next<span class="hljs-comment">; 判断是否循环，若是跳回next</span><br></code></pre></td></tr></table></figure><p>全局标号格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">global_next:</span>: <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">;全局标号</span><br></code></pre></td></tr></table></figure><p><strong>标号属性</strong>:</p><ul><li>段属性: 表明在哪个段中，<code>.code</code>表明在代码段</li><li>偏移量属性: 表明变量所在位置与段起始点之间的<strong>字节数</strong></li><li>距离属性: 表明标号可以被段内还是段间的指令调用<ul><li><strong>near</strong>: <strong>只能作段内转移</strong>，即只能是与该标号所指指令同在一个逻辑段的其它指令才能使用它</li><li><strong>far</strong>: <strong>可以被非本段的转移和调用指令使用</strong></li></ul></li></ul><p>距离属性指定格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">label_name:</span> op ···<span class="hljs-comment">; 隐含方式，默认为near</span><br><span class="hljs-symbol">label_name label</span> type<span class="hljs-comment">; 指定标号属性</span><br>op<span class="hljs-comment">; 指令可以在全局标号下一行</span><br></code></pre></td></tr></table></figure><p><strong>label伪指令还可用来定义变量的属性，即改变一个变量的属性，如把字变量的高低字节作为字节变量来处理。</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">data_byte label</span> <span class="hljs-built_in">byte</span><span class="hljs-comment">;</span><br>data_word <span class="hljs-built_in">dw</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; 字类型变量</span><br></code></pre></td></tr></table></figure><p><strong>data_byte可以被用来存取一个字节数据而data_word不能</strong></p><h2 id="常用伪指令格式与表达式"><a class="markdownIt-Anchor" href="#常用伪指令格式与表达式"></a> 常用伪指令格式与表达式</h2><h3 id="comment"><a class="markdownIt-Anchor" href="#comment"></a> comment</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">comment 自定义符号: <br>多行内容<br>多行内容<br>多行内容<br>自定义符号<br></code></pre></td></tr></table></figure><p>功能: 实现块注释，<strong>块注释内部不能出现自定义的符号</strong></p><h3 id="dup"><a class="markdownIt-Anchor" href="#dup"></a> dup</h3><p>在<a href="#dup%E5%88%9D%E5%A7%8B%E5%8C%96">dup初始化</a>中有介绍</p><h3 id="label"><a class="markdownIt-Anchor" href="#label"></a> label</h3><p>在<a href="#%E6%A0%87%E5%8F%B7">标号</a>中有所应用</p><h3 id="equ"><a class="markdownIt-Anchor" href="#equ"></a> equ</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">name <span class="hljs-built_in">equ</span> expression<span class="hljs-comment">; 用符号名来表示EQU右边的表达式</span><br></code></pre></td></tr></table></figure><p>功能: 用符号名来表示equ右边的表达式。后面的程序中一旦出现该符号名，<strong>汇编程序</strong>将把它<strong>替换成</strong>该表达式。(类似C语言中的<code>define</code>，因此<strong>符号在内存中没有保存，而是直接作为立即数出现</strong>)<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">count <span class="hljs-built_in">equ</span> <span class="hljs-number">5</span><span class="hljs-comment">; 后面出现的count在汇编时全部会被替换为立即数5</span><br>add1 <span class="hljs-built_in">equ</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">ebp</span>+<span class="hljs-number">14</span>]<span class="hljs-comment">; add1被定义为在DS数据段中以BP作基址寻址的一个存储单元</span><br>str1 <span class="hljs-built_in">equ</span> <span class="hljs-string">&#x27;ABCD&#x27;</span><br>str2 <span class="hljs-built_in">db</span> str1<span class="hljs-comment">; str1为符号常量,str2为变量。</span><br>creg <span class="hljs-built_in">equ</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">; 在后面的程序使用CREG就是使用CX</span><br>my_add <span class="hljs-built_in">equ</span> <span class="hljs-keyword">add</span><span class="hljs-comment">; 将add指令使用my_add代替</span><br></code></pre></td></tr></table></figure><p><strong>符号名不能重复！</strong></p><h3 id="伪指令"><a class="markdownIt-Anchor" href="#伪指令"></a> =伪指令</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">name = expression<span class="hljs-comment">; 用符号名来表示=右边的表达式</span><br></code></pre></td></tr></table></figure><p><strong><code>=</code>伪指令与<code>equ</code>伪指令效果相同，区别在于<code>equ</code>可以给指令取别名而<code>=</code>不可以，<code>equ</code>不可以重复赋值而<code>=</code>可以</strong></p><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3><p>表达式是指令或伪指令语句操作数的常见形式。它由常数、变量、标号等通过操作运算符连接而成。<br /><strong>任何表达式的值在程序被汇编的过程中进行计算确定，而不是到程序运行时才计算。</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">num = <span class="hljs-number">15</span> * <span class="hljs-number">8</span><span class="hljs-comment">; num = 120</span><br>num = num / <span class="hljs-number">7</span><span class="hljs-comment">; nunm = 17(取整数部分)</span><br>num = num mod <span class="hljs-number">3</span><span class="hljs-comment">; num = 2</span><br>num = num + <span class="hljs-number">5</span><span class="hljs-comment">; num = 7</span><br>num = -num - <span class="hljs-number">3</span><span class="hljs-comment">; num = -10</span><br>num = -num - num<span class="hljs-comment">; num = 20</span><br>num = <span class="hljs-number">0</span><br>num = num[<span class="hljs-number">10</span>]<span class="hljs-comment">; num = 10(中括号视为加号)</span><br>num = <span class="hljs-number">11011011B</span><br>num = num <span class="hljs-keyword">shl</span> <span class="hljs-number">1</span><span class="hljs-comment">; num = 10110110B(左移伪指令)</span><br>num = num <span class="hljs-keyword">shr</span> <span class="hljs-number">1</span><span class="hljs-comment">; num = 01011011B(右移伪指令)</span><br>num = num <span class="hljs-keyword">and</span> <span class="hljs-number">00H</span><span class="hljs-comment">; num = 00H</span><br>num = num <span class="hljs-keyword">or</span> <span class="hljs-number">FFH</span><span class="hljs-comment">; num = FFH</span><br>num = num <span class="hljs-keyword">xor</span> num<span class="hljs-comment">; num = 00H</span><br>num = <span class="hljs-keyword">not</span> num<span class="hljs-comment">; num = FFH</span><br>num = <span class="hljs-number">10</span><br>result = num eq <span class="hljs-number">10</span><span class="hljs-comment">; result = 1(等于)</span><br>result = num ne <span class="hljs-number">10</span><span class="hljs-comment">; result = 0(不等)</span><br>result = num gt <span class="hljs-number">9</span><span class="hljs-comment">; result = 1(大于)</span><br>result = num lt <span class="hljs-number">11</span><span class="hljs-comment">; result = 1(小于)</span><br>result = num ge <span class="hljs-number">10</span><span class="hljs-comment">; result = 1(大于等于)</span><br>result = num le <span class="hljs-number">10</span><span class="hljs-comment">; result = 1(小于等于)</span><br></code></pre></td></tr></table></figure><h3 id="offset"><a class="markdownIt-Anchor" href="#offset"></a> offset</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">1</span><span class="hljs-comment">; 定义变量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span> offset data<span class="hljs-comment">; 取得data的偏移地址</span><br></code></pre></td></tr></table></figure><p>功能:<br /><strong>取变量或标号在段内的偏移地址</strong></p><h3 id="type"><a class="markdownIt-Anchor" href="#type"></a> type</h3><p>格式:<br />data dw 1; 定义字类型数据<br />label1: mov al type data; al = 2<br />mov bl, type label1; bl = -1<br />功能:<br /><strong>取变量或标号的类型属性，并用数字形式表示。对变量来说就是取它的字节长度。</strong><br /><img src="type_number.png" alt="对应关系" /></p><h4 id="lengthlengthofsizesizeof"><a class="markdownIt-Anchor" href="#lengthlengthofsizesizeof"></a> length/lengthof/size/sizeof</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">k1</span> <span class="hljs-built_in">dw</span> <span class="hljs-number">10H</span> dup(<span class="hljs-number">0</span>), <span class="hljs-number">20H</span><br><span class="hljs-built_in">k2</span> <span class="hljs-built_in">db</span> <span class="hljs-number">10H</span>, <span class="hljs-number">20H</span>, <span class="hljs-number">30H</span>, <span class="hljs-number">40H</span><br>   <span class="hljs-built_in">db</span> <span class="hljs-number">50H</span>, <span class="hljs-number">60H</span><br><span class="hljs-built_in">k3</span> <span class="hljs-built_in">dw</span> <span class="hljs-number">20H</span> dup(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> dup(<span class="hljs-number">0</span>))<br><span class="hljs-built_in">k4</span> <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ABCDEFGH&#x27;</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, length <span class="hljs-built_in">k1</span><span class="hljs-comment">; al = 10H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, size <span class="hljs-built_in">k1</span><span class="hljs-comment">; al = 20H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, lengthof <span class="hljs-built_in">k1</span><span class="hljs-comment">; ah = 11H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, sizeof <span class="hljs-built_in">k1</span><span class="hljs-comment">; ah = 22H</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, length <span class="hljs-built_in">k2</span><span class="hljs-comment">; bl = 1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, size <span class="hljs-built_in">k2</span><span class="hljs-comment">; bl = 1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>, lengthof <span class="hljs-built_in">k2</span><span class="hljs-comment">; bh = 4</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>, sizeof <span class="hljs-built_in">k2</span><span class="hljs-comment">; bh = 4</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, length <span class="hljs-built_in">k3</span><span class="hljs-comment">; bl = 20H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, size <span class="hljs-built_in">k3</span><span class="hljs-comment">; bl = 40H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>, lengthof <span class="hljs-built_in">k3</span><span class="hljs-comment">; bh = 4 * 20H =80H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>, sizeof <span class="hljs-built_in">k3</span><span class="hljs-comment">; bh = 4 * 20H * 2 =100H</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, length <span class="hljs-built_in">k4</span><span class="hljs-comment">; dl = 1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, szie <span class="hljs-built_in">k4</span><span class="hljs-comment">; dl = 1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, lengthof <span class="hljs-built_in">k4</span><span class="hljs-comment">; dh = 8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, sizeof <span class="hljs-built_in">k4</span><span class="hljs-comment">; dh = 8</span><br></code></pre></td></tr></table></figure><p>功能: <b></p><ul><li>length: 取DUP说明的重复次数，并且只取最外层DUP的重复次数。如果第一个初始值不是DUP说明，则LENGTH运算符返回值总是1。</li><li>lengthof: 取变量定义行中的初始值个数</li><li>size: size = length <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> type</li><li>sizeof: sizeof = lengthof <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> type<br /></b></li></ul><h3 id="ptr"><a class="markdownIt-Anchor" href="#ptr"></a> ptr</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">type <span class="hljs-built_in">ptr</span> address<span class="hljs-comment">; 修改地址的类型为type</span><br></code></pre></td></tr></table></figure><p>功能:<br /><strong>用来对变量、标号或存储器操作数的类型属性进行修改或指定</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; 定义字节类型变量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> data[<span class="hljs-number">10</span>]<span class="hljs-comment">; 按照字类型变量从data+10的偏移地址取得数据</span><br></code></pre></td></tr></table></figure><h3 id="highlow"><a class="markdownIt-Anchor" href="#highlow"></a> high/low</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">const <span class="hljs-built_in">equ</span> <span class="hljs-number">FF00H</span><span class="hljs-comment">; 符号名常量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, high const<span class="hljs-comment">; al = FFH</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, low const<span class="hljs-comment">; al = 00H</span><br></code></pre></td></tr></table></figure><p>功能:<br />取常数的最低8位和其后的8位。<br /><strong>注意: HIGH/LOW运算符不能用来分离一个变量、寄存器或存储器单元的内容。</strong><br />如:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ABCD&#x27;</span><span class="hljs-comment">; 定义字节类型变量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, high data<span class="hljs-comment">; 错误</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>, low <span class="hljs-built_in">ax</span><span class="hljs-comment">; 错误</span><br></code></pre></td></tr></table></figure><h3 id="运算符的优先级"><a class="markdownIt-Anchor" href="#运算符的优先级"></a> 运算符的优先级</h3><p><img src="priority.png" alt="运算符的优先级" /></p><h4 id="procendp"><a class="markdownIt-Anchor" href="#procendp"></a> proc/endp</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">process_name proc [距离][语言类型][可视区域][USES 寄存器列表][参数列表]<br>local 变量名<span class="hljs-number">1</span>[重复数量]:类型,变量名<span class="hljs-number">2</span>[重复数量]:类型 ···<br>op<br>·<br>·<br><span class="hljs-keyword">ret</span><span class="hljs-comment">; 恢复现场、弹出断点偏移地址到EIP</span><br>process_name endp<span class="hljs-comment">; 结束子过程</span><br></code></pre></td></tr></table></figure><ul><li>process_name: 是子程序的名称，用CALL指令或INVOKE伪指令来调用该过程</li><li>距离: 可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32</li><li>语言类型: 表示参数的进栈顺序和堆栈恢复的方式，可以是StdCall，C，SysCall，BASIC、FORTRAN和PASCAL，如果忽略，则使用程序头部 .model定义的值</li><li>可视区域: 可以是private、public和export，缺省时为public<ul><li>private:表示过程只对本模块可见</li><li>public: 表示对所有的模块可见</li><li>export: 表示是导出的函数，当编写DLL的时候要将某个函数导出的时候可以这样使用</li></ul></li><li>USES寄存器列表: 用于保存执行环境(自动push和pop保护现场)，寄存器间用空格分隔</li><li>参数列表: 用来定义过程使用的参数名和类型(参数1:类型,参数2:类型)<ul><li>若指定了参数，则过程要用invoke伪指令调用，否则应在CALL指令调用之前将参数按照规定的顺序压栈</li><li>若过程未指定参数则可用call指令，也可以用invoke调用</li><li>参数名不能与全局变量和过程中的局部变量重名</li></ul></li></ul><p>功能:<br /><strong>PROC和ENDP伪指令定义了过程开始和结束的位置， PROC后面跟的参数是过程的属性和输入参数。</strong></p><h3 id="invoke"><a class="markdownIt-Anchor" href="#invoke"></a> invoke</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">invoke function ,parm1, parm2···<span class="hljs-comment">; 调用API函数，根据API原型可带参数</span><br></code></pre></td></tr></table></figure><p>功能:<br />调用三方库或系统API</p><h3 id="伪指令与org"><a class="markdownIt-Anchor" href="#伪指令与org"></a> $伪指令与org</h3><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org expression<span class="hljs-comment">; $ = expression</span><br></code></pre></td></tr></table></figure><p>功能:<br />$: 表示&quot;位置计数器&quot;的当前值，也被称为当前位置计数器，即当前偏离段基址距离(32位)<br />org: <strong>将数值表达式的值赋给当前位置计数器$，ORG语句为其后的变量或指令设置起始偏移量，表达式的值必须为正值</strong><br />若运行环境为flat模式，则该伪指令并不能把一个具体的偏移值赋值赋给位置计算器，系统会自动为每个段指定一个起始偏移地址，数值表达式的值为相对该起始偏移地址。</p><h2 id="x86源程序框架"><a class="markdownIt-Anchor" href="#x86源程序框架"></a> X86源程序框架</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.386</span><span class="hljs-comment">; 指定允许的指令集</span><br><span class="hljs-meta">.model</span> flat,stdcall<span class="hljs-comment">; 设置内存模式和语言模式(Win32必须为stdcall)</span><br><span class="hljs-meta">option</span> casemap:none<span class="hljs-comment">; 设定程序中的变量、符号常量和过程名对大小写敏感，即区分大小写(Win32 API硬性要求)</span><br><span class="hljs-comment">; 一些include语句</span><br>include user32<span class="hljs-number">.</span><span class="hljs-keyword">inc</span><br>include kernel32<span class="hljs-number">.</span><span class="hljs-keyword">inc</span><br>includelib user32<span class="hljs-number">.</span>lib<br>includelib kernel32<span class="hljs-number">.</span>lib<br>comment @<br>include 导入库。类似.h文件<br>includelib 导入库，类似.c/.lib/.dll<br>@<br><span class="hljs-meta">.stack</span> [堆栈段的大小]<br><span class="hljs-meta">.data</span><br><span class="hljs-comment">; 一些初始化过的变量定义</span><br><span class="hljs-meta">.data</span>?<br><span class="hljs-comment">; 一些没有初始化过的变量定义</span><br><span class="hljs-meta">.const</span><br><span class="hljs-comment">; 一些常量定义</span><br><span class="hljs-meta">.code</span><br>main proc<br><span class="hljs-comment">; 其他语句</span><br>mian endp<br>end main<span class="hljs-comment">; 指明了程序开始的地址，也是程序结束的最后一句</span><br></code></pre></td></tr></table></figure><p>上述代码即Win32汇编语言源程序的<strong>一般框架</strong>，如C语言必须以main为入口函数般的模板。书写Win32汇编可按照该源程序框架进行改进。</p><h2 id="x86三方库irvine进行输入输出操作"><a class="markdownIt-Anchor" href="#x86三方库irvine进行输入输出操作"></a> X86三方库Irvine进行输入输出操作</h2><p>为实现各种IO设备的输入输出，Win32提供了非常丰富的API，它是Win32 Platform SDK中的一部分，覆盖了所有的输入输出功能，但使用上稍显繁琐。<br />CSUDH的Irvine教授在Win32 SDK的基础上，整理和编写了一个API库——Irvine32.LIB。<br />API详情见其<a href="https://csc.csudh.edu/mmccullough/asm/help/">官网API手册</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Assembly Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>X86指令系统</title>
    <link href="/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="x86指令系统"><a class="markdownIt-Anchor" href="#x86指令系统"></a> X86指令系统</h1><h2 id="x86-32位寻址方式"><a class="markdownIt-Anchor" href="#x86-32位寻址方式"></a> X86 32位寻址方式</h2><p>寻址方式主要在三方面上进行运用:</p><ul><li>操作数的寻址</li><li>转移地址的寻址</li><li>IO端口的寻址</li></ul><p>以下分别对X86指令的三方面寻址方式进行说明</p><h3 id="操作数寻址"><a class="markdownIt-Anchor" href="#操作数寻址"></a> 操作数寻址</h3><p>由冯诺依曼架构可以得到这样的结论: 操作数的来源只有三处:</p><ol><li>指令直接给出</li><li>存放在寄存器中</li><li>存放在内存单元中</li></ol><p>其中最简单的方式就是由指令直接给出，最复杂的则为存放在内存单元中，以下将分别说明不同的寻址方式！</p><h4 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h4><p>立即寻址即是<strong>由指令直接给出源操作数</strong>。<strong>立即寻址只能用于指令的源操作数！</strong><br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> <span class="hljs-number">1200H</span><span class="hljs-comment">; 将1200H这个数放如al中</span><br></code></pre></td></tr></table></figure><h4 id="寄存器直接寻址"><a class="markdownIt-Anchor" href="#寄存器直接寻址"></a> 寄存器(直接)寻址</h4><p>即操作数<strong>直接存放在寄存器中</strong>，处理器会直接从寄存器中拿取操作数。<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span> <span class="hljs-built_in">al</span><span class="hljs-comment">; 将al中的数移动到bl中</span><br></code></pre></td></tr></table></figure><h4 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h4><p><strong>操作数存放在内存之中</strong>，其<strong>偏移地址存放在寄存器之中</strong>，处理器先从寄存器中拿到偏移地址，再得到在内存之中的物理地址，再去该物理地址拿取操作数。<br />操作数的段基址取决于间址寄存器，若为EBP、ESP则默认在堆栈段，其他寄存器则为数据段。当然如果是flat模式则没有区别。<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">v1 <span class="hljs-built_in">dw</span> <span class="hljs-number">1024</span><span class="hljs-comment">; 定义字变量v1</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">ebx</span> v1<span class="hljs-comment">; 将v1的偏移地址取到ebx中，注意必须放置在32位寄存器中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 将ebx寄存器存储的内存单元的操作数取到ax中，中括号说明是寄存器间接寻址而非寄存器(直接)寻址，注意v1是dw类型变量，需要16位以上寄存器进行存放</span><br></code></pre></td></tr></table></figure><h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4><p>操作数<strong>存放在内存之中</strong>，偏移地址由变量表示。<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">v1 <span class="hljs-built_in">db</span> <span class="hljs-number">1</span><span class="hljs-comment">; 定义字节变量v1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> v1<span class="hljs-comment">; 将v1对应的偏移地址的数据传送到al中</span><br></code></pre></td></tr></table></figure><p>特别的，在X86保护模式下用户不能使用常数作为存储单元地址，若使用常数则视为立即寻址。<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> [<span class="hljs-number">1200H</span>]<span class="hljs-comment">; 等价于 mov al 1200H</span><br></code></pre></td></tr></table></figure><h4 id="寄存器相对寻址"><a class="markdownIt-Anchor" href="#寄存器相对寻址"></a> 寄存器相对寻址</h4><p>操作数<strong>存放在内存中</strong>，操作数的偏移地址为间址寄存器的内容加上一个位移量，位移量可以是一个常数，也可以是变量<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">dd</span> <span class="hljs-number">1</span><span class="hljs-comment">; 相对偏移量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>+data]<span class="hljs-comment">; 将ebx+data寄存器存储的内存单元的操作数移动到ax中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, data[<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]+data<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">5</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">5</span>[<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]+<span class="hljs-number">5</span><span class="hljs-comment">; 相同的含义不同的语句形式</span><br></code></pre></td></tr></table></figure><p><strong>Hint</strong>: <code>mov ax,[ebx]5</code>是错误的用法，<strong>当常数或变量在后面时，必须加加号，在前面可加可不加</strong></p><h4 id="基址-变址寻址"><a class="markdownIt-Anchor" href="#基址-变址寻址"></a> 基址-变址寻址</h4><p>操作数<strong>存放在内存中</strong>，操作数的偏移地址为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">基</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">容</mi><mo>+</mo><mi mathvariant="normal">变</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">容</mi><mo>×</mo><mi mathvariant="normal">比</mi><mi mathvariant="normal">例</mi><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="normal">位</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">量</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">基址寄存器的内容 + 变址寄存器的内容\times 比例 + (位移量)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">例</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span></span></span></span></span></p><p><img src="bias_formula.png" alt="公式" /><br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10</span>]+[<span class="hljs-built_in">edi</span>*<span class="hljs-number">8</span>]<span class="hljs-comment">; 将ebp内的内容+10+edi内容乘以8得到内存单元，再去该内存单元取得操作数</span><br></code></pre></td></tr></table></figure><h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4><p>指令中隐含了一个或两个操作数的地址，即<strong>操作数在默认的地址中</strong>。<br />例:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mul</span> <span class="hljs-built_in">bl</span><span class="hljs-comment">; 等价于 al * bl -&gt; ax</span><br></code></pre></td></tr></table></figure><h3 id="转移地址寻址"><a class="markdownIt-Anchor" href="#转移地址寻址"></a> 转移地址寻址</h3><p>转移地址一般分为两种寻址方式:</p><ul><li>直接寻址: 当前指令与目的地指令距离<strong>在-128~127字节</strong>内时，均采用<strong>立即寻址</strong>的方式，即将位移量(1B)放在指令中，形成<strong>2字节的jmp指令</strong></li><li>间接寻址: 当指令与目的地指令距离超过了短转移(-128~127字节)的限制时，位移量则为4B，形成<strong>5字节的jmp指令</strong></li></ul><h3 id="io端口寻址"><a class="markdownIt-Anchor" href="#io端口寻址"></a> IO端口寻址</h3><p>IO端口寻址也分为两种寻址方式:</p><ul><li>直接寻址: 端口地址为8位时(可寻址256个端口)，指令中的PORT直接由一个8位无符号常数提供，是立即寻址变体<br />例:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> acc, port<span class="hljs-comment">; acc是al/ax/eax，port为端口地址</span><br><span class="hljs-keyword">out</span> port, acc<span class="hljs-comment">; 立即寻址操作数不能为目的操作数，但在这里可以，所以为变体</span><br></code></pre></td></tr></table></figure><ul><li>间接寻址: 当端口地址超过255时，地址码为16位(可寻址64K个端口)，<strong>指令中的端口地址必须由DX指定(不能使用EDX指定)</strong>，其中端口地址为0~255时也可使用间接寻址<br />例:</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">132</span><span class="hljs-comment">; 端口地址为132</span><br><span class="hljs-keyword">in</span> acc, <span class="hljs-built_in">dx</span><span class="hljs-comment">; acc是al/ax/eax，从132端口取数据到acc中</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, acc<span class="hljs-comment">; acc是al/ax/eax，将acc中数据输出到132端口</span><br></code></pre></td></tr></table></figure><h2 id="x86指令"><a class="markdownIt-Anchor" href="#x86指令"></a> X86指令</h2><p>学习汇编指令主要从五个角度出发:<br /><b></p><ul><li>指令格式</li><li>指令功能</li><li>对操作数的要求</li><li>指令对操作数的影响</li><li>指令对标志位的影响<br /></b></li></ul><p>在下面六大类的每条指令中均会说明该五个角度，并且需要记忆！</p><h3 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h3><p>数据传送指令一般对标志位无影响</p><h4 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> mov</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> dest, src<br></code></pre></td></tr></table></figure><p>功能:<br />将src的操作数送到dest内<br />操作数要求:</p><ol><li>两操作数长度必须相同</li><li>存储单元之间不能直接传送(可以用串操作指令实现直接传送)</li><li>段寄存器CS只能作源操作数，段寄存器之间不能直接传送</li><li>在源操作数是立即数时，目标操作数不能是段寄存器</li><li>标志寄存器(EFLAGS或FLAGS)一般不作为操作数在指令中出现</li></ol><p><img src="mov.png" alt="mov操作数要求" /><br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="movzxmovsx"><a class="markdownIt-Anchor" href="#movzxmovsx"></a> movzx/movsx</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">movzx</span> reg32, reg8/mem8<br><span class="hljs-keyword">movzx</span> reg32, reg16/mem16<br><span class="hljs-keyword">movzx</span> reg16, reg8/mem8<br><span class="hljs-keyword">movsx</span> reg32, reg8/mem8<br><span class="hljs-keyword">movsx</span> reg32, reg16/mem16<br><span class="hljs-keyword">movsx</span> reg16, reg8/mem8<br></code></pre></td></tr></table></figure><p>功能:<br />将位数短的操作数传到较长的寄存器，并进行<strong>0扩展(movzx)<strong>或</strong>符号扩展(movsx)</strong><br />操作数要求:</p><ol><li>源操作数位数要小于目的操作数长度</li><li>目的操作数必须为寄存器<br />对操作数影响:<br />源操作数无影响，目的操作数变为源操作数的0扩展或符号扩展<br />对标志位影响:<br />无影响</li></ol><h4 id="pushpoppushapushdpopapopdpushfdpopfd"><a class="markdownIt-Anchor" href="#pushpoppushapushdpopapopdpushfdpopfd"></a> push/pop/pusha/pushd/popa/popd/pushfd/popfd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">ABCDH</span><span class="hljs-comment">; 将16位立即数入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">ABCD0000H</span><span class="hljs-comment">; 将32位立即数入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">; 将ax内容入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span>[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">; 将bx内容的存储字单元入栈</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">; 将出栈值放入ax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span>[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">; 将出栈值放入bx内容的存储字单元</span><br><span class="hljs-keyword">pusha</span><span class="hljs-comment">; 将8个16位通用寄存器按AX、CX、DX、BX、SP、BP、SI与DI的顺序入栈</span><br><span class="hljs-keyword">popa</span><span class="hljs-comment">; 从栈顶弹出8个字数据分别送入DI、SI、BP、SP、BX、DX、CX与AX</span><br>pushd<span class="hljs-comment">; 将8个32位通用寄存器按EAX、ECX、EDX、EBX、ESP、EBP、ESI与EDI的顺序入栈</span><br>popd<span class="hljs-comment">; 从栈顶弹出8个双字数据分别送入EDI、ESI、EBP、ESP、EBX、EDX、ECX与EAX</span><br><span class="hljs-keyword">pushfd</span><span class="hljs-comment">; EFLAGS进栈</span><br><span class="hljs-keyword">popfd</span><span class="hljs-comment">; 出栈送到EFLAGS</span><br></code></pre></td></tr></table></figure><p>功能:<br />push/pop: 将16位数据入栈或出战<br />pusha/popa: 将8个16位通用寄存器按AX、CX、DX、BX、SP、BP、SI与DI的顺序入栈和从栈顶弹出8个字数据分别送入DI、SI、BP、SP、BX、DX、CX与AX<br />pushd/popd: 将8个32位通用寄存器按EAX、ECX、EDX、EBX、ESP、EBP、ESI与EDI的顺序入栈和从栈顶弹出8个双字数据分别送入EDI、ESI、EBP、ESP、EBX、EDX、ECX与EAX<br />pushfd/popfd: 32位标志寄存器EFLAGS进栈/出栈指令<br />操作数要求:<br /><strong>若为存储器操作数，需要声明为字存储单元(PTR)</strong><br />对操作数影响:<br />对标志位影响:<br />对标志位无影响，但会影响SP内的值<br />push: SP变为SP-2<br />pop: SP变为SP+2</p><h4 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> xchg</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">xchg</span> reg/mem, mem/reg<br></code></pre></td></tr></table></figure><p>功能:<br />交换寄存器和内存单元的值<br />操作数要求:</p><ol><li>必须有一个操作数是寄存器操作数</li><li>不允许使用段寄存器<br />对操作数影响:<br />源操作数变为目的操作数，目的操作数变为源操作数<br />对标志位影响:<br />无影响</li></ol><h4 id="inout"><a class="markdownIt-Anchor" href="#inout"></a> in/out</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> acc, port<span class="hljs-comment">; 将端口数据传送到acc中</span><br><span class="hljs-keyword">out</span> port, acc<span class="hljs-comment">; 将acc中数据传送到端口中</span><br></code></pre></td></tr></table></figure><p>功能:<br />对IO端口进行输入和输出<br />操作数要求:<br />port在0~255时可以是立即数，也可以是dx，port大于255时必须是dx<br />acc可以是al、ax或eax，但不能是其他寄存器<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> lea</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lea</span> reg, mem<br></code></pre></td></tr></table></figure><p>功能:<br />将一个存储单元的32位(保护模式)偏移地址取出送目标寄存器<br />操作数要求:</p><ol><li>源操作数必须为存储单元操作数</li><li>目的操作数必须为16位或32位寄存器操作数<br />对操作数影响:<br />若目的操作数为32位寄存器操作数，目的操作数变为源操作数的偏移地址，若目的操作数为16位寄存器操作数，目的操作数变为源操作数的偏移地址的低16位<br />对标志位影响:<br />无影响</li></ol><h4 id="lahfsahf"><a class="markdownIt-Anchor" href="#lahfsahf"></a> lahf/sahf</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lahf</span><span class="hljs-comment">; 将FLAGS的低8位装入AH</span><br><span class="hljs-keyword">sahf</span><span class="hljs-comment">; 将AH装入FLAGS的低8位</span><br></code></pre></td></tr></table></figure><p>功能:<br />lahf: 将FLAGS的低8位装入AH<br />sahf: 将AH装入FLAGS的低8位<br />操作数要求:<br />无要求，因为是隐含地址<br />对操作数影响:<br />lahf: AH内容变为FLAGS的低8位<br />sahf: FLAGS低8位变为AH内容<br />对标志位影响:<br />lahf: 无影响<br />sahf: 标志位低8位涉及到的标志位变为AH内容对应位</p><h3 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h3><p>算术运算指令的执行大多对状态标志位会产生影响，对标志位的影响是算术运算指令的应用思路之一。</p><h4 id="addadcinc"><a class="markdownIt-Anchor" href="#addadcinc"></a> add/adc/inc</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">add</span> oprd1, oprd2<span class="hljs-comment">; oprd1+oprd2送到oprd1内</span><br><span class="hljs-keyword">adc</span> oprd1, oprd2<span class="hljs-comment">; oprd1+oprd2+CF送到oprd1内</span><br><span class="hljs-keyword">inc</span> oprd<span class="hljs-comment">; oprd自增1</span><br></code></pre></td></tr></table></figure><p>功能:<br />add: 将oprd1与oprd2相加送到oprd1中<br />adc: 将oprd1与oprd2相加再加上CF标志位送到oprd1中。<strong>adc指令常用于多字节数相加，使用前要先将CF清零。</strong><br />inc: oprd自增1<br />操作数要求:<br />add/adc: 与<a href="#mov">mov指令</a>基本相同<br />inc:</p><ol><li>不能是立即数</li><li>不能是段寄存器<br />对操作数影响:<br />add/adc: oprd1变为oprd1+oprd2+(CF)，oprd2无影响<br />inc: oprd自增1<br />对标志位影响:<br />add/adc: 对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)<br />inc: <strong>不影响CF</strong>，其他5个状态标志位仍然受到影响</li></ol><p><strong>adc实现多字节数相加示例</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">m1 <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; m1是20个字节的大数</span><br>m2 <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">2</span>)<span class="hljs-comment">; m2是20个字节的大数</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span> m1<span class="hljs-comment">; 取得m1起始地址</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span> m2<span class="hljs-comment">; 取得m2起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span> <span class="hljs-number">20</span><span class="hljs-comment">; 大数字节数作为循环加法数</span><br><span class="hljs-keyword">clc</span><span class="hljs-comment">; 清空CF</span><br><span class="hljs-symbol">next:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将esi的数取到al中，因为adc不能直接用于两个存储器操作数之间</span><br><span class="hljs-keyword">adc</span> [<span class="hljs-built_in">edi</span>], <span class="hljs-built_in">al</span><span class="hljs-comment">; 带CF的相加</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><span class="hljs-comment">; 相加指针移动</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span><span class="hljs-comment">; 相加指针移动</span><br><span class="hljs-keyword">dec</span> <span class="hljs-built_in">cl</span><span class="hljs-comment">; 剩余未加字节数减少</span><br><span class="hljs-keyword">jnz</span> next<span class="hljs-comment">; 判断是否相加完成</span><br></code></pre></td></tr></table></figure><h4 id="subsbbdec"><a class="markdownIt-Anchor" href="#subsbbdec"></a> sub/sbb/dec</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> oprd1, oprd2<span class="hljs-comment">; oprd1-oprd2送到oprd1内</span><br><span class="hljs-keyword">sbb</span> oprd1, oprd2<span class="hljs-comment">; oprd1-oprd2-CF送到oprd1内</span><br><span class="hljs-keyword">dec</span> oprd<span class="hljs-comment">; oprd自减1 </span><br></code></pre></td></tr></table></figure><p>功能:<br />sub: 将oprd1与oprd2相减送到oprd1中<br />sbb: 将oprd1与oprd2相减再减去CF标志位送到oprd1中。<br />inc: oprd自减1<br />操作数要求:<br />sub/sbb: 与<a href="#mov">mov指令</a>基本相同<br />dec:</p><ol><li>不能是立即数</li><li>不能是段寄存器<br />对操作数影响:<br />sub/sbb: oprd1变为oprd1-oprd2-(CF)，oprd2无影响<br />inc: oprd自增1<br />对标志位影响:<br />sub/sbb: 对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)<br />dec: <strong>不影响CF</strong>，其他5个状态标志位仍然受到影响</li></ol><h4 id="neg"><a class="markdownIt-Anchor" href="#neg"></a> neg</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">neg</span> oprd<span class="hljs-comment">; 0-oprd送oprd内</span><br></code></pre></td></tr></table></figure><p>功能:<br />用0减去操作数，相当于对该操作数求补，但不是补码。<br />操作数要求:<br />必须是寄存器操作数(8位、16位、32位均可)或存储器操作数<br />对操作数影响:<br />oprd变为0 - oprd<br />对标志位影响:<br />6个标志位(AF、PF、CF、OF、ZF、SF)都会被影响<br />对CF的影响:</p><ol><li>oprd为0时，CF=0</li><li>oprd不为0时，CF=1</li></ol><p>对OF的影响:<br />当字节操作数为-128(80H)，或字操作数为-32768(8000H)或双字操作数为80000000H时，结果将无变化，但溢出标志OF被置1</p><h4 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> cmp</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cmp</span> oprd1, oprd<span class="hljs-comment">; 执行oprd1-oprd2，但不送任何单元</span><br></code></pre></td></tr></table></figure><p>功能:<br />用于比较两个数的大小，可作为条件转移指令转移的条件<br />操作数要求:<br />与<a href="#mov">mov指令</a>基本相同<br />对操作数影响:<br />无影响<br />对标志位影响:<br />对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)</p><p><strong>cmp指令对标志位的影响主要通过CF、ZF、OF、SF四个标志位来判断两个数的大小</strong><br /><b></p><ul><li>无符号数比较:<ol><li>oprd1 &gt; oprd2: CF = 0 &amp; ZF = 0</li><li>oprd1 = oprd2: ZF = 1</li><li>oprd1 &lt; oprd2: CF = 1 &amp; ZF = 0</li></ol></li><li>带符号数比较:<ol><li>oprd1 &gt; oprd2: OF = SF &amp; ZF = 0(为正数时，OF与SF相等表示结果仍为正数，说明oprd1大;为负数时，SF为1时结果为负数，OF为1表示结果溢出，oprd1大，SF为0时结果为正数，OF为0表示不溢出，说明oprd2的绝对值大，负数小)</li><li>oprd1 = oprd2: ZF = 1</li><li>oprd1 &lt; oprd2: OF <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> SF &amp; ZF = 0(与oprd1 &gt; oprd2结论相反，除了ZF = 0)</li></ol></li></ul><p>也可通过直接的跳转指令实现根据两数大小的跳转:</p><ol><li>无符号数比较跳转:<ul><li>ja/jae: ja为当oprd1&gt;oprd2时跳转，jae为当oprd1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd2时跳转</li><li>jb/jbe: jb为当oprd2&gt;oprd1时跳转，jbe为当oprd2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd1时跳转</li></ul></li><li>带符号数比较跳转:<ul><li>jg/jge: jg为当oprd1&gt;oprd2时跳转，jge为当oprd1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd2时跳转</li><li>jl/jle: jl为当oprd2&gt;oprd1时跳转，jle为当oprd2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd1时跳转<br /></b></li></ul></li></ol><p><strong>cmp实现20个无符号数寻找最大值示例</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">max <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><span class="hljs-comment">; 定义存储最大值变量单元</span><br>buff <span class="hljs-built_in">db</span> <span class="hljs-number">5</span> dup(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">; 20个无符号数</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, max<span class="hljs-comment">; 取得max的偏移地址，便于后面存储最大值</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, buff<span class="hljs-comment">; 取得20个数的起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">20</span>-<span class="hljs-number">1</span><span class="hljs-comment">; 20个数只需要比较19次</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 取出第一个数到寄存器中</span><br><span class="hljs-symbol">next:</span> <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><span class="hljs-comment">; 循环的开始，需要比较指针自增</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 比较已取出的数与下一个数的大小</span><br><span class="hljs-keyword">jnc</span> goon<span class="hljs-comment">; 如果al比较大就跳转到goon里面直接进行比较指针的移动</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; al比较小，更新al</span><br><span class="hljs-symbol">goon:</span> <span class="hljs-keyword">dec</span> <span class="hljs-built_in">cl</span><span class="hljs-comment">; cl减1，比较完成</span><br><span class="hljs-keyword">jnz</span> next<span class="hljs-comment">; 重新比较流程，如果比较次数完成则直接将al内的最大值放入max中</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edi</span>], <span class="hljs-built_in">al</span><span class="hljs-comment">; 将al内的最大值放入max中</span><br></code></pre></td></tr></table></figure><h4 id="mulimul"><a class="markdownIt-Anchor" href="#mulimul"></a> mul/imul</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mul</span> oprd<span class="hljs-comment">; 无符号数的乘法，使用隐含寻址al、ax、eax，将隐含寻址的值*oprd送到ax、dx:ax、edx:eax中</span><br><span class="hljs-keyword">imul</span> oprd<span class="hljs-comment">; 与mul相同，但操作数被视为带符号数</span><br><span class="hljs-keyword">imul</span> dest, src<span class="hljs-comment">; src乘以dest送到dest中</span><br></code></pre></td></tr></table></figure><p>功能:<br />mul/imul: 将隐含寻址的值乘以oprd倍送到扩展寄存器中(结果为64位时，由edx:eax构成64位寄存器)<br />imul: 将src<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>dest的结果送到dest中，若结果超过目的寄存器位数则截断高位<br />操作数要求:<br />mul/imul: 隐含寻址时，操作数只能是寄存器操作数或存储器操作数<br />imul: 可以是寄存器操作数或存储器操作数或<strong>比目的操作数位数少的立即数</strong><br />对操作数影响:<br />mul/imul: 对oprd无影响，隐含寻址操作数变为乘积的低位<br />imul: dest操作数变为src*dest的结果的低位<br />imul:<br /><b>对标志位影响:<br />mul: 只对CF和OF产生影响，若高位寄存器(即AH、DX、EDX)为全0则CF=OF=0，否则CF=OF=1<br />imul: 只对CF和OF产生影响，隐含寻址时，若高位寄存器(即AH、DX、EDX)全为低位的符号位扩展则CF=OF=0，否则CF=OF=1<br />imul: 只对CF和OF产生影响，如果存放结果的目的寄存器中丢弃了乘积高位的有效数值则CF=OF=1，否则CF=OF=0</b></p><h4 id="dividiv"><a class="markdownIt-Anchor" href="#dividiv"></a> div/idiv</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">div</span> reg/mem8<br><span class="hljs-keyword">div</span> reg/mem16<br><span class="hljs-keyword">div</span> reg/mem32<br><span class="hljs-keyword">idiv</span> reg/mem8<br><span class="hljs-keyword">idiv</span> reg/mem16<br><span class="hljs-keyword">idiv</span> reg/mem32<br></code></pre></td></tr></table></figure><p>功能:<br />将隐含寻址的目的操作数除以源操作数的倍数，结果放入隐含寻址的操作数中<br />操作数要求:<br />指令要求被除数是除数的双倍字长，因此除法指令常与扩展指令CBW、CWD、CDQ配合使用。<br /><img src="div.png" alt="div操作数要求" /><br />对操作数影响:<br />源操作数无影响，目的操作数按上图所示变化<br />对标志位影响:<br />无影响</p><h4 id="cbwcwdcdq"><a class="markdownIt-Anchor" href="#cbwcwdcdq"></a> cbw/cwd/cdq</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cbw</span><span class="hljs-comment">; 隐含寻址，将AL的符号位扩展到AH</span><br><span class="hljs-keyword">cwd</span><span class="hljs-comment">; 隐含寻址，将AX的符号位扩展到DX</span><br><span class="hljs-keyword">cdq</span><span class="hljs-comment">; 隐含寻址，将EAX的符号位扩展到EDX</span><br></code></pre></td></tr></table></figure><p>功能:<br />扩展源操作数的符号位到指定位置<br />操作数要求:<br />必须在隐含寻址的寄存器内<br />对操作数影响:<br />源操作数无影响，目的操作数变为源操作数的符号位扩展<br />对标志位影响:<br />无影响</p><h4 id="bcd码校正指令daaaaadasaasaamaad"><a class="markdownIt-Anchor" href="#bcd码校正指令daaaaadasaasaamaad"></a> BCD码校正指令(daa/aaa/das/aas/aam/aad)</h4><p><em>不要求掌握，了解即可。</em><br />在X86系统中，BCD码可以有两种表示方式:</p><ul><li>压缩型: 一个字节表示两个BCD码，即两位十进制数。<strong>每4位表示1个十进制数</strong>。</li><li>非压缩型: 一个字节的<strong>低四位表示一个BCD码</strong>，而高四位对所表示的十进制数<strong>没有影响</strong>，常为0000或0011。</li></ul><p>BCD码处理指令: 先用二进制数的加、减、乘、除运算指令对BCD码运算，再用BCD码校正指令对结果校正。<br /><img src="bcd.png" alt="BCD码校正指令" /></p><h3 id="位操作指令"><a class="markdownIt-Anchor" href="#位操作指令"></a> 位操作指令</h3><p>位操作大多数时候也是一种算术运算，如乘法在一定程度上可以视为左移，除法在一定程度上可以用右移操作今天代替。同时位操作往往也会导致标志位的变化，同时某些<strong>特殊的位操作目的是对特定的标志位操作</strong>。</p><h4 id="and"><a class="markdownIt-Anchor" href="#and"></a> and</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> oprd1, oprd2<span class="hljs-comment">; oprd1和oprd2按位&amp;，结果送oprd1</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现两操作数按位相与的运算，<strong>使目标操作数的某些位不变，某些位清零</strong><br />操作数要求:<br />与<a href="#mov">mov指令</a>相同<br />对操作数影响:<br />源操作数无影响，目的操作数变为按位与的结果<br />对标志位影响:<br />CF=OF=0，其余状态位根据结果产生</p><p><strong>判断某些位是否为0</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">1</span><span class="hljs-comment">; 定义测试变量</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, data<span class="hljs-comment">; 取得测试变量偏移地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">01H</span><span class="hljs-comment">; 构造测试位为1，其余位为0的数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 测试变量与测试数据按位与</span><br><span class="hljs-keyword">jz</span> bit1<span class="hljs-comment">; 如果结果全0说明测试位为0</span><br></code></pre></td></tr></table></figure><p><strong>将CF和OF清零</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">; 自身按位与不改变操作数，且能将CF和OF清零</span><br></code></pre></td></tr></table></figure><h4 id="or"><a class="markdownIt-Anchor" href="#or"></a> or</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">or</span> oprd1, oprd2<span class="hljs-comment">; oprd1和oprd2按位|，结果送oprd1</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现两操作数按位相或的运算，<strong>使目标操作数的某些位不变，某些位置1</strong><br />操作数要求:<br />与<a href="#mov">mov指令</a>相同<br />对操作数影响:<br />源操作数无影响，目的操作数变为按位或的结果<br />对标志位影响:<br />CF=OF=0，其余状态位根据结果产生</p><p><strong>将CF和OF清零</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">; 自身按位或不改变操作数，且能将CF和OF清零</span><br></code></pre></td></tr></table></figure><h4 id="not"><a class="markdownIt-Anchor" href="#not"></a> not</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">not</span> oprd<span class="hljs-comment">; 将操作数按位取反再送回原地址</span><br></code></pre></td></tr></table></figure><p>功能:<br />将操作数按位取反<br />操作数要求:</p><ol><li>不能为立即数</li><li>操作数为存储器操作数时需要说明数据类型(db、dw、dd)<br />对操作数影响:<br />操作数变为按位取反的结果<br />对标志位影响:<br />无影响</li></ol><h4 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> xor</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">xor</span> oprd1, oprd2<span class="hljs-comment">; 两操作数按位相异或，结果送目标地址</span><br></code></pre></td></tr></table></figure><p>功能:<br />两操作数按位相异或，结果送目标地址，<strong>xor有个很重要的属性: 自身相异或结果为0，经常用以判断数据是否为预期数据</strong><br />操作数要求:<br />与<a href="#mov">mov指令</a>相同<br />对操作数影响:<br />源操作数无影响，目的操作数变为两操作数按位相异或结果<br />对标志位影响:<br />CF=OF=0，其余状态位根据结果产生</p><p><strong>属性应用:</strong><br />与test例相同，需要判断bit1、bit3、bit5是否为均1，用xor指令十分优雅但会改变数据</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 去除其他位的影响</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 如果为数据bit1、bit3、bit5均为1，则与2AH(自身)异或结果为0，只需要判断ZF是否为1即可得知al的几位数据</span><br></code></pre></td></tr></table></figure><p><strong>还有一种在不改变数据的情况下能一次性比较多位的方式: cmp指令</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 去除其他位的影响</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; cmp指令通过al-2AH的方式来判断ZF，并且结果并不会送回到al中，因此不改变数据同样能够得到ZF标志位来进行判断</span><br><br>#### <span class="hljs-keyword">test</span><br>格式: <br><span class="hljs-string">```</span> x86asm<br><span class="hljs-keyword">test</span> oprd1, oprd2<span class="hljs-comment">; 执行与运算，运算的结果影响标志位，但不送回目标地址</span><br></code></pre></td></tr></table></figure><p>功能:<br />判断两操作数按位与结果对标志位的影响<br />操作数要求:<br />与<a href="#mov">mov指令</a>相同<br />对操作数影响:<br />无影响<br />对标志位影响:<br />CF=OF=0，其余状态位根据结果产生</p><p><strong>可跟and指令一样判断某些位数据，并且不影响测试数据，因此可用来判断多位且不影响数据</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">test</span>  <span class="hljs-built_in">al</span>，<span class="hljs-number">02H</span><span class="hljs-comment">; 判断bit1</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">08H</span><span class="hljs-comment">; 判断bit3</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">20H</span><span class="hljs-comment">; 判断bit5</span><br></code></pre></td></tr></table></figure><h4 id="salshl"><a class="markdownIt-Anchor" href="#salshl"></a> sal/shl</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sal</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1左移oprd2位</span><br><span class="hljs-keyword">shl</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1左移oprd2位</span><br></code></pre></td></tr></table></figure><p>功能:<br /><strong>sal与shl在机器指令执行时为同一条指令</strong>，将oprd1左移oprd2位，区别在于sal将操作数视为无符号数，shl将操作数视为带符号数<br />操作数要求:<br /><strong>oprd2必须是8位立即数或CL寄存器内容</strong><br />对操作数影响:<br />oprd1变为左移后的结果，oprd2无影响<br />对标志位影响:<br />影响标志位OF、SF、ZF、PF、CF</p><p><strong>左移在二进制操作中可视为特殊乘法</strong>: 左移n位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇔</mo><mi>o</mi><mi>p</mi><mi>r</mi><mi>d</mi><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Leftrightarrow oprd1 \times 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p><h4 id="sarshr"><a class="markdownIt-Anchor" href="#sarshr"></a> sar/shr</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sar</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1右移oprd2位</span><br><span class="hljs-keyword">shr</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1右移oprd2位</span><br></code></pre></td></tr></table></figure><p>功能:<br /><strong>sar与shr并不相同，sar高位补零，shr高位补符号位</strong>，将oprd1右移oprd2位，区别在于sar将操作数视为无符号数，shr将操作数视为带符号数<br />操作数要求:<br /><strong>oprd2必须是8位立即数或CL寄存器内容</strong><br />对操作数影响:<br />oprd1变为右移后的结果，oprd2无影响<br />对标志位影响:<br />影响标志位OF、SF、ZF、PF、CF</p><p><strong>右移在二进制操作中可视为特殊除法</strong>: 右移n位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇔</mo><mi>o</mi><mi>p</mi><mi>r</mi><mi>d</mi><mn>1</mn><mo>÷</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Leftrightarrow oprd1 \div 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p><h4 id="rolrcl"><a class="markdownIt-Anchor" href="#rolrcl"></a> rol/rcl</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">rol</span> oprd1, oprd2<span class="hljs-comment">; 不带CF的循环左移位oprd2位</span><br><span class="hljs-keyword">rcl</span> oprd1, oprd2<span class="hljs-comment">; 带CF的循环移左位oprd2位</span><br></code></pre></td></tr></table></figure><p>功能:<br />循环左移oprd2位，并将结果放入oprd1中<br />操作数要求:<br />与<a href="#salshl">sal/shl</a>相同<br />对操作数影响:<br />oprd1变为循环移位后的结果，oprd2无影响<br />对标志位影响:<br /><strong>影响标志位CF(rol无影响)、OF(若移位位数为1次，且移位前后目的操作数的最高位发生变化，那么OF置1，否则OF清零。若移位位数大于1，那么OF不确定)。其他标志位无影响</strong></p><h4 id="rorrcr"><a class="markdownIt-Anchor" href="#rorrcr"></a> ror/rcr</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ror</span> oprd1, oprd2<span class="hljs-comment">; 不带CF的循环右移位oprd2位</span><br><span class="hljs-keyword">rcr</span> oprd1, oprd2<span class="hljs-comment">; 带CF的循环移右位oprd2位</span><br></code></pre></td></tr></table></figure><p>功能:<br />循环右移oprd2位，并将结果放入oprd1中<br />操作数要求:<br />与<a href="#salshl">sal/shl</a>相同<br />对操作数影响:<br />oprd1变为循环移位后的结果，oprd2无影响<br />对标志位影响:<br /><strong>影响标志位CF(rol无影响)、OF(若移位位数为1次，且移位前后目的操作数的最高位发生变化，那么OF置1，否则OF清零。若移位位数大于1，那么OF不确定)。其他标志位无影响</strong></p><p>通过带CF的循环移位可以实现多字节单元数据联合移位(如<a href="#addadcinc">adc大数加法一般</a>)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">M <span class="hljs-built_in">dw</span> <span class="hljs-number">3</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; 定义变量</span><br><span class="hljs-keyword">sal</span> M, <span class="hljs-number">1</span><span class="hljs-comment">; 低字节移位到CF</span><br><span class="hljs-keyword">rcl</span> M+<span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 带CF循环移位</span><br><span class="hljs-keyword">rcl</span> M+<span class="hljs-number">4</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 带CF循环移位</span><br></code></pre></td></tr></table></figure><p><img src="big_shift.png" alt="多字节单元数据联合移位" /></p><h4 id="shldshrd"><a class="markdownIt-Anchor" href="#shldshrd"></a> shld/shrd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">shld</span> dest, src, count<span class="hljs-comment">; 将目的操作数dest向左移动指定位数，移动形成的空位由源操作数source的高位填充，指令执行后source保持不变</span><br><span class="hljs-keyword">shrd</span> dest, src, count<span class="hljs-comment">; 将目的操作数dest向右移动指定位数，移动形成的空位由源操作数source的低位填充，指令执行后source保持不变</span><br></code></pre></td></tr></table></figure><p>功能:<br />双精度移位操作，移位时以一定数据进行填充空位而非固定0或1<br />操作数要求:<br />与<a href="#salshl">sal/shl</a>相同<br />对操作数影响:<br />src无影响，dest变为移位后结果<br />对标志位影响:<br />会影响SF、ZF、AF、PF、CF</p><h3 id="串操作指令"><a class="markdownIt-Anchor" href="#串操作指令"></a> 串操作指令</h3><p>串操作是针对数据块或字符串的操作，可实现存储器到存储器的数据传送，默认源串地址由[ESI]提供，目的串地址由[EDI]提供。<br /><strong>地址修改方向由DF标志位决定，DF=0时为增地址方向，DF=1时为减地址方向。</strong></p><h4 id="重复前缀"><a class="markdownIt-Anchor" href="#重复前缀"></a> 重复前缀</h4><p><strong>串操作指令前面可加上自动重复前缀，实现自动重复执行串操作，重复执行次数必须由ECX指定，每次执行ECX自减1。</strong><br />共有5条重复前缀:</p><ul><li>rep: 无其他条件重复，即ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li><li>repe: 相等重复，即ZF = 1 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li><li>repz: 为零重复，即ZF = 1 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li><li>repne: 不相等重复，即ZF = 0 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li><li>repnz: 不为零重复，即ZF = 0 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li></ul><h4 id="movsmovsbmovswmovsd"><a class="markdownIt-Anchor" href="#movsmovsbmovswmovsd"></a> movs/movsb/movsw/movsd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">movs [<span class="hljs-built_in">edi</span>], [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将esi内容的存储器单元内容送到edi内容的存储器单元中</span><br><span class="hljs-keyword">movsb</span><span class="hljs-comment">;  将esi内容的存储器字节单元内容送到edi内容的存储器字节单元中</span><br><span class="hljs-keyword">movsw</span><span class="hljs-comment">; 将esi内容的存储器字单元内容送到edi内容的存储器字单元中</span><br><span class="hljs-keyword">movsd</span><span class="hljs-comment">; 将esi内容的存储器双字单元内容送到edi内容的存储器双字单元中</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现存储器单元的直接传送<br />操作数要求:<br />源操作数必须是esi寄存器间接寻址单元，目的操作数必须是edi寄存器间接寻址单元，<strong>movs必须指明操作数结构</strong><br />对操作数影响:<br />目的操作数会变为源操作数，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />对标志位影响:</p><h4 id="cmpscmpsbcmpswcmpsd"><a class="markdownIt-Anchor" href="#cmpscmpsbcmpswcmpsd"></a> cmps/cmpsb/cmpsw/cmpsd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">cmps [<span class="hljs-built_in">esi</span>], [<span class="hljs-built_in">edi</span>]<span class="hljs-comment">; 执行[esi]-[edi]，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsb</span><span class="hljs-comment">;  计算[esi]字节单元 - [edi]字节单元，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsw</span><span class="hljs-comment">; 计算[esi]字单元 - [edi]字单元，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsd</span><span class="hljs-comment">; 计算[esi]双字单元 - [edi]双字单元，结果影响标志位但不送任何地址</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现存储器单元的直接比较并影响标志位<br />操作数要求:<br />源操作数必须是esi寄存器间接寻址单元，目的操作数必须是edi寄存器间接寻址单元，<strong>cmps必须指明操作数结构</strong><br />对操作数影响:<br />无影响，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />对标志位影响:<br />与<a href="#cmp">cmp</a>相同</p><p><strong>cmps指令常与条件重复前缀共同使用</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">mem1 <span class="hljs-built_in">db</span> <span class="hljs-number">200</span> dup(?)<span class="hljs-comment">; 定义mem1</span><br>mem1 <span class="hljs-built_in">db</span> <span class="hljs-number">200</span> dup(?)<span class="hljs-comment">; 定义mem2</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, mem1<span class="hljs-comment">; 取得起始地址一</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, mem2<span class="hljs-comment">; 取得起始地址二</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">200</span><span class="hljs-comment">; 比较区间长度</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">repe</span> <span class="hljs-keyword">cmpsb</span><span class="hljs-comment">; 重复寻找，直到第一个不同数据</span><br></code></pre></td></tr></table></figure><h4 id="scasscasbscaswscasd"><a class="markdownIt-Anchor" href="#scasscasbscaswscasd"></a> scas/scasb/scasw/scasd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">scas <span class="hljs-built_in">edi</span><span class="hljs-comment">; 执行EAX、AX、AL - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasb</span><span class="hljs-comment">; 执行AL - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasw</span><span class="hljs-comment">; 执行AX - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasd</span><span class="hljs-comment">; 执行EAX - [edi]内容，结果影响标志位但不送任何地址</span><br></code></pre></td></tr></table></figure><p>功能:<br />从edi串数据中扫描AL、AX、EAX寄存器内容数据<br />操作数要求:<br />必须是edi存储器操作数，<strong>scas必须指明操作数结构</strong><br />对操作数影响:<br />无影响，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />对标志位影响:<br />与<a href="#subsbbdec">sub</a>相同</p><p><strong>scas扫描找出对应字符所在串位置</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">buff <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ABCDEFGHIJK&#x27;</span><span class="hljs-comment">; 定义字符串</span><br>len $-buff<span class="hljs-comment">; 微指令求字符串长度</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span> buff<span class="hljs-comment">; 取得字符串起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;H&#x27;</span><span class="hljs-comment">; 将寻找字符放入al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, len<span class="hljs-comment">; 重复前缀次数</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">repne</span> <span class="hljs-keyword">scasb</span><span class="hljs-comment">; 重复扫描字符</span><br></code></pre></td></tr></table></figure><h4 id="lodslodsblodswlodsd"><a class="markdownIt-Anchor" href="#lodslodsblodswlodsd"></a> lods/lodsb/lodsw/lodsd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">lods [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将[esi]内容装入AL、AX、EAX</span><br><span class="hljs-keyword">lodsb</span><span class="hljs-comment">; 将[esi]内容装入AL</span><br><span class="hljs-keyword">lodsw</span><span class="hljs-comment">; 将[esi]内容装入AX</span><br><span class="hljs-keyword">lodsd</span><span class="hljs-comment">; 将[esi]内容装入EAX</span><br></code></pre></td></tr></table></figure><p>功能:<br />将存储器操作数装入累加器<br />操作数要求:<br />必须是esi寄存器间接寻址存储器操作数，<strong>lods必须指明操作数结构</strong><br />对操作数影响:<br />累加器内容变为[esi]<br />对标志位影响:<br />无影响</p><p><strong>lods一般不需要重复前缀，因为累加器数据会被覆盖</strong></p><h4 id="stosstosbstoswstosd"><a class="markdownIt-Anchor" href="#stosstosbstoswstosd"></a> stos/stosb/stosw/stosd</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">stos [<span class="hljs-built_in">edi</span>]<span class="hljs-comment">; 将AL、AX、EAX内容送入[edi]</span><br><span class="hljs-keyword">stosb</span><span class="hljs-comment">; 将AL内容送入[edi]</span><br><span class="hljs-keyword">stosw</span><span class="hljs-comment">; 将AX内容送入[edi]</span><br><span class="hljs-keyword">stosd</span><span class="hljs-comment">; 将EAX内容送入[edi]</span><br></code></pre></td></tr></table></figure><p>功能:<br />将累加器内容送入存储器操作数<br />操作数要求:<br />必须是edi寄存器间接寻址存储器操作数，<strong>stos必须指明操作数结构</strong><br />对操作数影响:<br />存储器操作数变为累加器内容，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />对标志位影响:<br />无影响</p><p><strong>stos常用于将内存某个区域置同样的值</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">buff <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(?)<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">F4H</span><span class="hljs-comment">; 需存储值</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, buff<span class="hljs-comment">; 取得偏移地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">20</span><span class="hljs-comment">; 区域长度</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosb</span><span class="hljs-comment">; 重复存储</span><br></code></pre></td></tr></table></figure><h3 id="程序控制指令"><a class="markdownIt-Anchor" href="#程序控制指令"></a> 程序控制指令</h3><p>程序控制指令一般没有操作数或只有单个操作数，且一般对标志位没有影响。<strong>其主要通过标志位控制程序执行的方向。</strong></p><h4 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> jmp</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> oprd<br></code></pre></td></tr></table></figure><p>功能:<br />跳转到距离jmp指令下一条指令oprd字节的指令。如<a href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AF%BB%E5%9D%80">转移地址寻址</a>中说的，有两个寻址方式，当采用直接寻址的方式时，称为<strong>短距离转移</strong>，jmp指令仅2字节长，当采用间接寻址方式时可按转移地址是否仍在本代码段分为<strong>近转移</strong>和<strong>远转移</strong>，jmp指令长为5字节<br />操作数要求:<br />操作数可以为标号，由汇编器进行翻译为8位的位移量或32位的位移量，也可为寄存器间接寻址的存储器单元<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="jcjncjojnojzjnzjpjnpjcxzjcxnz"><a class="markdownIt-Anchor" href="#jcjncjojnojzjnzjpjnpjcxzjcxnz"></a> jc/jnc/jo/jno/jz/jnz/jp/jnp/jcxz/jcxnz</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">jc label</span><span class="hljs-comment">; CF=1时跳转</span><br><span class="hljs-symbol">jnc label</span><span class="hljs-comment">; CF=0时跳转</span><br><span class="hljs-symbol">jo label</span><span class="hljs-comment">; OF=1时跳转</span><br><span class="hljs-symbol">jno label</span><span class="hljs-comment">; OF=0时跳转</span><br><span class="hljs-symbol">jz label</span><span class="hljs-comment">; ZF=1时跳转</span><br><span class="hljs-symbol">jnz label</span><span class="hljs-comment">; ZF=0时跳转</span><br><span class="hljs-symbol">jp label</span><span class="hljs-comment">; PF=1时跳转</span><br><span class="hljs-symbol">jnp label</span><span class="hljs-comment">; PF=0时跳转</span><br><span class="hljs-symbol">jcxz label</span><span class="hljs-comment">; CX或ECX=0时跳转</span><br><span class="hljs-symbol">jcxnz label</span><span class="hljs-comment">; CX或ECX不为0时跳转</span><br></code></pre></td></tr></table></figure><p>功能:<br />根据一个标志位或CX、ECX决定是否跳转<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="jajaejbjbejgjgejljle"><a class="markdownIt-Anchor" href="#jajaejbjbejgjgejljle"></a> ja/jae/jb/jbe/jg/jge/jl/jle</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">ja label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jae label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jb label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jbe label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jg label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jge label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jl label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jle label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br></code></pre></td></tr></table></figure><p>功能:<br />见<a href="#cmp">cmp</a><br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="looploopzloopnz"><a class="markdownIt-Anchor" href="#looploopzloopnz"></a> loop/loopz/loopnz</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">loop label</span><span class="hljs-comment">; ECX不为零</span><br><span class="hljs-keyword">loopz</span>(<span class="hljs-keyword">loope</span>) label<span class="hljs-comment">; ECX为不为零且ZF=1，则跳转label</span><br><span class="hljs-keyword">loopnz</span>(<span class="hljs-keyword">loopne</span>) label<span class="hljs-comment">; ECX不为零且ZF=0，则跳转label</span><br></code></pre></td></tr></table></figure><p>功能:<br />根据ECX内容和ZF决定是否跳转<br />操作数要求:<br />转移范围为当前EIP内容的-128~+127内<br />对操作数影响:<br />无要求<br />对标志位影响:<br />无影响</p><h4 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">call</span> subprocess<span class="hljs-comment">; 调用子过程</span><br></code></pre></td></tr></table></figure><p>功能:<br />调用子过程，等价于以下代码:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 将断点地址压栈</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eip</span> subprocess<span class="hljs-comment">; 将子过程开始地址放入EIP</span><br></code></pre></td></tr></table></figure><p>操作数要求:<br />subprocess必须是子过程的开始地址，汇编器会代替程序员进行这件事<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> ret</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ret</span><span class="hljs-comment">; 从堆栈中弹出断点地址，返回原程序</span><br><span class="hljs-keyword">ret</span> n<span class="hljs-comment">; 从堆栈中n个数据，其中第n个是断点地址，返回原程序</span><br></code></pre></td></tr></table></figure><p>功能:<br />在子程序中从堆栈中弹出断点，以返回原程序，其功能等价于以下代码:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ret</span> =&gt;<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 从堆栈中弹出断点地址送到EIP中</span><br><span class="hljs-keyword">ret</span> n =&gt;<br><span class="hljs-keyword">pop</span> oprd1<span class="hljs-comment">; 弹出第一个参数</span><br><span class="hljs-keyword">pop</span> oprd2<span class="hljs-comment">; 弹出第二个参数</span><br>·<br>·<br>·<br><span class="hljs-keyword">pop</span> oprdn-<span class="hljs-number">1</span><span class="hljs-comment">; 弹出第n-1个参数</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 弹出断点地址送到EIP中</span><br></code></pre></td></tr></table></figure><p>操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="intintoiret"><a class="markdownIt-Anchor" href="#intintoiret"></a> int/into/iret</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> n<span class="hljs-comment">; 程序发出中断类型号为n的软中断请求</span><br><span class="hljs-keyword">into</span><span class="hljs-comment">; 程序发出溢出中断请求</span><br><span class="hljs-keyword">iret</span><span class="hljs-comment">; 中断服务程序发出，用来恢复断点和标志寄存器内容</span><br></code></pre></td></tr></table></figure><p>功能:<br />int: 给予程序发出软中断请求的能力<br />into: 检测是否溢出，如果溢出(OF=1)即等价于<code>int 4</code>发出一个类型号为4的中断请求，如果<strong>未溢出则不做任何操作</strong><br />iret: 中断服务程序结束的固定流程指令(恢复现场、开中断)<br />操作数要求:<br /><strong>int: 操作数为立即数，且范围必须在0~255(X86下中断向量表只有256个表项)</strong><br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h3 id="处理器控制指令"><a class="markdownIt-Anchor" href="#处理器控制指令"></a> 处理器控制指令</h3><p><b>处理器一般通过标志位来控制指令的执行方式，因此控制指令一般可以直接更改标志位而无需运算来实现(如通过and、or实现CF和OF清零)，或直接通过指令来实现处理器工作情况的控制，如暂停、让出总线使用权等。</b></p><h4 id="clcstccmc"><a class="markdownIt-Anchor" href="#clcstccmc"></a> clc/stc/cmc</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">clc</span><span class="hljs-comment">; CF复位</span><br><span class="hljs-keyword">stc</span><span class="hljs-comment">; CF置位</span><br><span class="hljs-keyword">cmc</span><span class="hljs-comment">; CF取反</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现对CF的直接操作<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />更改CF值</p><h4 id="cldstd"><a class="markdownIt-Anchor" href="#cldstd"></a> cld/std</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cld</span><span class="hljs-comment">; DF复位</span><br><span class="hljs-keyword">std</span><span class="hljs-comment">; DF置位</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现对DF的直接操作，以进行对串操作的方向控制<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />更改CF值</p><h4 id="clisti"><a class="markdownIt-Anchor" href="#clisti"></a> cli/sti</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cli</span><span class="hljs-comment">; IF复位</span><br>stu<span class="hljs-comment">; IF置位</span><br></code></pre></td></tr></table></figure><p>功能:<br />实现对IF的直接操作，用以控制处理器的中断屏蔽状态，一般在中断处理时使用<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />更改IF值</p><h4 id="nop"><a class="markdownIt-Anchor" href="#nop"></a> nop</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">nop</span><span class="hljs-comment">; 不执行任何操作，使处理器空闲一个指令周期(3个时钟周期)</span><br></code></pre></td></tr></table></figure><p>功能:<br />使处理器空闲一个指令周期(3个时钟周期)<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="hlt"><a class="markdownIt-Anchor" href="#hlt"></a> hlt</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">hlt</span><span class="hljs-comment">; 使 CPU 处于暂停状态，不执行任何操作，等待复位信号或下一次外部中断的到</span><br>来<br></code></pre></td></tr></table></figure><p>功能:<br />阻塞CPU，等待中断请求或多机系统的同步<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">wait<span class="hljs-comment">; 使 CPU 处于等待状态，不执行任何操作。 CPU 将等待外部中断发生，如果有中</span><br>断发生，则完成中断任务后仍返回 WAIT 指令继续等待。<br></code></pre></td></tr></table></figure><p>功能:<br />使CPU等待，以使得CPU与协处理器或外部设备同步工作<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="esc"><a class="markdownIt-Anchor" href="#esc"></a> esc</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">esc oprd, src<span class="hljs-comment">; CPU让出总线使得src内容可以到数据总线上，从而将存储器中的指</span><br>令或数据传送给其他处理器<br></code></pre></td></tr></table></figure><p>功能:<br />CPU让出总线，使得协处理器能够使用总线进行数据传送<br />操作数要求:<br />无要求<br />对操作数影响:<br />无影响<br />对标志位影响:<br />无影响</p><h4 id="lock前缀"><a class="markdownIt-Anchor" href="#lock前缀"></a> lock前缀</h4><p>格式:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lock</span> op<span class="hljs-comment">; 使得op指令在执行期间封锁总线(独占总线)</span><br></code></pre></td></tr></table></figure><p>功能:<br />保证指令独占总线，防止协处理器破坏数据<br />操作数要求:<br />无要求<br />对操作数影响:<br />无要求<br />对标志位影响:<br />无要求</p><h2 id="代码参考"><a class="markdownIt-Anchor" href="#代码参考"></a> 代码参考</h2><p><a href="https://blog.51cto.com/u_15127518/4665720">代码参考</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Assembly Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8086与IA32微处理器</title>
    <link href="/2022/12/05/8086%E4%B8%8EIA32%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/12/05/8086%E4%B8%8EIA32%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="8086与ia32微处理器"><a class="markdownIt-Anchor" href="#8086与ia32微处理器"></a> 8086与IA32微处理器</h1><h2 id="80868088微处理器"><a class="markdownIt-Anchor" href="#80868088微处理器"></a> 8086/8088微处理器</h2><p>8086微处理器是Intel公司在1978年发表的第一款<strong>16位</strong>微处理器，在随后的1979年又推出了低成本版本的8088微处理器。<br />其具有以下特点:</p><ul><li>采用<strong>并行流水线工作方式</strong><br />将CPU划分为两个功能部分(执行单元EU和总线接口单元BIU)并设置指令预取队列，实现流水线工作方式。</li><li>对<strong>内存空间</strong>进行<strong>分段</strong>管理<br />将内存分为多个段，并设置了<strong>4个段寄存器</strong></li><li>支持<strong>多处理器系统</strong><br />可以包含主处理器和协处理器</li></ul><h3 id="主要引线功能"><a class="markdownIt-Anchor" href="#主要引线功能"></a> 主要引线功能</h3><p>8086和8088<strong>均有40个引脚</strong>，其中8086数据线为<strong>16条</strong>，而8088数据线为<strong>8条</strong>。<br />8086与8088<strong>共同</strong>的控制与状态信号线:</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>W</mi><mi>R</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{WR}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 写信号</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>R</mi><mi>D</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{RD}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 读信号</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>D</mi><mi>E</mi><mi>N</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{DEN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 有效时表示数据总线是数据有效，允许读写</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>T</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>R</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">DT/\overline{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 数据收发器传送方向控制，为<strong>1</strong>时由CPU向其他部件传送，否则反之。</li><li>ALE: 地址锁存信号，为<strong>1</strong>时表示地址线上地址有效。一般用它将地址锁存到一个锁存器中。</li><li>READY: 外部同步控制输入信号，微处理器与内存/外设之间在一个总线周期内的时钟配合信号，当CPU给出读信号或写信号后由内存/外设返回。</li><li>INTR: (interrupt request)可屏蔽的中断请求信号。</li><li>NMI: (not masked interrupt)不可屏蔽的中断请求信号。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>I</mi><mi>N</mi><mi>T</mi><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{INTA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">A</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: (interrupt answer)中断响应信号。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>N</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>M</mi><mi>X</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">MN/\overline{MX}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 工作模式选择信号。</li><li>RESET: 复位信号，当其为高时将完成CPU内部复位。复位后CPU内部寄存器的值如下表。</li></ul><table><thead><tr><th style="text-align:center">内部寄存器</th><th style="text-align:center">内容</th><th style="text-align:center">内部寄存器</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">CS</td><td style="text-align:center">FFFFH</td><td style="text-align:center">IP</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">DS</td><td style="text-align:center">0000H</td><td style="text-align:center">FALGS</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">SS</td><td style="text-align:center">0000H</td><td style="text-align:center">其余寄存器</td><td style="text-align:center">0000H</td></tr><tr><td style="text-align:center">ES</td><td style="text-align:center">0000H</td><td style="text-align:center">指令队列</td><td style="text-align:center">空</td></tr></tbody></table><p><b>Hint: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{signal}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.08888em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>表示低有效！</b></p><h4 id="8086"><a class="markdownIt-Anchor" href="#8086"></a> 8086</h4><p><img src="8086.png" alt="8086引脚图" /></p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mi>D</mi><mn>0</mn></msub><mi mathvariant="normal">至</mi><mi>A</mi><msub><mi>D</mi><mn>15</mn></msub></mrow><annotation encoding="application/x-tex">AD_0至AD_{15}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 供<strong>地址线</strong>与<strong>数据线</strong>复用，做地址线时为单向，做数据线时为双向。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>16</mn></msub><mi mathvariant="normal">至</mi><msub><mi>A</mi><mn>20</mn></msub><mi mathvariant="normal">或</mi><msub><mi>S</mi><mn>3</mn></msub><mi mathvariant="normal">至</mi><msub><mi>S</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">A_{16}至A_{20}或S_3至S_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">或</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 供<strong>地址线高4位</strong>与<strong>状态信号</strong>复用。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>I</mi><mi>O</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">M/\overline{IO}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 为<strong>1</strong>时表示访问内存，否则反之。</li></ul><h4 id="8088"><a class="markdownIt-Anchor" href="#8088"></a> 8088</h4><p><img src="8088.png" alt="8088引脚图" /></p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mi>D</mi><mn>0</mn></msub><mi mathvariant="normal">至</mi><mi>A</mi><msub><mi>D</mi><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">AD_0至AD_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 供<strong>地址线</strong>与<strong>数据线</strong>复用，做地址线时为单向，做数据线时为双向。</li><li>$A_8至A_{15}: <strong>地址线</strong>中间8位。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mn>16</mn></msub><mi mathvariant="normal">至</mi><msub><mi>A</mi><mn>20</mn></msub><mi mathvariant="normal">或</mi><msub><mi>S</mi><mn>3</mn></msub><mi mathvariant="normal">至</mi><msub><mi>S</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">A_{16}至A_{20}或S_3至S_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">或</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">至</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 供<strong>地址线高4位</strong>与<strong>状态信号</strong>复用。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>O</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">IO/\overline{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>: 为<strong>1</strong>时表示访问IO设备，否则反之。</li></ul><h4 id="8086与8088的区别"><a class="markdownIt-Anchor" href="#8086与8088的区别"></a> 8086与8088的区别</h4><ol><li>数据总线宽度不同:<ul><li>8086: 16位数据总线</li><li>8088: 8位数据总线(8088为8086的低成本版本)</li></ul></li><li>表示对内存和IO设备的信号不同:<ul><li>8086: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi mathvariant="normal">/</mi><mover accent="true"><mrow><mi>I</mi><mi>O</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">M/\overline{IO}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，高有效时访问内存</li><li>8088: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>O</mi><mi mathvariant="normal">/</mi><mover accent="true"><mi>M</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">IO/\overline{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">/</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span>，高有效时访问IO设备</li></ul></li></ol><h3 id="80868088内部结构"><a class="markdownIt-Anchor" href="#80868088内部结构"></a> 8086/8088内部结构</h3><p>可分为两个功能部分: 两部分功能相互独立、控制相互依赖。</p><ul><li><strong>执行单元EU</strong>: 完成指令的执行<ul><li>运算器</li><li>8个通用寄存器</li><li>1个标志寄存器</li><li>EU部分的控制电路</li></ul></li><li><strong>总线接口单元BIU</strong>: 取指令、取数据、完成指令的调度<ul><li>地址加法器</li><li>4个段寄存器</li><li>指令指针寄存器IP(计组中的PC)</li><li>总线控制逻辑<br /><img src="8086_8088_architechture.png" alt="8086/8088功能结构" /></li></ul></li></ul><h3 id="内部寄存器"><a class="markdownIt-Anchor" href="#内部寄存器"></a> 内部寄存器</h3><p>8086/8088微处理器共有<strong>14个16位寄存器</strong>，按功能可分为3类:</p><ul><li>通用寄存器(<strong>8个</strong>):<ul><li>数据寄存器:<ol><li>AX: 累加器，所有的<strong>IO指令</strong>都通过AX与接口传送信息。相关指令: <strong>in指令和out指令</strong></li><li>BX: 在<strong>间接寻址</strong>中存放<strong>基地址(数据段)</strong></li><li>CX: 计数寄存器。用于在循环或串操作指令中存放计数值。相关指令: <strong>loop指令</strong></li><li>DX:<ol><li>IO端口间接寻址中<strong>存放IO端口地址</strong></li><li>32位乘除法时<strong>存放高16位</strong><br /><b>数据寄存器均可拆分为2个8位寄存器使用，如AX可以分为AH和AL使用。</b></li></ol></li></ol></li><li>地址指针寄存器:<ol><li>SP: 堆栈指针寄存器，其内容为<strong>栈顶的偏移地址</strong>，栈顶为栈的<strong>最小</strong>地址</li><li>BP: 基址指针寄存器，常用于在访问内存时存放<strong>内存单元(堆栈段)的偏移地址</strong>。</li></ol></li><li>变址寄存器:<ol><li>SI: 源变址寄存器，相关指令: <strong>movsb指令默认源地址为esi寄存器(IA32下)</strong></li><li>DI: 目标变址寄存器，相关指令: <strong>movsb指令默认目的地址为edi寄存器(IA32下)</strong></li></ol></li></ul></li><li>段寄存器(<strong>4个</strong>):<ol><li>CS: 代码段寄存器，存放代码段基址</li><li>DS: 数据段寄存器，存放数据段基址</li><li>SS: 堆栈段寄存器，存放堆栈段基址</li><li>ES: 附加段寄存器，存放附加段基址，附加段一般作为数据段的补充</li></ol></li><li>控制寄存器(<strong>2个</strong>):<ol><li>FLAGS: 存放运算结果的状态特征和控制CPU的运行。<br />常用9个标志位:<ul><li>CF: <strong>进/借位标志</strong></li><li>PF: <strong>低8位奇偶校验位</strong>，<strong>1</strong>的个数为偶数时为1</li><li>AF: <strong>第4位的进/借位标志</strong></li><li>ZF: <strong>零标志位</strong></li><li>SF: <strong>符号位标志位</strong></li><li>OF: <strong>溢出标志位</strong></li><li>TF: <strong>陷阱标志位</strong>，也叫<strong>跟踪标志位</strong>。TF=1时，使CPU处于单步执行指令的工作方式。</li><li>IF: <strong>中断允许标志位</strong>,IF=1使CPU可以响应可屏蔽中断请求。</li><li>DF: <strong>方向标志位</strong>，在数据串操作时确定操作的方向。</li></ul></li><li>IP: <strong>指令指针寄存器</strong>，其内容为<strong>下一条要执行指令的偏移地址</strong>。(与计组中PC类似)</li></ol></li></ul><h3 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式</h3><p>8086/8088共有<strong>2种工作模式</strong>:</p><ul><li>最小模式: 为单处理器模式，控制信号较少，CPU直接输出控制信号到总线。</li></ul><p><img src="min.png" alt="最小模式" /></p><ul><li>最大模式: 作为主处理器，连接有其他协处理器，需要接总线控制器。</li></ul><p><img src="max.png" alt="最大模式" /></p><h3 id="存储器寻址"><a class="markdownIt-Anchor" href="#存储器寻址"></a> 存储器寻址</h3><p>8086/8088采用<strong>字节编址</strong>的方式来管理内存空间，定义连续两个字节作为<strong>字单元</strong>，<strong>字单元的地址为较低字节的地址</strong>，其存放规则是低8位放在较低地址字节单元，高8位放在较高地址字节单元，即<strong>小端方式</strong>。</p><h4 id="80868088地址重定向"><a class="markdownIt-Anchor" href="#80868088地址重定向"></a> 8086/8088地址重定向</h4><p>8086/8088共有<strong>20条地址线</strong>，寻址范围为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>1</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">2^{20}=1M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>。如前面介绍，8086/8088采用分段的方式来进行内存空间管理，而段寄存器仅有16位，因此8086/8088并不能直接采用<strong>段基址+段内偏移地址=物理地址</strong>的方式进行寻址。<br /><img src="addresing.png" alt="8086/8088寻址方式" /><br />如上图所示: 段寄存器内16位数据作为高16位地址，低4位补零形成段基址。其他寄存器内16位地址高4位补零形成偏移地址，再通过<strong>段基址+段内偏移地址=物理地址</strong>得到物理地址。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">段</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi><mo>×</mo><mn>16</mn><mo>+</mo><mi mathvariant="normal">偏</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi></mrow><annotation encoding="application/x-tex">段寄存器\times 16 + 偏移地址寄存器</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span></span></span></span></span></p><p><img src="example.png" alt="example" /><br />根据上述算法，段内最大偏移量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>64</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">2^{16}=64k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>字节，每个段的段基址低4位一定为<code>0000B</code>，因此从0地址开始，<strong>每16个字节单元称为一个小节</strong>，1MB的内存空间最多可以划分为<strong>64K个小节</strong>。</p><h4 id="80868088堆栈段使用"><a class="markdownIt-Anchor" href="#80868088堆栈段使用"></a> 8086/8088堆栈段使用</h4><p>堆栈是一个特定的存储区，访问该存储区一般需要按照专门的规则进行操作。其主要用于<strong>暂存数据</strong>以及在过程调用或处理中断时<strong>保存断点信息</strong>。<br /><img src="stack.png" alt="栈的示意图" /></p><ul><li>栈顶: 栈顶是最后存入信息的存储单元，为栈的所有地址中的<strong>最小值</strong>。</li><li>栈底: 栈底为固定的一端，是堆栈存储区的<strong>最大地址单元</strong>。</li><li><strong>SP始终指向栈顶</strong></li><li>堆栈段的数据均以<strong>字(16位)<strong>为存储单元，以小端进行存放。堆栈</strong>初始化时SP指向栈底+2单元(16位)</strong>，其值就是堆栈的长度。由于SP是16位寄存器，因此堆栈长度小于等于64K字节。</li></ul><h3 id="系统总线"><a class="markdownIt-Anchor" href="#系统总线"></a> 系统总线</h3><p>系统总线(bus): 是一组导线和相关的控制、驱动电路的集合，它是计算机系统各部件之间<strong>传输地址、数据和控制信息的通道</strong>。<br />BUS:</p><ul><li>地址总线(AB)</li><li>数据总线(DB)</li><li>控制总线(CB)</li></ul><h4 id="最大总线模式"><a class="markdownIt-Anchor" href="#最大总线模式"></a> 最大总线模式</h4><p><img src="max_bus.png" alt="最大模式总线" /><br />处于<strong>最大模式</strong>下的8086/8088可以接其他的协处理器，控制信号更加复杂，因此需要将控制信号位输入给<strong>总线控制器</strong>来产生控制信号。</p><h4 id="最小总线模式"><a class="markdownIt-Anchor" href="#最小总线模式"></a> 最小总线模式</h4><p><img src="min_bus.png" alt="最小模式总线" /><br /><strong>最小模式</strong>下8086/8088直接作为单处理器，通过引脚上的端口将<strong>控制信号直接输出</strong>即可。</p><h4 id="最小总线模式时序"><a class="markdownIt-Anchor" href="#最小总线模式时序"></a> 最小总线模式时序</h4><p><b>总线时序是指CPU上各引脚的信号在时间上的关系。</b><br />总线周期: CPU完成一次访问内存(或I/O接口)操作所需要的时间。<strong>1个总线周期至少包括4个时钟周期</strong>。<br /><img src="bus_example.png" alt="典型总线周期" /><br />如上图所示: <strong>1次访存或IO操作需要4个时钟周期</strong>，分别用来进行地址传送和数据传送。当READY信号处于低电平时，说明数据不可用，需要等待，因此插入<strong>至少1个TW时钟周期</strong>，如果READY信号一直处于低电平状态即数据一直没有准备好则会<strong>插入多个TW周期</strong>进行等待。<br /><img src="bus_read.png" alt="" /><br /><img src="bus_write.png" alt="" /></p><h2 id="ia-32微处理器"><a class="markdownIt-Anchor" href="#ia-32微处理器"></a> IA-32微处理器</h2><p>Intel公司将80286之后的80X86 <strong>32位微处理器</strong>称为IA(Intel Architecture)-32结构。80386是与8086兼容的高性能的32位微处理器。Pentium系列微处理器是与80X86系列微处理器兼容、RISC型超标量结构的32位微处理器。<br /><b>Hint: IA-32包括80386和奔腾系列。</b></p><h3 id="ia-32微处理器结构"><a class="markdownIt-Anchor" href="#ia-32微处理器结构"></a> IA-32微处理器结构</h3><p>CPU被划分为6个单元:<b>总线接口单元BIU、指令预取单元IPU、指令译码单元IDU、执行单元EU、分段单元SU、分页单元PU。</b><br />其主要特点有:</p><ul><li>具有4GB的物理地址空间和64TB的虚拟地址空间的存储器寻址能力</li><li>不仅有分段存储管理方式，还增加了分页存储管理方式(段页结合式)</li><li>多任务运行机制</li><li>优先级保护机制</li></ul><h3 id="内部寄存器-2"><a class="markdownIt-Anchor" href="#内部寄存器-2"></a> 内部寄存器</h3><p>IA32微处理器共有<strong>24个寄存器，其中14个32位寄存器，8个16位寄存器，2个48位寄存器</strong>，按功能可分为5类:</p><ul><li>通用寄存器(<strong>8个32位</strong>)<br />均为8086/8088的8个<strong>通用寄存器32位扩展版本</strong>，分别命名为EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI，功能也与在8086/8088中类似，并且<strong>EAX、EBX、ECX、EDX的低16位可拆分为16位和8位寄存器使用</strong>，如EAX可拆分为AX或AH与AL使用。</li><li>段寄存器(<strong>6个16位</strong>)<br />IA-32中<strong>段基址和偏移量都是32位</strong>，段寄存器只有16位不直接作段基址，其内容称为段选择器，需间接访问才能得到段基地址。<ol><li>CS: 代码段寄存器</li><li>DS: 数据段寄存器</li><li>SS: 堆栈段寄存器</li><li>ES: 附加段寄存器，附加段一般作为数据段的补充</li><li>FS: 动态数据结构段寄存器，也作为数据段的补充</li><li>GS: 共享段寄存器，也作为数据段的补充</li></ol></li><li>指令指针和标志寄存器(<strong>2个32位</strong>):<ol><li>EFLAGS: <strong>其中第0⁓11位共有9个标志位，与8086一致。</strong><br /><img src="eflags.png" alt="EFLAGS" /></li><li>EIP: 其低16位与8086同名为IP，作用与IP相同。</li></ol></li><li>系统地址寄存器(<strong>2个48位，2个16位</strong>)<br />使用方法见<a href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE">保护模式下的存储器访问</a><ul><li>48位寄存器:<ol><li>全局描述符表寄存器GDTR:</li><li>中断描述符表寄存器IDT:</li></ol></li><li>16位寄存器:<ol><li>局部描述符表寄存器LDTR</li><li>任务状态段寄存器TR</li></ol></li></ul></li><li>控制寄存器(<strong>4个32位</strong>)<br />分别为CR0、CR1、CR2和CR3，其中CR1保留未使用。<strong>用来设置和保存机器的各种全局性状态</strong>，比如是否有浮点部件，是否处于保护模式，是否采用页式存储管理等等。</li></ul><h3 id="工作模式-2"><a class="markdownIt-Anchor" href="#工作模式-2"></a> 工作模式</h3><p>IA-32有2种主要的工作方式和1种特殊模式:</p><ul><li>实模式: 实模式是为了与8086兼容而设置的工作方式即使<strong>IA32在16位模式下工作</strong>。IA-32的30多条<strong>地址线中只有低20条地址线起作用</strong>，可寻址1MB的物理地址空间。<strong>实模式下微处理器不能实现多任务的处理</strong>。</li><li>保护模式: 保护虚地址方式是IA-32微处理器的<strong>主要工作方式即32位模式</strong>。</li><li>虚拟86模式: 为了在IA-32系统上运行MS-DOS支持下的应用程序，微处理器可以工作在实地址方式<strong>即16位模式</strong>，但其功能十分有限。</li></ul><h3 id="保护模式下的存储器访问"><a class="markdownIt-Anchor" href="#保护模式下的存储器访问"></a> 保护模式下的存储器访问</h3><p>保护模式下可访问的地址空间达4GB，但不是随意使用，而是要受到一定的限制，<strong>这种保护就是由段描述符来完成，拿到段描述符即可重定向到段的物理地址</strong>。<br /><b>段描述符: 段描述符指示了这个段在内存中的位置、大小以及使用限制。段描述符有64位，包括段基址32位、段界限20位、特权级等属性12位。</b><br /><img src="segment.png" alt="段描述符" /></p><ul><li>段基址: <strong>32位</strong>段基址，表示该段在4GB线性地址空间中的<strong>起始地址</strong></li><li>属性: <strong>12位</strong>，包括特权级、段类型、段存在标志、粒度标志等<ul><li>特权级DPL: 每个段都有一个特权级，取值范围0~ 3，0级为最高级，一般用于操作系统核心代码。如果特权级数值高的程序试图访问特权级数值低的段，则发生处理器故障</li><li>段类型: 指定段的访问类型(只读、可读可写、只执行等)以及段生长的方向(向上或向下)</li><li>段存在标志: 指示该段当前是否在物理内存中</li><li>粒度标志G: 确定对段界限字段的解释</li></ul></li><li>段界限: <strong>20位</strong>段界限，<strong>表示段的大小</strong>，但具有两种解释: 根据粒度G的取值，1个段界限单位表示的内存大小不同，G=0时表示1字节，G=1时表示4096字节(4KB)</li></ul><table><thead><tr><th style="text-align:center">G = 0</th><th style="text-align:center">G = 1</th></tr></thead><tbody><tr><td style="text-align:center">1B~1MB</td><td style="text-align:center">4KB~4GB</td></tr></tbody></table><h4 id="获取段描述符"><a class="markdownIt-Anchor" href="#获取段描述符"></a> 获取段描述符</h4><p><b>描述符表: 把多个段的段描述符顺序地存放在一起就构成描述符表。</b><br />描述符表分为<strong>全局描述符表GDT和局部描述符表LDT</strong>。全局只有<strong>1个GDT</strong>，其起始地址存放在<strong>48位寄存器GDTR</strong>中，其中高32位为GDT起始地址，低16位为GDT长度。<strong>LDT也是一个单独的段，其段描述符称为LDT描述符</strong>，LDT描述符放在GDT中，当前任务的LDT描述符可以通过<strong>16位LDTR间接的从GDT中得到</strong>，然后再从LDT中得到需要的段描述符。<br />得到段描述符还需要该描述符在描述符表中的偏移地址，而该偏移地址由段寄存器的内容段选择器来进行指示:<br /><img src="segment_selector.png" alt="段选择器" /></p><ul><li>索引值: <strong>13位</strong>，描述段描述符在描述符表中的<strong>偏移地址</strong>，<strong>该索引值低位补零得到16位偏移地址</strong></li><li>TI: <strong>1位</strong>，指示段描述符在GDT中还是LDT中，<strong>为1时在LDT</strong></li><li>CPL/RPL: <strong>2位</strong>，表示<strong>该段的优先级</strong>，共4级</li></ul><h4 id="重定向"><a class="markdownIt-Anchor" href="#重定向"></a> 重定向</h4><p><img src="redirection.png" alt="重定向" /><br />重定向地址仍然由公式所示:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">物</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi><mo>=</mo><mi mathvariant="normal">段</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">址</mi><mo>+</mo><mi mathvariant="normal">段</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">偏</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">地</mi><mi mathvariant="normal">址</mi></mrow><annotation encoding="application/x-tex">物理地址=段基址+段内偏移地址</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">物</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">址</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">地</span><span class="mord cjk_fallback">址</span></span></span></span></span></p><p>段基址由段描述符所得到，段内偏移地址由其他32位寄存器得到。<br />以下是两个例子:<br /><img src="redirection_example1.png" alt="example" /><br /><img src="redirection_example2.png" alt="example" /></p><h4 id="flat-平坦模式"><a class="markdownIt-Anchor" href="#flat-平坦模式"></a> flat: 平坦模式</h4><p>在Windows 32位模式下将所有的段寄存器都设置为<strong>指向相同的线性地址0</strong>，代码段、数据段、堆栈段都重合于同一个4GB的线性地址空间。这种工作模式称为平坦存储模式(或平面存储模式)。<br />平坦存储模式下完全可以不管段寄存器的使用，<strong>访问存储器只使用32位的偏移地址</strong>，程序中不会出现CS、DS、SS等段寄存器。<br />虽然数据、堆栈和代码都共用一个4GB的线性地址空间，但在存储分配时仍然是相对集中，不是交叉随机分配。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Assembly Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互连及输入输出组织</title>
    <link href="/2022/06/13/%E4%BA%92%E8%BF%9E%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%84%E7%BB%87/"/>
    <url>/2022/06/13/%E4%BA%92%E8%BF%9E%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%84%E7%BB%87/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-8-interconnection-and-inputoutput-organization"><a class="markdownIt-Anchor" href="#chapter-8-interconnection-and-inputoutput-organization"></a> Chapter 8: Interconnection and input/output organization</h1><h2 id="io设备和磁盘存储器"><a class="markdownIt-Anchor" href="#io设备和磁盘存储器"></a> I/O设备和磁盘存储器</h2><h3 id="io系统概述"><a class="markdownIt-Anchor" href="#io系统概述"></a> I/O系统概述</h3><p>I/O系统常用的性能指标:</p><ul><li>Throughout(吞吐率/IO带宽): <strong>单位时间内从系统输入/输出数据量</strong></li><li>Latency(响应时间): <strong>请求任务的完成时间</strong></li></ul><p>I/O系统的功能: 解决各种形式信息的输入和输出，包括从外设获取输入数据和将数据传输给输出设备。</p><h3 id="io设备概述"><a class="markdownIt-Anchor" href="#io设备概述"></a> I/O设备概述</h3><p>外设分类:</p><ol><li>按信息传输方向:<ul><li>输入设备: 从外部向计算机输入信息，如：键盘、鼠标、扫描仪等</li><li>输出设备:从计算机向外部输出信息，如：打印机、显示器等</li><li>输入输出设备: 既可输入又可输出，如：带触屏的显示器、磁盘存储器等</li></ul></li><li>按功能:<ul><li>人-机交互设备:输入/输出的信息是人可读的，或可操作的。如: 键盘、鼠标、扫描仪、打印机、显示器等</li><li>外部存储设备: 用于信息的存储(其输入/出的信息是机器可读的)。如: 磁盘、磁带、光盘等</li><li>主机间通信设备: 主要用于计算机和计算机之间的通信。如: 网卡、调制解调器、A/D、D/A等</li></ul></li></ol><p><img src="io_devices_model.png" alt="外部设备通用模型" /></p><ul><li>电缆: 通过电缆与计算机内部I/O接口进行数据、状态和控制信息的传送。电缆线中包括<strong>控制信号</strong>、<strong>状态信号</strong>和<strong>数据信号</strong>三种信号线</li><li>控制逻辑: 根据控制信息控制设备的操作并检测设备状态</li><li>缓冲器: <strong>用于保存与计算机交换的数据信息</strong></li><li>变换器: 用于实现电信号形式与其他形式的设备数据之间的转换</li></ul><p><b>所有外部设备均可抽象为该模型，因此以磁盘为例进行说明。</b></p><h3 id="磁盘存储器"><a class="markdownIt-Anchor" href="#磁盘存储器"></a> 磁盘存储器</h3><h4 id="磁盘存储器组成"><a class="markdownIt-Anchor" href="#磁盘存储器组成"></a> 磁盘存储器组成</h4><p><b>磁盘 = 硬盘控制器 + 硬盘驱动器 + 磁记录介质(盘片)</b></p><pre><code class="mermaid" >flowchart TD    PC["主机"]    CR["硬盘控制器"]    DR["硬盘驱动器"]    DK["盘片"]    PC<-->|"I/O总线"|CR    CR<-->|"IDE、USB、SATA···"|DR    DR<-->|"磁头"|DK</code></pre><ul><li>盘片: 通过一些物理原理来<strong>实现信息的保存</strong></li><li>磁盘驱动器: 包括读写电路、读\写转换开关、读写磁头与磁头定位伺服系统等，<strong>实现盘片的读写</strong></li><li>磁盘控制器: 包括控制逻辑、时序电路、&quot;并→串&quot;转换和&quot;串→并&quot;转换电路等(用于连接主机与盘驱动器)，还包括数据缓存器、控制状态寄存器等，<strong>实现主机与磁盘存储器的数据交互和控制</strong></li></ul><p><img src="io_disk_model.png" alt="磁盘存储器模型" /></p><h4 id="磁盘信息存储原理"><a class="markdownIt-Anchor" href="#磁盘信息存储原理"></a> 磁盘信息存储原理</h4><p><img src="disk.png" alt="磁盘结构" /><br />当线圈通过不同方向的电流时，磁头磁场方向相反，在磁场的作用下盘片上会保存磁化状态从而表示0/1的信息。在读取时，磁头固定不动，载体运动，在铁芯线圈两端得到感应电压，感应电压的方向能够表示0/1.</p><h4 id="盘片划分结构"><a class="markdownIt-Anchor" href="#盘片划分结构"></a> 盘片划分结构</h4><p><img src="disk_board.png" alt="磁盘" /><br />磁盘表面分为多个<strong>同心圆</strong>，每个同心圆即一个磁道，其中最外围同心圆为0磁道。每个磁道上被划分为多个段，每个段称为一个扇区，一个扇区固定存储容量为512B(现在扇区划分已提升到4kB)</p><p>提高盘片信息记录密度方式:</p><ul><li>增加磁道数量: 提高道密度<br /><img src="disk_density.png" alt="道密度" /></li><li>增加扇区数量:<br /><img src="bit_density.png" alt="位密度" /></li></ul><p>提高磁盘容量: 在硬盘中叠加更多片盘片。</p><h4 id="磁盘驱动器"><a class="markdownIt-Anchor" href="#磁盘驱动器"></a> 磁盘驱动器</h4><p><img src="disk_driver.png" alt="磁盘驱动器逻辑结构" /><br /><b><br />定位数据流程:</p><ol><li>寻道: 磁头径向移动到指定的磁道</li><li>旋转: 在磁头固定不动的情况下，盘片旋转直到扇区在磁头下停止</li><li>读写: 通过载体运动产生感应电压从而进行读取数据或磁头加电流进行写操作<br /></b></li></ol><p><img src="disk_track.jpg" alt="磁道格式" /></p><h4 id="磁盘主要技术指标"><a class="markdownIt-Anchor" href="#磁盘主要技术指标"></a> 磁盘主要技术指标</h4><ul><li>磁盘容量: 磁盘容量分为未格式化容量和格式化容量<ul><li>未格式化容量: 指按道密度和位密度计算出的容量，包括间歇、ID域、数据域等信息。<br />磁盘总容量=记录面数×柱面数×内圆周长×位密度</li><li>格式化容量: 格式化后的磁盘容量只包含数据区，即能存储数据信息的容量。<br />磁盘数据容量=2×盘片数×磁道数/面×扇区数/磁道×512/扇区</li></ul></li><li><b>平均存取时间: T = 平均寻道时间 + 平均旋转等待时间 + 数据传输时间，磁盘响应时间 = 排队延迟 + 控制器时间 + 平均存取时间</b><br />例: 假定每个扇区512字节，磁盘转速为5400RPM，声称寻道时间(最大寻道时间的一半)为12 ms, 数据传输率为4MB/s, 磁盘控制器开销为1ms, 不考虑排队时间，则磁盘响应时间为多少？<br />T = 12ms + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>0.5</mn><mrow><mn>5400</mn><mo>÷</mo><mn>60</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{0.5}{5400 \div 60 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">4</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mbin mtight">÷</span><span class="mord mtight">6</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>ms + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>512</mn><mrow><mn>4</mn><mi>M</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{512}{4M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>ms + 1ms + 0ms <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span></span></span></span> 18.6ms</li></ul><h3 id="raid冗余磁盘阵列"><a class="markdownIt-Anchor" href="#raid冗余磁盘阵列"></a> RAID(冗余磁盘阵列)</h3><p>基本思想: 将多个独立操作的磁盘按某种方式组织成磁盘阵列(Disk Array)，以增加容量，利用类似于主存中的多体交叉技术，将数据分散在多个磁盘上，<strong>通过这些盘并行工作来提高数据传输速度</strong>。</p><p>RAID特性:</p><ul><li>RAID是<strong>一组</strong>物理磁盘驱动器，但在操作系统下被视为一个高容量的单逻辑驱动器</li><li>数据连续或交叉地分布在一组物理磁盘上，高数据传输率</li><li><strong>冗余磁盘用于存储校验信息</strong>，保证磁盘万一损坏时能恢复数据(一张磁盘专门用于存放校验)</li></ul><h3 id="ssd固态硬盘"><a class="markdownIt-Anchor" href="#ssd固态硬盘"></a> SSD(固态硬盘)</h3><p>SSD并不是一种磁表面存储器，而是一种使用NAND闪存组成的外部存储系统，与U盘并没有本质差别，只是容量更大，存取性能更好。</p><p>SSD的特性:</p><ul><li>写操作比读操作慢得多</li><li><strong>内部传输速率远远高于常规硬盘</strong></li><li>闪存的擦写次数有限，所以频繁擦写会降低其写入使用寿命</li></ul><h2 id="总线及系统互连-io接口"><a class="markdownIt-Anchor" href="#总线及系统互连-io接口"></a> 总线及系统互连、I/O接口</h2><p>总线的分类:</p><ul><li><strong>芯片内总线</strong>: 在芯片内部各元件之间提供连接，数据通路中的线均为芯片内总线</li><li><strong>系统总线</strong>: 在系统主要功能部件间提供连接，如CPU、MM和I/O控制器之间<br />系统总线可以分为单总线结构和多总线结构<ul><li>单总线将CPU、MM和I/O控制器<strong>通过一条底板总线</strong>连接在一起</li><li>多总线将不同部件用不同总线进行连接，如CPU与MM单独连接的总线，CPU与I/O的高速总线，CPU与I/O的低速总线等</li></ul></li><li><strong>通信总线</strong>: 在主机和I/O设备或主机与主机之间提供连接，<strong>如SATA、USB、SCSI等</strong></li></ul><h3 id="系统总线"><a class="markdownIt-Anchor" href="#系统总线"></a> 系统总线</h3><p><img src="system_bus.png" alt="系统总线" /><br />在Intel体系中北桥将CPU到存储器的总线分为了<strong>处理器总线</strong>和<strong>存储器总线</strong>两条总线。系统总线通常由<strong>一组控制线</strong>、<strong>一组数据线</strong>和<strong>一组地址线</strong>构成，但存在地址线和数据线合一的总线，这种情况称为<strong>数据/地址复用</strong></p><p>总线宽度: 总线中数据线的条数，决定了每次能同时传输的信息位数<br />总线工作频率: 有些总线一个时钟周期可以传送2次或4次数据，因此，工作频率是时钟频率的2倍或4倍(与DDR技术对应)<br />总线带宽: 总线的最大数据传输率，B=W <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mfrac><mi>F</mi><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">\times \frac{F}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord">×</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，W为总线宽度，F为总线时钟频率，N为完成一次数据传送所用的时钟周期数<br />总线传送方式:</p><ul><li>非突发传送: 每个总线事务都传送地址，一个地址对应一次数据传送</li><li>突发传送: 即成块数据传送。突发传送总线事务中，先传送一个地址，后传送多次数据，后续数据的地址默认为前面地址自动增量</li></ul><h4 id="fsb处理器总线"><a class="markdownIt-Anchor" href="#fsb处理器总线"></a> FSB(处理器总线)</h4><ul><li>并行传输、同步定时方式</li><li>是第一代CPU总线，使用quad pumped技术: 每个总线时钟周期传送4次数据</li></ul><h4 id="qpi快速通道互连总线"><a class="markdownIt-Anchor" href="#qpi快速通道互连总线"></a> QPI(快速通道互连总线)</h4><ul><li>目前在Intel架构中CPU芯片内部核之间、CPU芯片之间、CPU芯片与IOH(I/O Hub)芯片之间，都通过QPI总线互连</li><li>采用QPI总线的CPU已经将主存控制器集成到芯片，因此<strong>主存不需要通过北</strong>桥，而是直接与CPU相连</li><li>发送方和接收方有各自的时钟信号，总线有20条数据线，每条数据线为一个<strong>双向</strong>的串行传输通道，因<strong>此双方都有20个传输通道</strong></li><li>QPI总线带宽为：时钟频率×2×2B×2(不算校验位，按有效数据位计算)</li></ul><h4 id="存储器总线"><a class="markdownIt-Anchor" href="#存储器总线"></a> 存储器总线</h4><p><img src="storage_bus.png" alt="存储器总线" /></p><h4 id="io总线"><a class="markdownIt-Anchor" href="#io总线"></a> I/O总线</h4><p><strong>I/O总线用于为系统中的各种I/O设备提供输入输出通道</strong>。<br />I/O总线在物理上可以是主板上的I/O扩展槽，如:</p><ul><li>第一代: <strong>ISA/EISA总线，VESA总线</strong></li><li>第二代: <strong>PCI、AGP、PCI-X</strong></li><li>第三代: <strong>PCI-Express</strong></li></ul><p>PCI-Express:</p><ul><li><strong>串行</strong>总线</li><li>两个PCI-Express设备之间以一个链路(link)相连</li><li>每个链路包含多条通路(lane)，可以是1,2,4,8,16或32条</li><li>每条通路<strong>可同时发送和接受</strong>，<strong>每个数据字节被转换为10位信息被传输</strong></li><li>PCI-Express1.0下，每条通路的发送和接受速率都是2.5Gb/s，故PCI-Express×n的带宽为：2.5Gb/s×2×n/10=0.5GB/s×n</li></ul><h5 id="io总线io控制器和io设备的关系"><a class="markdownIt-Anchor" href="#io总线io控制器和io设备的关系"></a> I/O总线，I/O控制器和I/O设备的关系</h5><p><img src="io_devices2PC.png" alt="图示" /><br /><b><br />I/O设备通常是物理上相互独立的设备，它们一般通过通信总线与I/O控制器连接。<br />I/O控制器(I/O接口)通过扩充卡或者南桥芯片与I/O总线连接<br />I/O总线经过北桥芯片与内存、CPU连接<br /></b></p><h5 id="io接口"><a class="markdownIt-Anchor" href="#io接口"></a> I/O接口</h5><p><strong>I/O接口：I/O设备控制器及其插座，I/O接口是I/O设备与主机接入的桥梁</strong>。<br />I/O接口的功能:</p><ul><li>数据缓冲: <strong>提供数据缓冲寄存器</strong>，以达到主机和外设工作速度的匹配</li><li>错误或状态检测: <strong>提供状态寄存器，以保存各种错误或状态信息供CPU查用</strong></li><li>控制和定时: 提供控制和定时逻辑，以接受从系统总线来的控制定时信号</li><li>数据格式转换: 使通过外部接口得到的<strong>数据转换为内部接口需要的格式</strong>，或在相反的方向进行数据格式转换</li><li>与主机和设备通信: 能够与主机和设备通信从而实现上述功能</li></ul><p><img src="io_interface.png" alt="I/O接口" /></p><p>CPU通过I/O接口从而实现控制I/O设备:</p><ol><li>通过发送命令字到控制寄存器来向设备发送命令</li><li>通过从状态寄存器读取状态字来获取外设或I/O控制器的状态信息</li><li>通过向数据缓冲寄存器发送或读取数据来和外设进行数据交换</li></ol><p><b>I/O端口: I/O控制器中CPU能够访问的各类寄存器。因此I/O端口需要编址，I/O设备的寻址方式就是I/O端口的编址方式</b></p><ul><li><b>统一编址方式(内存映射方式)</b>: 与主存空间统一编址，将主存空间分出一部分地址给I/O端口进行编号</li><li><b>独立编址方式(专门的I/O指令方式)</b>: 不和主存单元一起编号，而是单独编号，使成为一个独立的I/O地址空间，因此需要特殊的I/O指令来支持访问I/O端口</li></ul><h2 id="io传输方式"><a class="markdownIt-Anchor" href="#io传输方式"></a> I/O传输方式</h2><p>I/O设备与主机进行数据交换的三种基本方式:</p><ul><li>程序直接控制方式:<ul><li>无条件传送: 对简单外设定时同步进行数据传送</li><li><strong>条件传送</strong>: 轮询方式，OS主动查询，I/O设备将自己的状态放到一个状态寄存器中，OS阶段性的查询状态寄存器中的特定状态以决定下一步动作。</li></ul></li><li><strong>中断方式</strong>: 几乎所有系统都支持的方式<ol><li>当一个I/O设备需要CPU的干预时，他通过<strong>中断请求来通知CPU</strong></li><li>CPU<strong>中止当前程序的执行</strong>，调出OS中断处理程序来执行</li><li>处理完成后<strong>返回到中止的程序继续执行</strong></li></ol></li><li><strong>DMA方式</strong>: 磁盘等高速外设<strong>成批的直接和主存进行数据交换</strong></li></ul><h3 id="轮询方式"><a class="markdownIt-Anchor" href="#轮询方式"></a> 轮询方式</h3><p>轮询方式有独占查询和定时查询来进行的方式，这里以打印机为例通过流程图来表示轮询查询的过程:</p><h3 id="程序中断方式"><a class="markdownIt-Anchor" href="#程序中断方式"></a> 程序中断方式</h3><p>基本思想: 当外设准备好时便<strong>向CPU发中断请求</strong>，CPU响应后，中止现行程序的执行，<strong>转入一个中断服务程序</strong>，在中断服务程序中进行输入/输出操作，实现主机和外设接口之间的数据传送，并启动外设工作，中断服务程序执行完后，<strong>返回原被中止的程序断点处继续执行</strong>。<br /><img src="interruption.png" alt="中断方式" /><br />注意: 中断隐指令是指切换程序间的工作指令，也需要消耗时间。</p><p><strong>中断的实质是CPU执行程序的切换: 从当前工作切换到I/O处理程序再切换回来。</strong></p><p>中断处理机制其实与异常处理机制几乎完全相同，如<a href="https://thm-lab.github.io/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">CPU</a>中异常处理所示: 主要由<strong>关中断、保护断点和程序状态、识别异常(中断)事件</strong>步骤组成。但异常和中断的处理还是有所不同，<strong>CPU内部产生的异常是不可屏蔽的，必须要处理异常后才能继续运行(在指令执行过程中也必须处理异常而中断可以等指令执行完后再处理)，而通过中断请求的外部中断是可以通过屏蔽字来进行屏蔽的</strong>。</p><p>中断处理中十分重要的一步是<strong>识别异常(中断)事件</strong>，而在CPU章中说过，有硬件识别(向量中断方式)和软件识别两种方式，这里将详细说明两种方式识别异常和处理异常的过程。</p><p>首先中断响应有一定的条件:</p><ul><li><strong>CPU处于开中断状态(中断允许位开启)</strong></li><li><strong>在一条指令执行完</strong>，因此当中断出现在指令过程中时，必须等待当前指令执行完后才能进行响应</li><li>至少有一个<strong>未被屏蔽</strong>的中断请求</li></ul><p>在开始中断响应后需要通过隐指令来完成中断响应，中断隐指令具体内容即为<strong>关中断、保护现场和识别中断源</strong>这三个步骤</p><h4 id="软件方式识别中断类型"><a class="markdownIt-Anchor" href="#软件方式识别中断类型"></a> 软件方式识别中断类型</h4><p>本质上是一种<strong>轮询方法</strong>，中断查询程序根据中断请求状态，<strong>按优先级顺序来依次查询</strong>中断请求状态，从而识别出中断源。</p><h4 id="向量中断方式识别中断类型"><a class="markdownIt-Anchor" href="#向量中断方式识别中断类型"></a> 向量中断方式识别中断类型</h4><p><strong>将所有中断请求状态送到一个排队电路中</strong>，根据中断优先级识别出最高优先级的中断请求。一般由中断控制器实现，如Intel8259A。<br /><img src="vector_query.png" alt="硬件实现" /></p><p><strong>识别中断后需要调出对应的中断服务程序</strong>。然后CPU执行该中断服务程序，当结束后需要恢复现场回到原来的程序。</p><pre><code class="mermaid" >flowchart TD    Main["原程序"]    subgraph "准备阶段"        Close["关中断"]        Protect["保护现场和旧屏蔽字"]        Query["查询中断原因"]        Set["设置新屏蔽字"]        Open["开中断"]        Close-->Protect-->Query-->Set-->Open    end    Main-->Close    subgraph "中断处理"        Process["执行中断服务程序"]    end    Open-->Process    subgraph "恢复阶段"        Close2["关中断"]        Recover["恢复现场和旧屏蔽字"]        Clean["清除新屏蔽字和中断请求"]        Return["中断返回"]        Close2-->Recover-->Clean-->Return    end    Process-->Close2    Return-->Main</code></pre><h4 id="多重中断处理"><a class="markdownIt-Anchor" href="#多重中断处理"></a> 多重中断处理</h4><p>在一个<strong>中断处理(执行中断服务程序)过程中</strong>(因为在准备阶段和恢复阶段都会关中断)，若有新的中断请求发生，且新中断优先级高于正在执行的中断，则中止正在执行的中断服务程序，转去处理新的中断。这种情况为多重中断，也称中断嵌套。</p><p>中断响应优先级: 由查询程序或硬联排队线路决定的优先权，<strong>反映多个中断同时请求时选择哪个响应</strong>。<br />中断处理优先级: 当某个中断正在被处理过程中，有别的中断源的请求发生了，这时就<strong>由各中断源的中断处理优先级决定如何响应</strong>。如果优先级低的中断发生了则先处理本次中断，若优先级更高的中断发生了则先处理新发生的中断。<strong>中断处理优先级由屏蔽字来体现</strong>。<br /><img src="shield_word.png" alt="屏蔽字" /></p><p><img src="multi_interrupt_process.png" alt="多重中断处理" /></p><h3 id="dma方式直接存储器访问"><a class="markdownIt-Anchor" href="#dma方式直接存储器访问"></a> DMA方式(直接存储器访问)</h3><p><b>程序直接控制方式会产生轮询开销大的问题，而中断控制方式对I/O请求响应慢且数据传送速度慢，因此对于磁盘等高速外设一般采用DMA方式来进行主存和外设间的数据传送</b></p><p>基本思想: <strong>通过专门硬件(DMA接口)来直接控制总线实现外设与主存间的数据传送</strong>。<br />特点:</p><ul><li>成批数据交换: 一旦启动数据连续读写，且数据间间隔时间短</li><li>采用请求-响应方式: 当设备准备好数据后就会向DMA控制器发送DMA请求，DMA控制器收到请求后会向CPU申请总线的使用权</li><li>与中断控制方式结合使用:<ul><li>DMA传送前，外设在寻道、旋转等操作结束时会<strong>通过中断来通知CPU</strong></li><li><strong>DMA控制器使用总线进行数据传送时，CPU执行其他程序</strong></li><li>DMA结束后会<strong>通过DMA结束中断来通知CPU</strong></li></ul></li></ul><p><img src="dma_model.png" alt="DMA方式" /></p><p>但DMA向CPU申请总线使用权时可能会出现一些问题，这里以可能出现的情况来进行分析:</p><ol><li>CPU不需使用主存: 即CPU没有使用总线，因此DMA可以直接拿到总线的使用权</li><li>CPU正在访问主存: <strong>必须等到CPU让出总线使用权时才能访存</strong></li><li>CPU也同时将要访问主存: <strong>出现访存冲突，需要处理权限问题</strong></li></ol><p>处理访存冲突的方式:</p><ul><li>CPU停止法: DMA传输时，<strong>CPU脱离总线停止访问主存</strong>直到DMA传完一块数据。<ul><li>优点: 控制简单，适合传输速率很高的外设成组传输数据</li><li>缺点: CPU收到影响，CPU基本停止工作(没有数据可以使用除非cache命中)<br />在DMA接口中可<strong>设置一个缓冲器，外设先于缓冲器进行交换数据，缓冲满时再由缓冲通过总线与主存进行数据交换</strong></li></ul></li><li>周期挪用法: 在<strong>存储器工作周期中窃取一部分时间作为DMA传输时间</strong>，从而即满足CPU使用也满足DMA使用，但会增加总线控制权等控制信号的开销<br /><img src="cycle_move_method.png" alt="周期挪用法" /></li><li>交替分时访问法: 将每个存储周期分成两个时间片，一个给CPU，一个给DMA，这样在每个存储周期内，CPU和DMA都可访问存储器</li></ul><p><img src="dma_logic.png" alt="DMA逻辑结构" /></p><h4 id="dma数据传送流程"><a class="markdownIt-Anchor" href="#dma数据传送流程"></a> DMA数据传送流程</h4><ol><li>DMA控制器与CPU沟通好内存地址传输方向等参数信息</li><li>外设准备好数据后<strong>将数据送入数据缓冲寄存器并将DMA请求触发器置为1</strong></li><li>DMA请求触发器<strong>向DMA控制器发送DMA请求同时向控制状态端口发送&quot;Ready&quot;信号</strong></li><li><strong>DMA控制器向CPU请求总线</strong><br />5， CPU完成当前周期后返回总线响应</li><li><strong>DMA控制器通知I/O接口发送DMA响应信号，DMA请求触发器置为0</strong>，此时DMA控制器拿到总线使用权</li><li>DMA控制器给出内存地址，<strong>I/O接口开始通过总线批量传输数据</strong></li><li>完成后I/O接口通知DMA控制器完成，<strong>DMA控制器通过中断告知CPU DMA传输完成</strong>并释放总线</li></ol><h4 id="dma与中断方式的区别"><a class="markdownIt-Anchor" href="#dma与中断方式的区别"></a> DMA与中断方式的区别</h4><ul><li>DMA<strong>通过DMA控制器完成</strong>数据传输，而<strong>中断通过中断服务程序完成</strong>数据传输</li><li><strong>DMA是对总线使用权的请求</strong>，而<strong>中断是对CPU执行的请求</strong>，使用的资源类型不同</li><li>DMA<strong>响应是在一个总线周期后</strong>，而中断<strong>响应是在一个指令周期后</strong></li><li>DMA的数据传送效率高于中断，且DMA的并行度高于中断方式</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器层次结构</title>
    <link href="/2022/06/12/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/12/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-7-memory-hierarchy"><a class="markdownIt-Anchor" href="#chapter-7-memory-hierarchy"></a> Chapter 7: Memory Hierarchy</h1><h2 id="存储器概述和存储器芯片"><a class="markdownIt-Anchor" href="#存储器概述和存储器芯片"></a> 存储器概述和存储器芯片</h2><p>首先对常用的术语进行解释:</p><ul><li>记忆单元: 具有两种稳态的能够表示二进制数0和1的物理器件</li><li>存储单元: 具有相同地址的位构成一个存储单元，也称为一个编址单位</li><li>存储阵列: 所有存储单元构成一个存储阵列</li><li>编址方式:<ul><li>字节编址: 存储单元的地址是一个字节的整数</li><li>按字编址: 每个地址宽度为一个字的宽度</li></ul></li><li>MAR: 存储器地址寄存器，用于存放访问主存单元的地址的寄存器</li><li>MDR: 存储器数据寄存器，用于存放与主存单元进行交换的数据的寄存器</li></ul><h3 id="存储器分类"><a class="markdownIt-Anchor" href="#存储器分类"></a> 存储器分类</h3><ol><li>按<strong>工作性质/存取方式分</strong>类:<ul><li>随机存取存储器: 每个单元读写时间一样，且与各单元所在位置无关。如: 内存</li><li>顺序存取存储器: 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。如: 磁带</li><li>直接存取存储器: 直接定位到读写数据块，在读写数据块时按顺序进行。如: 磁盘</li><li>相联存储器: 按内容检索到存储位置进行读写。如: 快表</li></ul></li><li>按<strong>存储介质</strong>分类:<ul><li>半导体存储器: 双极型，静态MOS型(SRAM)，动态MOS型(DRAM)</li><li>磁表面存储器: 磁盘(Disk)、磁带(Tape)</li><li>光存储器: CD，CD-ROM，DVD</li></ul></li><li>按<strong>信息的可更改性</strong>分类:<ul><li>读写存储器(Read/Write Memory): 可读可写</li><li>只读存储器(Read Only Memory, ROM): 只能读不能写</li></ul></li><li>按<strong>断电后信息的可保存性</strong>分类:<ul><li>非易失(不挥发)性存储器: 信息可一直保留，不需电源维持。如: ROM、磁表面存储器、光存储器等</li><li>易失(挥发)性存储器: 电源关闭时信息自动丢失。如: RAM、Cache等</li></ul></li><li>按功能/容量/速度/所在位置分类——<strong>层次结构存储系统</strong>:<ul><li>寄存器: 封装在CPU内，用于存放当前正在执行的指令和使用的数据，<strong>用触发器实现</strong>，速度快，容量小</li><li>高速缓存: 位于CPU内部或附近，用来存放当前要执行的局部程序段和数据，<strong>用SRAM实现</strong>，速度可与CPU匹配，容量小</li><li>内存: 位于CPU之外，用来存放已被启动的程序及所用的数据，<strong>用DRAM实现</strong>，速度较快，容量较大</li><li>外存: 位于主机之外，用来存放暂不运行的程序、数据或存档文件，<strong>用磁表面或光存储器实现</strong>，容量大而速度慢</li></ul></li></ol><h3 id="主存结构"><a class="markdownIt-Anchor" href="#主存结构"></a> 主存结构</h3><p><img src="main_memory.png" alt="主存结构" /><br />当CPU需要从主存中取指令或数据时，需要将地址放入MAR中并同时通过控制线告知读写控制电路，主存从MAR中取得地址并译码，取数后将数据传送到MDR中，CPU从MDR中拿到数据完成整个取指或取数。流程图如下:</p><pre><code class="mermaid" >flowchart TB    MAR("MAR")    MDR("MDR")    CPU("CPU")        CTL("读写控制电路")    DEC("地址译码器")    MEM("存储单元")        CPU-->MAR    MAR-->DEC    DEC-->MEM    CPU-->CTL    CTL-->MEM    MEM-->MDR    MDR-->CPU</code></pre><p>在上图中MAR与地址译码器之间的地址线宽度为36位因此主存地址空间大小=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>6</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^36GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">6</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>(按字节编址)，但<strong>主存容量为实际安装的主存大小</strong>。数据线宽度为64位，因此一次读写最大为64位=8B。</p><h3 id="主存的主要性能指标"><a class="markdownIt-Anchor" href="#主存的主要性能指标"></a> 主存的主要性能指标</h3><ul><li>存储容量: 所包含的存储单元的总数</li><li><strong>存取时间</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 从CPU送出内存单元的地址码开始，到主存读出数据并送到CPU(送到MDR)所需要的时间</li><li>存储周期<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>M</mi><mi>C</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{MC}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: 连读两次访问存储器所需的最小时间间隔，它等于存取时间加上下一次存取开始前所要求的附加时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>M</mi><mi>C</mi></mrow></msub><mo>&gt;</mo><msub><mi>T</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">T_{MC}&gt;T_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>因为存储器的读出放大器、驱动电路等都有一段稳定恢复时间，所以读出后不能立即进行下一次访问</li></ul><h3 id="各半导体芯片的读写原理"><a class="markdownIt-Anchor" href="#各半导体芯片的读写原理"></a> 各半导体芯片的读写原理</h3><h4 id="sram"><a class="markdownIt-Anchor" href="#sram"></a> SRAM</h4><p>SRAM的电子基础元件为6管静态NMOS记忆单元。</p><ul><li>写入时: <strong>位线上是被写入的二进位信息0或1，字线为1，则存储单元设置为位线数据</strong></li><li>读出时: <strong>两个位线均为高电平(1)，字线为1，输出位线则为输出数据</strong></li></ul><p><img src="sram.png" alt="SRAM" /><br />SRAM中数据保存在双稳态触发器中，只要供电，数据就一直保持，<strong>不是破环性读出</strong>，也无需重写，也<strong>无需刷新</strong>。</p><h4 id="dram"><a class="markdownIt-Anchor" href="#dram"></a> DRAM</h4><p>DRAM的电子基础元件为MOS管的栅极电容。</p><ul><li>写入时: 字线为1，位线放置写入数据，存储单元设置为位线数据</li><li>读出时: 字线为1，位线放置读出电压，输出位线则为输出数据</li></ul><p><img src="dram.png" alt="DRAM" /><br /><strong>DRAM为破坏性读出</strong>，即读出时Cs上的电荷会被放电，为此读后需要再生，<strong>用读出的数据再写</strong>入。并且实际的Cs有漏电，一定时间后存储的电荷会消失，<strong>为此需要定时地向Cs补充电荷，称此操作为刷新</strong>。</p><h3 id="rom"><a class="markdownIt-Anchor" href="#rom"></a> ROM</h3><p>ROM具有<strong>信息只能读不能(在线)写</strong>、<strong>非破坏性读出</strong>、<strong>随机存取方式</strong>、<strong>不受断电影响</strong>的特点。</p><p>常见的ROM:</p><ul><li>MROM(Mask ROM): 掩膜只读存储器</li><li>PROM(Programmable ROM): 可编程只读存储器</li><li>EPROM(Erasable PROM): 可擦除可编程只读存储器</li><li>EEPROM(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>E</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>PROM, Electrically EPROM): 电可擦除可编程只读存储器</li><li>flash memory: 闪存(快擦存储器): 快擦型电可擦除重编程ROM</li></ul><h4 id="flash"><a class="markdownIt-Anchor" href="#flash"></a> Flash</h4><p><img src="flash.png" alt="Flash" /></p><ul><li>擦除: 所有单元都同时写1</li><li>编程: 只对需要之处写0</li><li>读取: 控制栅加正电压，若状态为0，则读出电路检测不到电流，若状态为1，则读出电路检测到电流</li></ul><p>即使电源关闭，两种状态可以稳定地维持不变。因此<strong>无需刷新</strong>，<strong>无需重写</strong>，<strong>不怕断电</strong>。</p><h3 id="dram刷新"><a class="markdownIt-Anchor" href="#dram刷新"></a> DRAM刷新</h3><p>在上面DRAM原理时说到，DRAM存在漏电情况，在不供电时数据只能维持几十毫秒，为保证信息不丢失需要定期刷新。<strong>刷新操作即读操作</strong>。刷新按行进行，所有芯片中的同一行同时刷新。刷新周期: <strong>从上次对整个存储器刷新结束到下次对整个存储器全部刷新一遍为止的时间间隔</strong>，也就是对某个特定行进行刷新的时间间隔目前多数情况下是64ms。</p><p>刷新方式:</p><ul><li>集中刷新: 在刷新周期内<strong>集中安排所有行的刷新</strong></li><li>分散刷新: <strong>各行的刷新分散安排</strong>在每个存取周期中</li><li>异步刷新: <strong>所有行刷新分散安排在1个刷新周期内</strong>，每隔一段时间刷新一行即可定时刷新一行</li></ul><h3 id="主存与cpu的连接及其读写操作"><a class="markdownIt-Anchor" href="#主存与cpu的连接及其读写操作"></a> 主存与CPU的连接及其读写操作</h3><p>CPU和主存之间有同步和异步两种通信方式。</p><ul><li>异步方式过程(需要握手信号):<ol><li>CPU送地址到地址线，主存进行地址译码</li><li>CPU发读命令，然后等待存储器发回&quot;完成&quot;信号</li><li>主存收到读命令后开始读数，完成后发&quot;完成&quot;信号给CPU</li><li>CPU接收到&quot;完成&quot;信号，从数据线取数</li></ol></li><li>同步方式:<ol><li>CPU和主存由统一时钟信号控制，无需应答信号(完成信号)</li><li>主存总是在确定的时间内准备好数据</li><li>CPU送出地址和读命令后，总是在确定的时间取数据</li><li>存储器芯片必须支持同步方式，如SDRAM芯片</li></ol></li></ul><p>SRAM同步存储芯片:</p><ul><li>每步操作都在系统时钟控制下进行(上升沿和下降沿)</li><li>有确定的等待时间(读命令开始到数据线有效的时间)因此无需信号沟通</li><li>多体(缓冲器)交叉存取</li><li>突发传输方式: 一个时钟周期内连续传送多个数据。在一个时钟周期内SDRAM可以突发传输1个数据，DDR SDRAM可以突发传输2个数据，DDR2可以突发传输4个数据，DDR3可以突发传输8个数据。</li></ul><h3 id="存储器容量扩展"><a class="markdownIt-Anchor" href="#存储器容量扩展"></a> 存储器容量扩展</h3><p>由前面可以知道存储器最小编址单位是字节，而一个字节内有8位。当存储器容量不足时，即需要扩展，存储器容量的扩展可以有字扩展、位扩展和字位同时扩展三种情况。</p><p><strong>字扩展例</strong>: 用16K <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 8位芯片扩成64K <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 8位存储器需几个芯片？地址范围各为什么？<br /><b>芯片位数与存储器位数相同，因此位方向无需位扩展，字方向扩展需要4个芯片。</b>每个芯片16k=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>4</mn></mrow><annotation encoding="application/x-tex">2^14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">4</span></span></span></span>，<b>因此片内地址有14位，4片芯片需要2位进行片选，存储器编址应为16位。</b>第一片地址范围为<code>0000 0000 0000 0000(0000H) ~ 0011 1111 1111 1111(3FFFH)</code>，第二片地址范围为<code>0100 0000 0000 0000(4000H) ~ 0111 1111 1111 1111(7FFFH)</code>，第三片地址范围为<code>1000 0000 0000 0000(8000H) ~ 1011 1111 1111 1111(BFFFH)</code>，第四片地址范围为<code>1100 0000 0000 0000(C000H) ~ 1111 1111 1111 1111(FFFFH)</code>。</p><p><strong>位扩展例</strong>: 用4K <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 1位芯片构成4K <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 8位存储器需几个芯片？地址范围各是多少？<br /><b>芯片字地址与存储器字地址相等，字方向无需扩展，在位方向需要扩展8倍，因此需要8个芯片。</b>因为按字节编址，字地址总共为4k=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">2^12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>因此需要12位做地址编码，8个芯片的地址范围均为<code>0000 0000 0000(000H) ~ 1111 1111 1111(FFFH)</code>。<b>而无需片选，因为芯片地址线与读/写控制线相接，数据线需要单独引出。</b></p><p><strong>字位同时扩展例</strong>: 16K×4位芯片构成64K×8位存储器需几个芯片，地址范围各是多少？<br /><b>位方向需要扩展2倍，字方向需要扩展4个芯片，因此需要4 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2=8张芯片因为有字扩展，因此同样有片选字段和片内地址两部分组成编址，地址范围与字扩展例相同，位扩展数据线需单独引出。</b>第一片地址范围为<code>0000 0000 0000 0000(0000H) ~ 0011 1111 1111 1111(3FFFH)</code>，第二片地址范围为<code>0100 0000 0000 0000(4000H) ~ 0111 1111 1111 1111(7FFFH)</code>，第三片地址范围为<code>1000 0000 0000 0000(8000H) ~ 1011 1111 1111 1111(BFFFH)</code>，第四片地址范围为<code>1100 0000 0000 0000(C000H) ~ 1111 1111 1111 1111(FFFFH)</code>。</p><h4 id="扩展后地址分配和片选逻辑"><a class="markdownIt-Anchor" href="#扩展后地址分配和片选逻辑"></a> 扩展后地址分配和片选逻辑</h4><p>存储器寻址逻辑:</p><ul><li>芯片内寻址系统</li><li>芯片外地址分配和片选逻辑</li></ul><p><img src="address_distribute.png" alt="地址分配" /><br /><img src="chips_select.png" alt="片选" /></p><h2 id="高速缓冲存储器cache"><a class="markdownIt-Anchor" href="#高速缓冲存储器cache"></a> 高速缓冲存储器(Cache)</h2><p><b>程序访问的局部性: 空间局部性和时间局部性，原因: 指令按序存放，地址连续，循环程序段或子程序重复执行，数据连续存放，数组元素重复、按序访问。</b><br />为加快访存速度提出了cache的概念。<b>cache: 在CPU和主存之间的一个快速小容量的存储器，其中总是存放最活跃(被频繁访问)的程序和数据</b>，由于程序访问的局部性特征，大多数情况下，CPU能直接从cache中取得指令和数据，而不必访问主存。</p><h3 id="cache组成与原理"><a class="markdownIt-Anchor" href="#cache组成与原理"></a> cache组成与原理</h3><p>cache是一种小容量高速缓冲存储器，它由SRAM组成，直接制作在CPU芯片内，速度几乎与CPU一样快。程序运行时，CPU使用的一部分数据/指令会预先成批拷贝在cache中，<strong>cache的内容是主存储器中部分内容的映象</strong>。当CPU需要从内存读(写)数据或指令时，先检查cache，若有，就直接从cache中读取，而不用访问主存储器。</p><pre><code class="mermaid" >graph TD    Start("开始")    AD["CPU给出主存地址AD"]    Judge{"CPU读写指令或数据"}    Cache_send["从cache中取信息送CPU"]    MM_fetch["从主存取出AD单元所在块"]    cache_spare["在cache中找到一个空闲行"]    MM_send["将AD单元内容送CPU"]    MM_project_cache["将主存块的数据拷贝到cache中"]    End("结束")    Start-->AD    AD-->Judge    Judge-->|"是"|Cache_send    Cache_send-->End    Judge-->|"否"|MM_fetch    MM_fetch-->cache_spare    cache_spare-->MM_send    cache_spare-->MM_project_cache    MM_send-->End    MM_project_cache-->End</code></pre><h3 id="cache实现"><a class="markdownIt-Anchor" href="#cache实现"></a> cache实现</h3><p>cache结构为:</p><table><thead><tr><th style="text-align:center">V</th><th style="text-align:center">TAG</th><th style="text-align:center">DATA</th></tr></thead><tbody><tr><td style="text-align:center">有效位</td><td style="text-align:center">标志位</td><td style="text-align:center">数据区</td></tr></tbody></table><ul><li>V: 有效位，表示该行cache是否有效</li><li>TAG: 标志位，表示该行cache来源于主存的哪个主存块群或主存块号或组群(根据映射关系决定)</li><li>DATA: 数据区，存放主存数据的复制</li></ul><ol><li>分块: 把访问的局部主存区域设定为块，将整个主存空间分为多个块。主存每次和cache之间的传送单位为一个块的大小，根据块大小将主存划分为不同的块</li><li>主存块与cache行进行映射: cache行数量远远小于主存块数量，因此需要将主存块映射到cache行，共有以下三种映射方式:<ul><li>直接映射: <strong>即取模运算映射</strong>，cache行号=主存块号 mod cache行数，如cache行数16行，则第100号块映射行号=100 mod 16 = 4，<strong>注意编号都是从0开始。</strong><br />主存块群的概念: 对所有主存块而言，每cache行数个块组成一个群，因此主存块号就可以分为主存块群号和cache群号两部分，因此可以快速得到cache行号。<br />例: 设cache有16行，主存有2048块，一个块容量为512B。<br /><img src="block_and_Bgroup.png" alt="分块和划块群" /><br /><img src="direct_mapping.png" alt="直接映射地址划分" /><br /><b>则地址为<code>0000 0010 0010 0000 1100</code>的块位于cache中的第一行。前七位<code>0000 001</code>=1块群，中四位<code>0001</code>=1块因此该地址位于主存第一块群第一块，对应cache中第一行(从0开始)。</b><br />直接映射的特点:<ul><li>实现简单，命中检测时间短</li><li>无需考虑淘汰（替换）问题</li><li>但不够灵活，Cache存储空间得不到充分利用，命中率低<br />例如，对于16行的Cache，若要将主存第0块与第16块同时复制到Cache中。<br />由于它们都只能复制到Cache第0行，即使<strong>其它行空闲</strong>，也有一个主存块不能写入cache。这样就会产生频繁的cache装入</li></ul></li><li>全相联映射: <strong>主存中任意的一块都可以装载进cache的任意一行，而没有固定的映射方式。cache行内的TAG字段即为主存块号。</strong><br />例: 设cache有16行，主存有2048块，一个块容量为512B。<br />不再分群，任何一块都可映射进空闲行。<br /><img src="all_direct_mapping.png" alt="全相联映射地址划分" /><br /><b>则地址为<code>0000 0001 1110 0000 1000</code></b>可能位于cache中的任意行。前十一位<code>0000 0001 111</code>=15块标志着其来源于主存的第十五块，因此在查询cache时需要同时比较所有cache行的TAG字段，找到主存块号为15的行然后送CPU。</li><li>组相联映射: <b>组相联映射是直接映射和全相联映射两者的结合将cache分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>个组，每个主存块只能映射到一个固定组，每组的行数称为路，但可以在组内选择任何一行进行映射。cache组号=主存块号 mod cache组数，行号为组内任意空闲行。</b><br />例: 设cache有16行，主存有2048块，一个块容量为512B。<br /><img src="block_and_Ggroup.png" alt="分块和划组群" /><br /><b>则地址为<code>0000 0001 0010 0000 1100</code>位于第一组内的任意空闲行，前八位<code>0000 0001</code>=1组群，中三位<code>001</code>=1组，在查询cache时需要对组内所有行进行通过比较TAG，再送CPU</b><br />当通过全相联映射和组相联映射时，可能找到的行均为非空闲状态，因此需要从多个非空闲行中选择一个淘汰掉并装入新块，这就<strong>需要替换算法来进行选择</strong>。常用的替换算法有:</li><li>FIFO: 先进先出算法，把最线进入的块淘汰掉</li><li>LRU: 最近最少使用算法，即最近未被使用的行被替换。</li><li>LFU: 最不经常用算法</li><li>Random: 随机替换算法，随机选择一行进行替换。</li></ul></li><li>保存cache与主存一致: 因为cache中的内容是主存块的副本，当对cache中的内容进行更新时，就存在Cache和主存如何保持一致的问题。对写操作而言有两种情况:<ul><li>写命中: 要写的单元已经在cache中，处理方式有:<ul><li>Write Through(全写): 同时写cache和主存，但可以在cache和主存见增加缓存来提高效率</li><li>Write Back(只写cache): 只写cache，主存不变，可以在cache增加修改位，当被替换时才回写内存，但实现很复杂</li></ul></li><li>写未命中: 要写的单元不在cache中<ul><li>Write Allocate(写分配): 将主存块装入cache然后同时更新cache和主存</li><li>Not Write Allocate(不写分配): 直接写主存而不将主存装入cache</li></ul></li></ul></li></ol><h2 id="虚拟存储器virtual-memory"><a class="markdownIt-Anchor" href="#虚拟存储器virtual-memory"></a> 虚拟存储器(Virtual Memory)</h2><p>VM的思想: 把<strong>地址空间</strong>和<strong>主存容量</strong>的概念区分开来。程序员在地址空间里编写程序，而程序则在真正的内存中运行。<strong>由一个专门的机制实现地址空间和实际主存之间的映射。</strong></p><h3 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h3><p>基本思想:</p><ul><li>内存被分为固定长且小的存储块: 实页(页框)</li><li>进程被划分为固定长的程序块: 页(虚页)</li><li>程序块可装到内存中可用的存储块中</li><li>通过<strong>页表</strong>实现<strong>逻辑地址</strong>与<strong>物理地址</strong>的转换(从虚页到实页，页表存储在主存中)</li></ul><p><b>无需将进程全部页均装入到内存中，而是通过按需调页的方式分配内存，当需要时才从外存调页进入内存。</b></p><h3 id="早期分页实现"><a class="markdownIt-Anchor" href="#早期分页实现"></a> 早期分页实现</h3><p>早期内存只有一个页框(即整个内存大小作为一个页)，<strong>将地址空间按照页框大小进行分割</strong>。<br /><img src="early_page.png" alt="早期分页" /><br />将地址空间执行到某个区间时，把该区间的地址自动映射到0~4095之间，其余部分在外存中存储。</p><h3 id="现代虚拟存储技术"><a class="markdownIt-Anchor" href="#现代虚拟存储技术"></a> 现代虚拟存储技术</h3><p><img src="current_page.png" alt="现代虚拟存储技术" /></p><table><thead><tr><th style="text-align:center">装入位</th><th style="text-align:center">修改位</th><th style="text-align:center">替换控制位</th><th style="text-align:center">其他···</th><th style="text-align:center">实页号(八进制)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">···</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">···</td><td style="text-align:center">13</td></tr></tbody></table><p>虚页号是页表从上到下的行数，从0开始计算。<br /><strong>页表的项数理论上由虚拟地址空间大小决定，即理论上每个进程都可以占据全部虚拟地址空间。</strong><br /><img src="page_example.png" alt="页表" /></p><ul><li>未分配页: 进程的虚拟地址空间中&quot;空洞&quot;对应页(VP0、VP4)</li><li>已分配的缓存页: 有内容并已装入主存的页(VP1、VP2、VP5)</li><li>已分配的未缓存页: 有内容但未装入主存的页(VP3、VP6)</li></ul><p><b>虚页与实页之间采用全相联方式进行映射，但高位地址为虚页号</b><br />当使用逻辑地址去查询页表得到物理地址时可能会出现两种异常情况:</p><ul><li>缺页: V位为0时即为缺页。<br />处理方法: <b>阻塞操作指令，从外存将该页读到内存中。</b>若内存没有空间，则还要从内存选择一页替换到磁盘上，替换算法类似于cache，采用回写法，淘汰时，根据修改位位确定是否要写磁盘</li><li>保护违例(访问违例): 当存取权限与具体操作不相符时发生。<br />处理方法: <b>指令阻塞，进程终止，抛出异常。</b></li></ul><h3 id="tlb快表"><a class="markdownIt-Anchor" href="#tlb快表"></a> TLB(快表)</h3><p><strong>把经常要查的页表项放到cache中，这种在cache中的页表项组成的页表称为Translation Lookaside Buffer或TLB(快表)。通过TLB可以减少到内存查页表的次数</strong><br />快表中的页表项比主存中的页表项多一个tag标志: TLB item = tag + page item<br /><img src="tlb.png" alt="快表" /><br />因此主存中的页表项一定多于cache中的快表页表项，因此同样存在映射方法，或直接映射或全相联映射或组相联映射。当为全相联映射时，虚页号需要与快表中每个tag相比较。当为组相联时，需要与组内每个tag相比。</p><h2 id="层次结构存储系统下cpu访存过程"><a class="markdownIt-Anchor" href="#层次结构存储系统下cpu访存过程"></a> 层次结构存储系统下CPU访存过程</h2><p>CPU访存过程如流程图所示:</p><pre><code class="mermaid" >flowchart TD    VA["CPU给出虚拟地址VA"]    TLB_judge{"对应页表项在TLB中?"}    VA-->TLB_judge        subgraph "TLB缺失处理"        MM_page["访问主存页表"]        MM_judge{"页表项在主存中?"}        TLB_update["更新TLB并将VA转为物理地址PA"]        MM_page-->MM_judge    end    TLB_judge-->|否|MM_page    TLB_judge-->|是|TLB_update    subgraph "缺页处理"        MM_spare{"主存存在空闲页框?"}        MM_judge-->|"否，缺页"|MM_spare        MM_replace["从主存中换出一页"]        MM_write["从外存读出一页到主存"]        MM_update["更新页表和TLB并将VA转换为物理地址PA"]        MM_spare-->|是|MM_write        MM_spare-->|否|MM_replace        MM_replace-->MM_write        MM_write-->MM_update    end    VA2PA["VA转换为物理地址PA"]    TLB_update-->VA2PA    MM_update-->VA2PA        cache_judge{"对应主存块在cache中?"}    VA2PA-->cache_judge    subgraph "cache缺失处理"        cache_spare{"cache存在空闲页框?"}        cache_replace["从cache中换出一行"]        cache_write["从内存读出一行到cache并标记有效位"]        cache_spare-->|是|cache_write        cache_spare-->|否|cache_replace        cache_replace-->cache_write    end    get_cache["从cache中读取数据"]    cache_judge-->|是|get_cache    cache_judge-->|否|cache_spare    cache_write-->get_cache</code></pre><p><img src="overall_process.png" alt="访存过程" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令流水线</title>
    <link href="/2022/06/11/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2022/06/11/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-6-cpu-pipelining"><a class="markdownIt-Anchor" href="#chapter-6-cpu-pipelining"></a> Chapter 6: CPU Pipelining</h1><h2 id="流水线数据通路和控制逻辑"><a class="markdownIt-Anchor" href="#流水线数据通路和控制逻辑"></a> 流水线数据通路和控制逻辑</h2><p><strong>指令分阶段执行</strong>可以使硬件处理更高效并更加充分利用硬件，而降低指令的运行时间。<br /><img src="load_instruction.png" alt="Load指令分阶段" /></p><ul><li>Fetch(取指): 取指令并计算PC+4，<strong>使用部件: PC、Adder</strong></li><li>Reg/Dec(取数和译码): 取数同时译码，<strong>使用部件: 寄存器读口、指令译码器</strong></li><li>Exec(执行): 计算内存单元，<strong>使用部件: 扩展器、ALU</strong></li><li>Mem(读存储器): 从MDR读取数据，<strong>使用部件: MDR，MAR</strong></li><li>Wr(写寄存器): 写入寄存器，<strong>使用部件: 寄存器写口</strong></li></ul><p>通过分析其他类型指令也可将指令的执行分为使用不同部件的阶段，因此可以<strong>实现流水线来更加高效的利用硬件部件</strong>。</p><h3 id="单周期处理器模型和流水线性能比较"><a class="markdownIt-Anchor" href="#单周期处理器模型和流水线性能比较"></a> 单周期处理器模型和流水线性能比较</h3><p>假设: 取指2ns，寄存器读1ns，ALU操作2ns，存储器读2ns，寄存器写1ns，假定控制单元、PC访问、信号传递等没有延迟。</p><ul><li>单周期: 时钟周期=2+1+2+2+1=8ns，N条指令执行时间=8 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> Nns</li><li>流水线最长阶段=2ns，每条指令执行时间=2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 5=10ns，N条指令执行时间=N <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2+4 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 = (N+4) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2ns</li></ul><p>当N&gt;&gt;4时，流水线效率是单周期效率的4倍。<strong>流水线方式下，单条指令执行时间不能缩短，但能大大提高指令吞吐率！</strong></p><p>流水线CPU对指令集的要求:</p><ul><li>指令长度尽量一致，有利于简化取指令和指令译码操作</li><li>格式少，且源寄存器位置相同，有利于在指令功能未知时就可取操作数</li><li>若位置随指令不同而不同，则需先确定指令类型才能取寄存器编号</li><li>内存中&quot;对齐&quot;存放，有利于减少访存次数并使流水线规整</li></ul><p>总结: 规整、简单和一致等特性有利于指令的流水线执行。</p><h3 id="mips指令子集流水线数据通路"><a class="markdownIt-Anchor" href="#mips指令子集流水线数据通路"></a> MIPS指令子集流水线数据通路</h3><p><img src="load_instruction.png" alt="Load指令分阶段" /><br />每个周期五个功能部件都在同时工作，<strong>后面指令在前一指令完成取指后马上开始</strong>，虽每个load指令仍然需要五个周期完成，但吞吐率(throughput)提高很多，理想情况下有:</p><ul><li>每个周期有一条指令进入流水线</li><li>每个周期都有一条指令完成</li><li>每条指令的有效周期数(CPI)为1<br /><img src="load_pipeline.png" alt="Load指令流水线" /></li></ul><p>在上面分析了Load指令可以分为5个阶段，然而R型指令只需要分为4个阶段即可完成。<br /><img src="r_instruction.png" alt="R型指令分阶段" /></p><ul><li>Fetch(取指): 取指令并计算PC+4，<strong>使用部件: PC、Adder</strong></li><li>Reg/Dec(取数和译码): 取数同时译码，<strong>使用部件: 寄存器读口、指令译码器</strong></li><li>Exec(执行): 在ALU中进行操作运算，<strong>使用部件: ALU</strong></li><li>Wr(写寄存器): 写入寄存器，<strong>使用部件: 寄存器写口</strong></li></ul><p>从R型指令的分阶段可以看到，<strong>R型指令只需要4个阶段即可完成一条指令而无需读存储器阶段</strong>，如果直接将R型指令和Load指令在同一流水线执行则会<b>出现资源冲突(结构冒险)</b>情况。<br /><img src="resource_conflict.png" alt="资源冲突" /><br />资源冲突: 一个功能部件同时被多条指令使用的现象，因此为了流水线顺利工作，<strong>每个功能部件每条指令只能用一次，每个功能部件必须在相同的阶段被使用</strong>，因此为了保证R型指令与Load指令不会出现资源冲突，<strong>需要将R型指令的Wr操作延后一个周期执行，在R型指令的Mem阶段为空操作noop。</strong><br /><img src="r_load_pipeline.png" alt="R型指令与Load指令流水线" /></p><p>Store指令同样也可以用4个阶段完成指令内容，因为不需要将结果写入寄存器。<br /><img src="store_instruction.png" alt="Store指令分阶段" /></p><ul><li>Fetch(取指): 取指令并计算PC+4，<strong>使用部件: PC、Adder</strong></li><li>Reg/Dec(取数和译码): 取数同时译码，<strong>使用部件: 寄存器读口、指令译码器</strong></li><li>Exec(执行): 计算存储地址单元，<strong>使用部件: 扩展器、ALU</strong></li><li>Mem(写存储器): 从MDR读取数据，<strong>使用部件: MDR，MAR</strong></li></ul><p>为实现流水线，Wr阶段为NOOP。</p><p>Beq指令同样也可以用4个阶段完成指令内容，因为不需要将结果写入寄存器。<br /><img src="beq_instruction.png" alt="Beq指令分阶段" /></p><ul><li>Fetch(取指): 取指令并计算PC+4，<strong>使用部件: PC、Adder</strong></li><li>Reg/Dec(取数和译码): 取数同时译码，<strong>使用部件: 寄存器读口、指令译码器</strong></li><li>Exec(执行): ALU对两个寄存器取数进行减法，Adder计算转移地址，<strong>使用部件: 扩展器、ALU、Adder</strong></li><li>Mem(写存储器): 从MDR读取数据，<strong>使用部件: MDR，MAR</strong></li></ul><p>为实现流水线，Wr阶段为NOOP。</p><p>综上，五级流水线CPU数据通路如图所示:<br /><img src="five_stage_pipeline.png" alt="五级流水线" /><br />在每个阶段之间增加<strong>流水段寄存器</strong>，用来保存每个周期执行的结果，对程序员是透明的。</p><h4 id="取指数据通路"><a class="markdownIt-Anchor" href="#取指数据通路"></a> 取指数据通路</h4><p><img src="fetch_datapath.png" alt="取指数据通路(IUnit展开图)" /><br />取指部件主要的部件组成为<strong>PC</strong>、<strong>Adder</strong>和<strong>流水线寄存器IF/ID</strong>，因为取指令和PC+4为每条指令的公共部分，因此<strong>无需控制信号</strong>，<strong>在IF/ID中需要保存后面阶段用到的指令和PC+4的结果</strong>。</p><h4 id="译码取数数据通路"><a class="markdownIt-Anchor" href="#译码取数数据通路"></a> 译码/取数数据通路</h4><p><img src="reg_dec_datapath.png" alt="译码/取数数据通路" /><br />从IF/ID流水线寄存器中拿到指令和PC+4的值，然后根据指令的类型来译码出rs、rt、rd、imm等，同时从寄存器中取数，将取出的数据和PC+4的值存入流水线寄存器ID/EX，指令即无需再保存。译码/取数阶段也是各指令的公共部分，同样<strong>无需控制信号</strong>。</p><h4 id="执行部件数据通路"><a class="markdownIt-Anchor" href="#执行部件数据通路"></a> 执行部件数据通路</h4><p><img src="exec_datapath.png" alt="执行数据通路(Exec Unit展开)" /><br />在执行阶段各条指令的操作不同因此对ALU的控制信号也会有所不同因此<strong>需要ALUctl信号</strong>，同时不同指令的输入数处理方式也会有所不同，因此<strong>需要ALUSrc和ExtOp信号</strong>。<strong>除ALUctl由局部ALU控制器和主控制器共同产生外(ALUop与R-type信号决定选路逻辑)，其他控制信号均由主控制器产生。<strong>计算结果需要存入Ex/Mem寄存器中，可能存在的有</strong>有效内存地址、加减法计算结果、转移地址</strong>。</p><h4 id="读写存储器数据通路"><a class="markdownIt-Anchor" href="#读写存储器数据通路"></a> 读写存储器数据通路</h4><p><img src="mem_datapath.png" alt="读写存储器数据通路" /><br />与前三阶段数据通路不同，读写存储器数据通路<strong>存在反向数据流</strong>，因此可能<strong>产生数据冒险</strong>。数据通路如图中粉色与蓝绿色路线所示，在执行阶段可能完成下址计算后(beq和j指令)，需要从Ex/Mem寄存器中<strong>得到转移地址并传输回PC</strong>因此出现反向数据流，同时如果指令Mem阶段非NOOP则需要从Ex/Mem寄存器中<strong>拿到有效地址并通过MAR、MDR向存储器进行取数操作</strong>，完成后将取到数据存入Mem/Wr寄存器中，在此阶段需要MemWr等控制信号来进行不同指令的控制。</p><h4 id="写寄存器数据通路"><a class="markdownIt-Anchor" href="#写寄存器数据通路"></a> 写寄存器数据通路</h4><p><img src="wr_datapath.png" alt="写寄存器数据通路" /><br />在寄存器的回写阶段也<strong>存在反向数据流</strong>，因此也会有<strong>数据冒险</strong>产生的可能性。当Wr阶段非NOOP时，需要从Mem/Wr寄存器中拿到存储器取数的结果并写入寄存器中，而其他指令的Reg/Dec阶段可能正在使用寄存器因此可能产生数据冒险。在此过程中需要MemtoReg和RegWr信号来控制阶段的执行。</p><h3 id="mips指令子集流水线控制逻辑"><a class="markdownIt-Anchor" href="#mips指令子集流水线控制逻辑"></a> MIPS指令子集流水线控制逻辑</h3><p>与单周期CPU一样，<strong>控制信号的产生在Reg/Dec阶段</strong>，并且通过流水线寄存器实现控制信号的传递，而在每一级的传递过程中不再需要使用的控制信号就会被丢弃。如图所示:<br /><img src="control_signal.png" alt="控制信号的产生与不同级流水线的使用" /><br />为实现流水线作业，<strong>每条指令的控制信号在该指令执行期间均不能改变</strong>，因此只能在译码阶段结束时才将控制信号写入到流水线寄存器中。流水线控制器的设计理念与单周期控制器的设计理念几乎完全相同，因此不再赘述。<br /><img src="pipeline_control_unit.png" alt="流水线控制器" /></p><h2 id="流水线冒险处理"><a class="markdownIt-Anchor" href="#流水线冒险处理"></a> 流水线冒险处理</h2><p>在指令流水线中，当遇到某些情况使得流水线无法正确执行后续指令，而引起流水线阻塞或停顿，这个现象称为流水线冒险。根据引起冒险的原因不同，可以分为三种冒险:</p><ul><li>结构冒险: 同一个部件同时被不同指令所用，即使用硬件资源时发生了冲突</li><li>数据冒险:</li><li>控制冒险:</li></ul><h3 id="结构冒险及其处理方法"><a class="markdownIt-Anchor" href="#结构冒险及其处理方法"></a> 结构冒险及其处理方法</h3><p><img src="structure_risk.png" alt="结构冒险" /><br />为了避免结构冒险，规定流水线数据通路中功能部件的设置原则为:</p><ul><li>每个部件安排在特定的阶段使用。如: ALU总在指令的第三阶段使用</li><li>将Instruction Memory(Im)和Data Memory(Dm)分开</li><li><strong>将寄存器读口和写口独立开来</strong></li></ul><p><img src="structure_risk_solution.png" alt="处理方法" /></p><h3 id="数据冒险及其处理方法"><a class="markdownIt-Anchor" href="#数据冒险及其处理方法"></a> 数据冒险及其处理方法</h3><p>正如上面讨论数据通路时提到的反向数据流一样，<strong>反向数据量可能会导致后面指令用到前面指令结果时，前面指令的结果还没产生的情况</strong>，这种现象称为数据冒险。<br /><img src="data_risk.png" alt="数据冒险" /><br />采用流水线作业时，第1条指令的目的操作数是r1，它是后面几条指令的源操作数，第1条指令要到Wr阶段才写入r1，但后面的指令sub和and在此之前就读r1，or指令在Wr同时读r1，显然会得出错误的结果。</p><p>处理方法:</p><ul><li>硬件阻塞: 硬件上通过<strong>阻塞(stall)方式阻止后续指令执行</strong>，延迟到有新值以后。这种做法称为<strong>流水线阻塞</strong>，也称为<strong>插入&quot;气泡(Bubble)&quot;</strong><br /><img src="hardware_stall.png" alt="硬件阻塞" /><br />缺点: 控制比较复杂，需要改数据通路；指令被延迟三个时钟执行</li><li>软件插入NOP指令: 由编译器插入三条NOP指令，浪费三条指令的空间和时间，是最差的做法，但<strong>无需重新设计数据通路</strong><br /><img src="software_stall.png" alt="软件插入NOP指令" /></li><li>合理实现寄存器的读/写操作: 寄存器组的读口和写口是相互独立的部件，采用前半时钟周期写，后半时钟周期读的方式来进行，<strong>只能解决部分数据冒险</strong><br /><img src="register_optimization.png" alt="寄存器优化" /><br /><strong>可以解决add和or指令，但sub和and无法被这种方法解决</strong></li><li>转发技术: 有些流水线寄存器已取得需要数据但没有存到通用寄存器中，<strong>采用流水线寄存器将数据转发到ALU输入端</strong>，称为转发或旁路，<strong>但后条指令仍然需要阻塞一个时钟或添加一条NOP指令</strong><br /><img src="forwarding_technology.png" alt="转发技术" /></li><li>编译优化: 编译器通过等价逻辑来调整指令顺序从而避免数据冒险。<strong>但同样只能避免部分数据冒险</strong><br /><img src="compiler_optimization.png" alt="编译优化" /></li></ul><h3 id="控制冒险及其处理方法"><a class="markdownIt-Anchor" href="#控制冒险及其处理方法"></a> 控制冒险及其处理方法</h3><p>当遇到改变指令执行顺序的转移指令（调用、返回等）、异常和中断情况时，在形成转移目的地址之前，流水线中已取了后续指令并在执行，这时就需要清除流水线中的部分指令的执行。<br /><img src="control_risk.png" alt="控制冒险" /><br />Beq指令在第4周期取出，但要在Mem阶段才确定“是否转移”，即在第7周期目标地址才被送到PC输入端，第8周期才取出目标地址处的指令执行。因此<b>在取目标指令之前，已有三条指令被取出，取错了三条指令。</b>发生转移时，要在流水线中清除Beq后面的三条指令，分别在Exec 、Reg/Dec、 Ifetch段中。</p><p>处理方法:</p><ul><li>硬件上阻塞分支指令后三条指令: 当发现是转移指令时固定硬件插入三个气泡</li><li>软件插入三条NOP指令: 当软件产生指令时发现是转移指令则在其后加入三条NOP指令</li><li>分支预测:<ul><li>简单静态预测: 总是预测条件不满足(not taken)，即: 继续执行分支指令的后续指令(准确度: 65%-85%)</li><li>动态预测: 根据程序执行的历史情况进行动态预测调整(准确度: 90%)</li></ul></li><li>延迟分支: 把分支指令前面与分支指令无关的指令调到分支指令后执行，也称延迟转移</li></ul><h2 id="高级流水线技术待学"><a class="markdownIt-Anchor" href="#高级流水线技术待学"></a> 高级流水线技术(待学)</h2><p>待补全······</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中央处理器</title>
    <link href="/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2022/06/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-5-cpu"><a class="markdownIt-Anchor" href="#chapter-5-cpu"></a> Chapter 5: CPU</h1><h2 id="cpu的基本功能和基本组成"><a class="markdownIt-Anchor" href="#cpu的基本功能和基本组成"></a> CPU的基本功能和基本组成</h2><p>CPU执行指令的过程:</p><pre><code class="mermaid" >flowchart TB    subgraph "Instruction Fetch(取指阶段)"        IF("取指令")-->PC("PC+1送PC")    end    subgraph "Instruction Decode and Execute(译码和执行阶段)"       PC-->ID("指令译码")       ID-->AC("进行主存地址运算")       AC-->NF("取操作数")       NF-->CAL("进行算术/逻辑运算")       CAL-->MEM("对结果进行存储操作")    end        MEM-->IF        </code></pre><p><strong>注意: 以上每步都需检测有无&quot;异常&quot;，若有则自动切换到异常处理程序。并且会检测是否有中断请求，有则转中断处理。</strong></p><p><img src="cpu_architecture.png" alt="CPU基本组成原理" /></p><ul><li>执行部件: 主要由ALU、通用寄存器足和状态寄存器组成</li><li>控制部件: 主要由指令译码器和控制信号形成部件组成</li></ul><p><img src="sinple_cpu.png" alt="简化的CPU组成" /></p><p><b>数据通路: 指令执行过程中，数据所经过的路径，以及路径上的部件。</b>包括: <strong>ALU</strong>(运算)、<strong>通用寄存器</strong>(存储数据)、<strong>状态寄存器</strong>(存储标志位)、<strong>MMU</strong>(内存管理单元)、<strong>cache</strong>(缓存)、<strong>中断处理逻辑</strong>等。</p><p><strong>控制器</strong>: 对指令进行<strong>译码</strong>，<strong>生成指令对应的控制信号</strong>，控制数据通路的动作。它向执行部件发出控制信号，是指令的控制部件。</p><h3 id="cpu的功能及其与计算机性能的关系"><a class="markdownIt-Anchor" href="#cpu的功能及其与计算机性能的关系"></a> CPU的功能及其与计算机性能的关系</h3><p>计算机性能由三个关键因素决定:</p><ul><li>指令数目: 由ISA和编译器共同决定</li><li>CPI: 指一条指令的执行时钟周期数，由指令集决定，单周期CPU指令CPI一定为1</li><li>时钟周期: 对于单周期CPU，时钟周期等于最长的指令(一般为lw指令)的执行时间</li></ul><h3 id="指令的四个基本功能"><a class="markdownIt-Anchor" href="#指令的四个基本功能"></a> 指令的四个基本功能</h3><p>每一条指令的功能都是由以下四种基本操作的组合来实现:</p><ul><li>读取某一主存单元的内容，并将其装入某个寄存器(取指，取数)</li><li>把一个数据从某个寄存器存入给定的主存单元中(存结果)</li><li>把一个数据从某个寄存器送到另一个寄存器或者ALU(取数，存结果)</li><li>执行算术或逻辑运算(PC+1，计算地址，运算)</li></ul><p>操作功能的形式化描述语言称为寄存器传送语言RTL(Register Transfer Language)，规定如下:</p><ul><li>用R[r]表示寄存器r的内容</li><li>用M[addr]表示主存单元addr的内容</li><li>传送方向用&quot;&lt;-&quot;表示，传送源在右，传送目的在左</li><li>对于程序计数器PC，直接用PC表示其内容</li></ul><p>例如，R[$8] ← M[R[$9]+4]的含义是:<br />将寄存器$9的内容加4得到的内存地址单元的内容送寄存器$8中(偏移寻址)。</p><h3 id="数据通路的基本结构"><a class="markdownIt-Anchor" href="#数据通路的基本结构"></a> 数据通路的基本结构</h3><p>数据通路由两类元件组成:</p><ul><li>组合逻辑元件(也称操作元件)</li><li>时序逻辑元件(也称状态元件，或存储元件)</li></ul><p>数据通路由由<strong>操作元件</strong>和<strong>存储元件</strong>通过<strong>总线方式或分散方式</strong>连接而成。</p><h4 id="常用的操作元件"><a class="markdownIt-Anchor" href="#常用的操作元件"></a> 常用的操作元件</h4><ul><li>加法器(Adder): 只接受输入A、输入B和进位信号，输出加法结果和进位信号。<br /><img src="adder.png" alt="加法器" /></li><li>多路选择器(MUX): 输入n路信号和选路信号，输出选路信号对应的输入信号。<br /><img src="mux.png" alt="多路选择器" /></li><li>算术逻辑部件(ALU): 能进行多种不同运算，运算方式由ALUctl信号进行控制，输出计算结果和标志位。<br /><img src="alu.png" alt="算术逻辑部件" /></li></ul><p>操作元件(组合逻辑元件)特点:</p><ul><li>其输出只取决于当前的输入: 若输入一样，则其输出也一样</li><li>无定时: 所有输入到达后，经过一定的逻辑门延时，输出端改变，并保持到下次改变，不需要时钟信号来定时</li></ul><h3 id="数据通路的时序控制"><a class="markdownIt-Anchor" href="#数据通路的时序控制"></a> 数据通路的时序控制</h3><p>时序控制通过存储元件来实现，存储元件的特点:</p><ul><li>有专门的时钟信号来控制元件的工作</li><li>具有存储功能，在时钟控制下输入被写到电路中，直到下个时钟到达</li><li>输入端状态由时钟决定何时被写入，输出端状态随时可以读出</li></ul><p><strong>定时方式: 规定信号何时写入状态元件，一般在计算机内部均采用边沿触发方式(状态单元中的值只在时钟边沿改变，每个时钟周期改变一次。可以分为上升沿触发和下降沿触发)</strong><br /><img src="time_model.png" alt="存储元件定时模型" /></p><ul><li>Setup Time: 在触发时钟<strong>边沿之前一段时间</strong>内输入必须稳定</li><li>Hold Time: 在触发时钟<strong>边沿之后一段时间</strong>内输入必须稳定</li><li>Clock-to-Q Time: 锁存延时，在边沿后输出并<strong>不能立即变化</strong>而是需要经过一段时间后才能变化</li></ul><p><strong>只有当Clock-to-Q Time后输出才反映新的状态值。</strong></p><h4 id="常见的存储元件"><a class="markdownIt-Anchor" href="#常见的存储元件"></a> 常见的存储元件</h4><ul><li>寄存器: 能够存储n位数据的存储元件，具有输入端口进行接收输入，输出端口接收输出，并包含输入一个写使能信号，只有<strong>当写使能为1时才允许输入</strong>，作为存储元件一定有时钟信号的输入端口。<br /><img src="register.png" alt="寄存器" /></li><li>寄存器组: 是多个寄存器的组合，可以<strong>同时进行两个寄存器的读取操作或一个寄存器的写入操作</strong>。当RA和RB进行寄存器选择后，经过<strong>一个取数时间</strong>后寄存器组通过busA和busB分别将RA和RB的数据进行输出，当<strong>写使能为1时将busW的输入数据写入到RW选择的寄存器中</strong>，作为存储元件一定还有一个时钟信号的输入端口。<br /><img src="register_group.png" alt="寄存器组" /></li><li>理想存储器: Address端口作为地址选择端口，通过写使能来判断本次操作为读/写操作，当写使能为1时为写，存储器将Data In端口数据写入到选择的地址中，当写使能为0时为读，存储器将选择的地址的数据输出到Data Out。<br /><img src="ideal_memory.png" alt="理想存储器" /></li></ul><p><strong>注意: 寄存器的存储位数应与触发器数目相符合，寄存器组的寄存器选择位数应与寄存器数量一致。</strong></p><p>在数据通路中进行时序控制则必须有专门时序信号来定时，由时序信号规定何时发出什么动作。早期计算机具有三级时序系统: 机器周期 - 节拍 - 脉冲，但现代计算机已不再采用三级时序系统，在整个数据通路中定时信号就是时钟，一个时钟周期就是一个节拍。</p><p><img src="clock_cycle.png" alt="现代计算机时钟周期" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">钟</mi><mi mathvariant="normal">周</mi><mi mathvariant="normal">期</mi><mo>=</mo><mi>L</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo>+</mo><mi>L</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi><mi>P</mi><mi>a</mi><mi>t</mi><mi>h</mi><mo>+</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>p</mi><mo>+</mo><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mi>S</mi><mi>k</mi><mi>e</mi><mi>w</mi><mo stretchy="false">(</mo><mi mathvariant="normal">时</mi><mi mathvariant="normal">钟</mi><mi mathvariant="normal">偏</mi><mi mathvariant="normal">移</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">时钟周期 = Latch Prop + Longest Delay Path + Setup + Clock Skew(时钟偏移)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">钟</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">期</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">钟</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mclose">)</span></span></span></span></span></p><p><strong>操作元件输出有效信号最快出现必须在下一级状态元件的输入保持时间之后出现。</strong></p><h3 id="总线结构数据通路中四种基本功能的实现"><a class="markdownIt-Anchor" href="#总线结构数据通路中四种基本功能的实现"></a> 总线结构数据通路中四种基本功能的实现</h3><p>总线结构也可按总线数量而分为单总线连接和多总线连接方式，这里以单总线数据通路和三总线数据通路来演示四种基本操作(<strong>寄存器之间的取数</strong>、<strong>寄存器从主存取数取指</strong>、<strong>写数到主存</strong>、<strong>完成运算</strong>)的实现:</p><ul><li><p>单总线:<br /><img src="single_bus.png" alt="单总线" /></p><ol><li>寄存器之间的取数: <code>R0out, Yin</code>将寄存器数据取到ALU运算前的缓存寄存器中，仅需要1Cycle。</li><li>完成运算:<br /><code>R1out, Yin\n R2out, Add, Zin\n Zout, R3in</code><br />先从R1中取数，再将R2中数据从总线直接传送到ALU输入端口中最后将ALU计算结果写入到Z中，通过总线将Z中数据传输到R3中。</li><li>从主存中取数:<br /><code>R1out, MARin\n Read, WMFC(等待MFC返回取数成功信号)\n MDRout, R2in</code><br />MAR为存储器地址寄存器，MDR为存储器数据寄存器，将R1内地址取出送入MAR中，等待MFC应答后从MDR中取数到R2中。</li><li>写数到主存:<br /><code>R1out, MARin\n R2out, MDRin\n Write, WMFC(等待MFC返回写入成功信号)</code><br />将R1内的地址通过总线送入MAR中，将R2内的数据通过总线送入MDR中，等待MFC应答后将数据写入完成。</li></ol></li><li><p>多总线:<br /><img src="multiple_bus.png" alt="多总线" /><br />单总线中一个时钟内只允许传一个数据，因而指令执行效率很低，多总线方式可同时在多个总线上传输不同数据来提高效率。<br />实现一个时钟周期完成单条运算: <code>R1out, R2out, op, R3in</code>，通过总线同时实现R1、R2内数据的取出和传输，并通过ALU计算直接传输到R3进行存储。</p></li></ul><h2 id="单周期mips处理器的设计"><a class="markdownIt-Anchor" href="#单周期mips处理器的设计"></a> 单周期MIPS处理器的设计</h2><h3 id="mips数据通路设计"><a class="markdownIt-Anchor" href="#mips数据通路设计"></a> MIPS数据通路设计</h3><p>明确只需掌握<strong>经典7条指令</strong>的数据通路设计即可。</p><ul><li>add: add rd, rs, rt(rd = rs + rt)</li><li>sub: sub rd, rs, rt(rd = rs - rt)</li><li>ori: ori rt, rs, imm16(rt = rs | imm16)</li><li>lw: lw rt, imm16(rt = [rs + imm16])</li><li>sw: sw rt, imm16([rs + imm16] = rt)</li><li>beq: beq rs, rt, imm16(if rs == rt, PC = PC + 4 + (imm16 &lt;&lt; 2))</li><li>j: j target26(PC = PC[31:28] + target26 + 00)</li></ul><p><b><font color='red'>在下面各指令的数据通路图中，蓝色部分部件为从上一指令数据通路增加后来完成更多指令功能的重要部件。</font></b></p><h4 id="addsub的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#addsub的rtl描述和数据通路"></a> add/sub的RTL描述和数据通路</h4><p><strong>指令: add/sub rd, rs, rt</strong>是R型指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("R[rd] <- R[rs] +/- R[rt](做运算)")    label2-->label3("PC <- PC + 4(更新PC)")</code></pre><p><img src="add_sub.png" alt="add/sub" /><br />在取指令后经控制器译码产生<strong>RegWr写使能信号=1</strong>和<strong>ALUctl控制信号=add/sub</strong>，由寄存器组提供rs、rt数据作为ALU的输入，ALU计算结果作为输入输出到busW中，如果没有产生溢出(OF=0)，则与RegWr取并运算得到1激活写使能端口将结果写入到rd寄存器中。</p><h4 id="ori的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#ori的rtl描述和数据通路"></a> ori的RTL描述和数据通路</h4><p><strong>指令: ori rt, rs, imm16</strong>是I型指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("R[rt] <- R[rs] or ZeroExt(imm16)(做运算)")    label2-->label3("PC <- PC + 4(更新PC)")</code></pre><p><img src="ori.png" alt="ori" /><br />ori指令为<strong>立即数0扩展后与rs做或运算</strong>，因此相比于add/sub指令，ori数据通路应该增加扩展器Ext，同时写入寄存器位rt而不是rd，因此在Rw口应该增加多路选择器Mux使rd和rt均可作为写入寄存器，同时ALU输入端也应该增加Mux使输入可选项可以为busB或imm16。<br />根据图中数据通路设计，RegDst信号=1(rt为写入选择器)，RegWr=1(需要写入寄存器因此写使能等于1)，ALUctr=or，ALUSrc=1(imm16作为ALU输入)。</p><h4 id="lw的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#lw的rtl描述和数据通路"></a> lw的RTL描述和数据通路</h4><p><strong>指令: lw rt, rs, imm16</strong>是访问内存指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("Addr <- R[rs] + SignExt(imm16)(计算存储单元地址)")    label2-->label3("R[rt] <- M[Addr](从地址取数据)")    label3-->label4("PC <- PC + 4(更新PC)")</code></pre><p><img src="lw.png" alt="lw" /><br />从内存中取数或存数都是采用偏移寻址的方式，因此要先对<strong>立即数做符号扩展</strong>才能计算目的数的地址，因此需要将<strong>扩展器改为支持多种扩展方式的扩展器并增加控制信号来控制扩展器的扩展方式</strong>。同时因为寄存器组的输入由ALU计算结果改为内存取出的数，<strong>在busW前应增加一个多路选择器Mux，使其可以选择ALU计算结果或内存取出的数作为写入rt。</strong><br />因为需要在rt与rd中做选择，所以RegDst=1目的寄存器位rt，RegWr=1写使能端口为1，<strong>ALUctul为addu(addu表示ALU不做溢出检查，因为用add可能会产生OF=1的异常)</strong>，ExtOP=1做符号扩展，ALUSrc=1表示imm16符号扩展结果作为ALU输入，内存需要写入到寄存器则MemtoReg=1。</p><h4 id="sw的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#sw的rtl描述和数据通路"></a> sw的RTL描述和数据通路</h4><p><strong>指令: sw rt, rs, imm16</strong>是访问内存指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("Addr <- R[rs] + SignExt(imm16)(计算存储单元地址)")    label2-->label3("Mem[Addr] <- R[rt](向内存写入数据)")    label3-->label4("PC <- PC + 4(更新PC)")</code></pre><p><img src="sw.png" alt="sw" /><br />从逻辑上说，只需要给rt的输出写到内存途径即可，因此在busB后加一个Mux可以选择ALU输入端和内存输入端即可。由于增加了内存写入功能，对内存也应有写使能信号，控制信号也应该新加一个MemWr信号，控制信号为1时内存可以写入数据。<br />因为没有对寄存器进行写操作因此RegDst=x，RegWr=0禁止写寄存器，<strong>ALUctul为addu(addu表示ALU不做溢出检查，因为用add可能会产生OF=1的异常)</strong>，ExtOP=1做符号扩展，MemWr=1写入内存，MemtoReg=x因为寄存器的写使能已经为0。</p><h4 id="beq的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#beq的rtl描述和数据通路"></a> beq的RTL描述和数据通路</h4><p><strong>指令: beq rs, rt, imm16</strong>是条件跳转指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("Cond <- R[rs] == R[rt](做减法比较rs和rt中的内容)")    label2-->label3("if (Cond eq 0) PC <- PC + 4 + SignExt(imm16) * 4(计算下地址并跳转)")    label3-->label4("else PC <- PC + 4(不跳转)")</code></pre><p><img src="beq.png" alt="beq" /><br /><strong>beq指令为相等跳转，bne为不相等跳转，实现思路为rs内容与rt内相减</strong>，通过ALU的标志位ZF来判断rs内容与rt内容是否相等，将标志位传递给下址计算部件即可。因此只需**增加下址计算部件(将PC+4功能同时实现)**即可完成数据通路。<br />条件转移没有对寄存器和存储器进行读写操作因此RegWr=MemWr=0，因为有写使能做保护RegDst=MenmtoReg=x可以为任意值，ALUctl仍然取addu无符号加法防止溢出来实现转移地址的计算，ALUSrc=0因为无立即数参加，但为下址计算部件设定转移信号Branch=1，来激活下址计算部件。</p><p>下址计算部件的设计: PC是32位地址，当</p><ul><li>顺序执行时: PC&lt;31:0&gt; = PC&lt;31:0&gt; + 4</li><li>转移执行时: PC&lt;31:0&gt; = PC&lt;31:0&gt; + SignExt(imm16) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 4</li></ul><p>因为MIPS按字节编址，因此PC的值总是4的倍数，即后两位为00，去除这2位，PC只需要30位即可。下地址计算逻辑简化为:</p><ul><li>顺序执行时: PC&lt;31:2&gt; = PC&lt;31:2&gt; + 1</li><li>转移执行时: PC&lt;31:2&gt; = PC&lt;31:2&gt; + 1 + SignExt(imm16)</li></ul><p><strong>在取指令时将PC&lt;31:2&gt;串接<code>00</code>即可得到32位PC。</strong><br /><img src="next_address.png" alt="下址计算部件" /><br /><strong>因为下址计算只涉及到加法因此只需要使用Adder即可而不需更复杂功能更全面的ALU部件。</strong></p><h4 id="j的rtl描述和数据通路"><a class="markdownIt-Anchor" href="#j的rtl描述和数据通路"></a> j的RTL描述和数据通路</h4><p><strong>指令: j target26</strong>是无条件跳转指令的代表。</p><pre><code class="mermaid" >graph TD    label1("M[PC](取指令)")-->label2("PC<31:2> <- PC<31:28>串接target(计算转移地址)")</code></pre><p><img src="j.png" alt="j" /><br />跳转指令的范围: 只能在j指令所在的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>8</mn><mo>=</mo><mn>256</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^28=256MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>页面内，页面号与j指令相同PC&lt;31:28&gt;。</p><h4 id="mips-cpu数据通路"><a class="markdownIt-Anchor" href="#mips-cpu数据通路"></a> MIPS CPU数据通路</h4><p>在上面7条指令的数据通路可以看出，PC取指和下址计算与地址转移是每条指令的公共操作，因此可以把部分合成一个取指部件。<br /><img src="instruction_fetch.png" alt="取指部件" /><br /><img src="mips_cpu.png" alt="MIPS CPU数据通路" /><br /><strong>通过一条条指令的实现而推导出了能实现开始所说的7条指令的MIPS CPU的数据通路。推导过程是Computer Organization and Architecture这门课的核心。</strong></p><h3 id="单周期cpu控制器设计"><a class="markdownIt-Anchor" href="#单周期cpu控制器设计"></a> 单周期CPU控制器设计</h3><p>ISA确定后，控制器设计大致步骤如下:</p><ol><li>分析每条指令的功能并用RTL表示</li><li>确定数据通路</li><li>确定每个元件所需控制信号的取值</li><li>生成一张指令与控制关系的表</li><li>根据表得到每个控制信号的逻辑表达式</li></ol><p>控制信号产生的逻辑在数据通路设计与分析中已分析，这里直接给出不同指令的控制信号值，<strong>需要掌握根据数据通路计算出控制信号的能力。</strong></p><h4 id="addsub控制信号"><a class="markdownIt-Anchor" href="#addsub控制信号"></a> add/sub控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">add/sub</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="ori控制信号"><a class="markdownIt-Anchor" href="#ori控制信号"></a> ori/控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">or</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="lw控制信号"><a class="markdownIt-Anchor" href="#lw控制信号"></a> lw控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">addu</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="sw控制信号"><a class="markdownIt-Anchor" href="#sw控制信号"></a> sw控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">1</td><td style="text-align:center">addu</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="beq控制信号"><a class="markdownIt-Anchor" href="#beq控制信号"></a> beq控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">sub</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="j控制信号"><a class="markdownIt-Anchor" href="#j控制信号"></a> j控制信号</h4><table><thead><tr><th style="text-align:center">RegDst</th><th style="text-align:center">ALUSrc</th><th style="text-align:center">ALUctr</th><th style="text-align:center">MemWr</th><th style="text-align:center">ExtOP</th><th style="text-align:center">RegWr</th><th style="text-align:center">MemtoReg</th><th style="text-align:center">Branch</th><th style="text-align:center">Jump</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">x</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="生成控制器表"><a class="markdownIt-Anchor" href="#生成控制器表"></a> 生成控制器表</h4><p><img src="control_unit.png" alt="控制器表" /></p><h4 id="设计控制器部件"><a class="markdownIt-Anchor" href="#设计控制器部件"></a> 设计控制器部件</h4><p><strong>控制器 = 主控制单元 + ALU局部控制单元</strong><br /><img src="control.png" alt="控制器" /><br />ALUctr有6种操作: sdd, sub, or, and, addu, subu，因此需要3位来表示。在译码后将op传给主控制器产生ALUop信号，func传给ALU局部控制器，对于<strong>非R型指令ALUctl=ALUop</strong>，<strong>R型指令由func译码产生</strong>。</p><h5 id="alu局部控制器"><a class="markdownIt-Anchor" href="#alu局部控制器"></a> ALU局部控制器</h5><p><strong>非R型指令的ALUop产生方式为:</strong><br /><img src="aluop.png" alt="ALUop" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>L</mi><mi>U</mi><mi>o</mi><mi>p</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>=</mo><mi>b</mi><mi>e</mi><mi>q</mi><mo separator="true">,</mo><mi>A</mi><mi>L</mi><mi>U</mi><mi>o</mi><mi>p</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>=</mo><mi>o</mi><mi>r</mi><mi>i</mi><mo separator="true">,</mo><mi>A</mi><mi>L</mi><mi>U</mi><mi>o</mi><mi>p</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ALUop&lt;2&gt;=beq, ALUop&lt;1&gt;=ori, ALUop&lt;0&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p><strong>R型指令的ALUctl的产生:</strong><br /><img src="aluctl.png" alt="ALUctl" /></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>L</mi><mi>U</mi><mi>c</mi><mi>t</mi><mi>r</mi><mo>&lt;</mo><mn>2</mn><mo>&gt;</mo><mo>=</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo separator="true">,</mo><mi>A</mi><mi>L</mi><mi>U</mi><mi>c</mi><mi>t</mi><mi>r</mi><mo>&lt;</mo><mn>1</mn><mo>&gt;</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mi>L</mi><mi>U</mi><mi>c</mi><mi>t</mi><mi>r</mi><mo>&lt;</mo><mn>0</mn><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ALUctr&lt;2&gt;=func&lt;1&gt;, ALUctr&lt;1&gt;=1, ALUctr&lt;0&gt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><h6 id="主控制单元"><a class="markdownIt-Anchor" href="#主控制单元"></a> 主控制单元</h6><p><img src="main_control_unit.png" alt="主控制单元真值表" /><br />通过真值表根据卡诺图可以得到控制信号的逻辑表示式，这里控制信号产生仅用于7条指令:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>g</mi><mi>W</mi><mi>r</mi><mo>=</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">)</mo><mo>+</mo><mi>o</mi><mi>r</mi><mi>i</mi><mo>+</mo><mi>l</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">RegWr=(R-type)+ori+lw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>L</mi><mi>U</mi><mi>S</mi><mi>r</mi><mi>c</mi><mo>=</mo><mi>o</mi><mi>r</mi><mi>i</mi><mo>+</mo><mi>l</mi><mi>w</mi><mo>+</mo><mi>s</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">ALUSrc=ori+lw+sw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>g</mi><mi>D</mi><mi>s</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">RegDst=(R-type)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>e</mi><mi>m</mi><mi>t</mi><mi>o</mi><mi>R</mi><mi>e</mi><mi>g</mi><mo>=</mo><mi>l</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">MemtoReg=lw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>e</mi><mi>m</mi><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo>=</mo><mi>s</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">MemWrite=sw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>h</mi><mo>=</mo><mi>b</mi><mi>e</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Branch=beq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>u</mi><mi>m</mi><mi>p</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">Jump=j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>x</mi><mi>t</mi><mi>O</mi><mi>p</mi><mo>=</mo><mi>l</mi><mi>w</mi><mo>+</mo><mi>s</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">ExtOp=lw+sw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p><img src="control_pla.png" alt="控制信号产生电路" /></p><h4 id="控制器设计小结"><a class="markdownIt-Anchor" href="#控制器设计小结"></a> 控制器设计小结</h4><ul><li>控制器设计的关键是找出指令格式中规定指令功能(类型)的字段与各条指令所需要的控制信号之间的关系。<strong>MIPS指令中有op和func两个字段用来表示指令的功能。</strong><ol><li>R型指令: 所有指令的op字段都为000000，各指令的func字段用来产生ALU的控制信号，决定执行的操作(加、减、逻辑与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span>)，其它数据通路的控制信号各指令都相同(仅考虑三寄存器操作数)</li><li>其他类型指令：没有func字段，各指令的op字段不同，它产生包括ALU的所有数据通路的控制信号</li></ol></li><li>控制器结构分成主控制器和ALU局部控制器两部分<ol><li>ALU局部控制器是为R型指令产生ALU的控制信号，其输入为func字段</li><li>主控制器产生非R型指令的所有控制信号，以及R型指令的除ALU控制信号外的其他控制信号，其输入为op字段</li><li>将主控制器产生的ALU控制信号与ALU局部控制器的输出信号通过一个多路选择器合并后作为最终的ALU控制信号。多路选择器的选择信号(R-Type)由主控制器产生</li></ol></li></ul><h2 id="mips单周期计算机的性能"><a class="markdownIt-Anchor" href="#mips单周期计算机的性能"></a> MIPS单周期计算机的性能</h2><p>**在本章开始说过计算机性能由三个关键因素决定: 指令数目、CPI、时钟周期。**单周期CPU的CPI一定为1，MIPS单周期CPU指令数设计过程如上，因此只支持7条指令，评价其性能只需考虑时钟周期宽度的确定。</p><p><strong>在MIPS中lw指令的执行时间最长</strong>，因此时钟周期宽度为lw指令执行所需时间！<br /><img src="lw_time.png" alt="lw指令执行图" /></p><p>例: 在单周期处理器中，各主要功能单元的操作时间为: 存储单元200ps，ALU和加法器100ps，寄存器组(读/写)50ps，MUX、控制单元、PC、扩展器和传输线路都没有延迟。程序中各类指令占比: 25%取数、10%存数、45%ALU、15%分支、5%跳转，该程序共有n条指令。</p><ol><li>计算各指令执行时间(以lw指令为例): 时钟周期为最长指令执行时间，一般为load类型指令。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>w</mi><mo>=</mo><mn>50</mn><mo>+</mo><mn>100</mn><mo>+</mo><mn>50</mn><mo>+</mo><mn>50</mn><mo>+</mo><mn>100</mn><mo>+</mo><mn>200</mn><mo>+</mo><mn>50</mn><mo>=</mo><mn>600</mn></mrow><annotation encoding="application/x-tex">lw=50+100+50+50+100+200+50=600</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span></span></span></span>(PC取指–&gt;下址计算–&gt;放入PC–&gt;寄存器取数–&gt;ALU计算有效地址–&gt;存储器取数–&gt;写入寄存器)</li><li>计算时钟周期: 经过第一步得到所有指令执行时间分别为: R-type=400ps, lw=600ps, sw=550ps, Branch=350ps, Jump=200ps，因此时钟周期为600ps。</li><li>计算总时间: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi>n</mi><mo>×</mo><mi>c</mi><mi>i</mi><mi>r</mi><mi>c</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">time=n\times circle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span></li></ol><h2 id="微程序控制原理与异常处理"><a class="markdownIt-Anchor" href="#微程序控制原理与异常处理"></a> 微程序控制原理与异常处理</h2><h3 id="微程序设计"><a class="markdownIt-Anchor" href="#微程序设计"></a> 微程序设计</h3><h4 id="微程序控制器和硬连线控制器的对比"><a class="markdownIt-Anchor" href="#微程序控制器和硬连线控制器的对比"></a> 微程序控制器和硬连线控制器的对比</h4><ul><li>硬连线控制器:<ul><li>优点: <strong>速度快</strong>，适合于简单或规整的指令系统，如MIPS指令集</li><li>缺点: 它是一个<strong>多输入/多输出</strong>的巨大逻辑网络。对于复杂指令系统来说，<strong>结构庞杂，实现困难；修改、维护不易；灵活性差</strong></li></ul></li><li>微程序控制器:<ul><li>仿照程序设计的方法，编制每条指令对应的微程序，每个微程序由若干条微指令构成，一条微指令包含若干个微命令，<strong>每个微命令就是一个控制信号</strong></li><li><strong>所有指令对应的微程序放在只读存储器</strong>中，执行某条指令就是取出对应微程序中的各条微指令，对微指令译码产生对应的微命令(即控制信号)。<strong>这个只读存储器称为控制存储器(Control Storage)，简称控存CS</strong></li><li>优点: 具有规整性、可维护性和灵活性</li><li>缺点: 速度慢</li></ul></li></ul><b>微程序: 一条指令的执行转为其对应的微程序的执行微指令: 一个微程序由多个微指令组成，通过一条条微指令的执行来实现微程序的执行微命令: 每条微指令包含若干微命令，微命令即为控制信号</b>![微程序控制器](micro_controller.png)<p>微指令设计可以分为两类设计模式:</p><ul><li>水平型微指令:<ul><li>基本思想: 相容微命令尽量多地安排在一条微指令中(尽量将相似的控制信号放在一起)</li><li>优点: 微程序短，并行性高，适合于较高速度的场合</li><li>缺点: 微指令长，编码空间利用率较低，并且编制困难</li></ul></li><li>垂直型微指令:<ul><li>基本思想: 一条微指令只控制一、二个微命令</li><li>优点: 微指令短，编码效率高，格式与机器指令类似，故编制容易</li><li>缺点: 微程序长，一条微指令只能控制一、二个操作，无并行，速度慢</li></ul></li></ul><p><img src="micro_instruction.png" alt="微指令格式" /><br />可以看到微指令和指令的格式十分相似: 均有操作码、地址字段。<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>OP的编码方式有:</p><ul><li>不译法: 直接控制</li><li>字段直接编码法: 水平型微指令风格</li><li>字段间接编码法: 水平型微指令风格</li><li>最小编码法: 垂直型微指令风格</li></ul><p>微指令下址产生:</p><ul><li>增量计数器法: 下条微指令地址隐含在微程序计数器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>PC中</li><li>断定法: 在本条微指令中明显指定下条微指令地址，通过断定法可以实现顺序执行和分支执行</li></ul><h3 id="cpu对异常的处理"><a class="markdownIt-Anchor" href="#cpu对异常的处理"></a> CPU对异常的处理</h3><p>程序执行过程中CPU会遇到一些特殊情况，使正在执行的程序被&quot;<strong>中断</strong>&quot;，然后CPU中止原来正在执行的程序，<strong>转到处理异常情况或特殊事件的程序去执行</strong>，执行后再<strong>返回到原被中止的程序处</strong>(断点)继续执行。</p><p>异常和中断的区别:</p><ul><li>异常: <strong>在CPU内部发生的意外事件或特殊事件</strong>，按发生原因分为<strong>硬故障异常</strong>和<strong>程序性异常</strong>两类<ul><li>硬故障异常: 如电源掉电、硬件线路故障等</li><li>程序性异常: 执行某条指令时发生的&quot;例外(Exception)&quot;，如溢出、缺页、非法指令、除数为0、堆栈溢出等等</li></ul></li><li>中断: <strong>外部请求中断</strong>，在CPU外部发生的特殊事件，发送请求和CPU需要处理中断，如打印机缺纸、外设准备好、采样计时到、DMA传输结束等。外部中断是一种I/O方式</li></ul><h4 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h4><p>异常按处理方式又分为故障、自陷和终止三类</p><ul><li><strong>故障(fault)</strong>: 执行指令引起的异常事件，如溢出、缺页、堆栈溢出、访问超时等</li><li><strong>自陷(trap)</strong>: 预先安排的事件，如单步跟踪、系统调用(执行访管指令)等，自陷处理完成后 回到下条指令</li><li><strong>终止(abort)</strong>: 硬故障事件，此时机器将&quot;终止&quot;，调出中断服务程序来重启操作系统</li></ul><p>缺页、TLB缺失等: 补救后可继续，<strong>回到发生故障的指令重新执行</strong><br />溢出、除数为0、非法操作、内存保护错等: <strong>终止当前进程</strong></p><p>异常处理机制:</p><ol><li><strong>关中断</strong>: 关闭中断/异常请求允许，使处理器处于&quot;禁止中断&quot;状态，以防止新异常(或中断)破坏断点、程序状态和现场</li><li><strong>保护断点和程序状态</strong>: 将断点和程序状态保存到堆栈或特殊寄存器中<ul><li>PC -&gt; 堆栈或EPC(专门存放断点的寄存器)</li><li>PSWR -&gt; 堆栈或EPSWR(专门保存程序状态的寄存器)</li></ul></li><li><strong>识别异常事件</strong>: 有软件识别和硬件识别(向量中断方式)两种不同的方式<ul><li>软件识别: MIPS采用，设置一个异常状态寄存器(MIPS中为Cause寄存器)，用于记录异常原因。操作系统使用一个<strong>统一的异常处理程序</strong>，该程序<strong>按优先级顺序查询异常状态寄存器</strong>的各位，识别出异常事件</li><li>硬件识别(向量中断方式): 用<strong>专门的硬件查询电路按优先级顺序识别异常</strong>，得到&quot;中断类型号&quot;，根据此号，到<strong>中断向量表中读取对应的中断服务程序的入口地址</strong></li></ul></li></ol><h4 id="中断的处理"><a class="markdownIt-Anchor" href="#中断的处理"></a> 中断的处理</h4><p>中断的处理在<a href="https://thm-lab.github.io//2022/06/13/%E4%BA%92%E8%BF%9E%E5%8F%8A%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%84%E7%BB%87/">互连及输入输出组织</a>中详细介绍。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指令系统</title>
    <link href="/2022/06/05/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/06/05/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-4-instruction-set"><a class="markdownIt-Anchor" href="#chapter-4-instruction-set"></a> Chapter 4: Instruction Set</h1><h2 id="指令系统的设计"><a class="markdownIt-Anchor" href="#指令系统的设计"></a> 指令系统的设计</h2><p>一条指令必须明显或隐含包含以下信息:</p><ul><li>操作码: 指明操作类型，长度可为<strong>固定</strong>也可为<strong>可变长</strong>，在MIPS中为固定长度</li><li>源操作数或其地址: 一个或多个源操作数所在的地址，可以是<strong>寄存器编址</strong>也可以是<strong>内存地址</strong></li><li>结果的地址: 产生的结果存放何处(目的操作数)</li><li>下一条指令地址: 下条指令存放于何处</li></ul><p>在不同机器系统中指令系统的<strong>指令内地址数量</strong>也可能不同。</p><ul><li>零地址指令:<ol><li>无需操作数　如: 空操作／停机等</li><li>所需操作数为默认位置　如: 堆栈／累加器等<br /><strong>形式: op</strong></li></ol></li><li>一地址指令:<br />其地址既是操作数的地址，也是结果的地址<ol><li>单目运算: 如: 取反／取负等</li><li>双目运算: 另一操作数为默认的　如: 累加器等<br /><strong>形式: op + A</strong></li></ol></li><li>两地址指令(CISC常见):<br />分别存放双目运算中两个操作数，并将其中一个地址作为结果的地址。<br /><strong>形式: op + A + B</strong></li><li>三地址指令(RISC常见):<br />分别作为双目运算中两个源操作数的地址和一个结果的地址<br /><strong>形式: op + A + B + C</strong></li><li>多地址指令:<br />用于成批数据处理的指令，如:向量 / 矩阵等运算的SIMD指令</li></ul><p><strong>指令执行的全过程如下:</strong></p><pre><code class="mermaid" >graph TD    IF("Instruction Fetch(取指)")-->ID("Instruction Decode(解码)");    ID-->OF("Operand Fetch(取操作数)");    OF-->EX("Execute(执行)");    EX-->RS("Result Store(写入)");    RS-->IF;</code></pre><h3 id="指令系统设计的基本原则"><a class="markdownIt-Anchor" href="#指令系统设计的基本原则"></a> 指令系统设计的基本原则</h3><ul><li>尽量短</li><li>有足够的操作码位数</li><li>指令编码必须有唯一的解释，否则是不合法的指令</li><li>指令字长应是字节的整数倍</li><li>合理地选择地址字段的个数</li><li>指令尽量规整</li></ul><h3 id="数据的类型"><a class="markdownIt-Anchor" href="#数据的类型"></a> 数据的类型</h3><p>操作数是指令处理的对象，与高级语言数据类型对应，基本类型有:</p><ul><li>地址(指针): 被看成无符号整数，用来参加运算以确定主(虚)存地址。</li><li>数值数据:<ul><li>定点数: 用二进制补码表示</li><li>浮点数: 用IEEE754标准规定表示</li></ul></li><li>位、位串、字符和字符串: 用来表示文本、音频和视频等.</li><li>逻辑数据: 布尔变量，用单位0/1表示。</li></ul><h3 id="操作数的寻址方式"><a class="markdownIt-Anchor" href="#操作数的寻址方式"></a> 操作数的寻址方式</h3><p><strong>寻址方式: 指令或操作数地址的指定方式。即：根据地址找到指令或操作数的方法。在一边情况下我们所讲的寻址方法大多指操作数寻址。</strong><br />由于操作数有不同的寻址方式，而指令中操作数地址是指令的一部分，因此<strong>指令中的地址码编码由操作数的寻址方式决定。</strong><br />在指令中表示寻址方式主要有两种方法:</p><ul><li>不设专门的寻址方式位: 例如在MIPS中，一条指令最多含有一个主存地址因此仅有一到两种寻址方式，通过确定指令操作码即可得知指令内操作数的寻址方式。</li><li>在指令中设置专门的寻址方式位: 如X86指令，一条指令中有多个操作数，且寻址方式各不相同，需要各自说明寻址方式，因此每个操作数有专门的寻址方式位，需要在指令中额外说明。</li></ul><p>以下七种寻址方式<b>需要全面了解和掌握！</b>:<br />设定指令格式为: | op | R | A | ··· |<br /><strong>R为寄存器编号，A为地址字段值，(X)表示A中的内容。</strong></p><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">算法</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">立即数寻址</td><td style="text-align:center">操作数=A</td><td style="text-align:center">指令执行速度快，因为数据直接存储在指令内</td><td style="text-align:center">操作数的范围小(指令长度有限)</td></tr><tr><td style="text-align:center">直接寻址</td><td style="text-align:center">操作数地址=A</td><td style="text-align:center">有效地址计算简单</td><td style="text-align:center">地址范围小</td></tr><tr><td style="text-align:center">间接寻址</td><td style="text-align:center">操作数地址=(A)</td><td style="text-align:center">有效地址范围大</td><td style="text-align:center">需要进行多次存储器访问</td></tr><tr><td style="text-align:center">寄存器寻址</td><td style="text-align:center">操作数=(R)</td><td style="text-align:center">指令执行快，指令短(因为寄存器数量少，需要表达位数少且访问寄存器比访问主存快)</td><td style="text-align:center">寄存器数量少</td></tr><tr><td style="text-align:center">寄存器间接寻址</td><td style="text-align:center">操作数地址=(R)</td><td style="text-align:center">地址范围大</td><td style="text-align:center">需要访问一次寄存器和存储器</td></tr><tr><td style="text-align:center">偏移寻址</td><td style="text-align:center">操作数地址=A+(R)</td><td style="text-align:center">灵活</td><td style="text-align:center">复杂</td></tr><tr><td style="text-align:center">堆栈寻址</td><td style="text-align:center">操作数地址=栈顶内容</td><td style="text-align:center">指令短</td><td style="text-align:center">应用有限</td></tr></tbody></table><p>偏移寻址又可以因为<strong>R可以明显或者不明显</strong>给出而分为三种不同的寻址方法:</p><ul><li>相对寻址: 操作数地址=A+(PC)，此时R为PC(不明显给出)即操作数地址为相对当前指令偏移A的地址。</li><li>基址寻址: 操作数地址=A+(B)，此时R为B(B为基址寄存器，专门用于存放基址地址的寄存器，也可不明显给出也可明显给出)即操作数地址为相对基地址的地址。</li><li>变址寻址: 操作数地址=A+(I)，相对于首址A处位移量为(I)的单元，I为变址寄存器即专门存放偏移量的寄存器，可明显给出也可隐含给出。</li></ul><h3 id="操作码的编码方法"><a class="markdownIt-Anchor" href="#操作码的编码方法"></a> 操作码的编码方法</h3><p>根据指令系统设计要求，指令的操作码可以是定长的也可以是变长的，本节会介绍这两种操作码的编码方法。</p><h3 id="定长操作码"><a class="markdownIt-Anchor" href="#定长操作码"></a> 定长操作码</h3><p><b>定长操作码: 指令的操作码部分采用固定长度的编码。</b>如设操作码固定为6位，则系统最多可表示64种指令。特点是译码方便，但可能会有信息冗余(操作码未全部使用)。<br />这里以IBM360/370为例:<br />提供了8位操作码，能够表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8=256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span>条指令，但指令系统只提供了183条指令，有73种编码为冗余信息。<br /><img src="ibm370.svg" alt="IBM370指令格式" /></p><h3 id="变长操作码"><a class="markdownIt-Anchor" href="#变长操作码"></a> 变长操作码</h3><p><b>将操作码的编码长度分成几种固定长的格式。</b>这种方式被大多数指令集采用。由于指令长度为固定值，而不同指令内的操作数数量却不尽相同，因此根据操作数的数量可以将操作码长度分为几种定长的格式，其中又可以分为等长扩展法和不等长扩展法:</p><ul><li>等长扩展法: 4-&gt;8-&gt;12···</li><li>不等长扩展法: 4-&gt;5-&gt;9-&gt;11···</li></ul><p>设某指令系统指令字长16位，每个地址码为6位。若二地址指令15条，一地址指令34条，则剩下零地址指令最多有多少条？<br /><img src="extend_operate_code_example.svg" alt="变长操作码example" /></p><h3 id="条件码和标志寄存器"><a class="markdownIt-Anchor" href="#条件码和标志寄存器"></a> 条件码和标志寄存器</h3><p>条件转移指令通常根据Condition Codes (条件码CC/状态位/标志位)转移。一般通过执行算术指令或比较指令，然后用测试指令来检测CC。如判断两个数是否相等通过将两数相减得到ZF标志位，如ZF为1则两数相等。<br />在ALU运算时会产生常用的四种标志位(条件码): OF、SF、ZF、CF具体含义和产生方法见<a href="https://thm-lab.github.io/2022/06/04/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/">运算方法和运算部件</a>。标志可存于标志寄存器(也叫条件码寄存器、状态寄存器、程序状态字寄存器)，也可由指定的通用寄存器来存放标志位。<br />例:bgt r1, r2, label;如果r1&gt;r2，则转移到label处执行；否则顺序执行。</p><p><b>例: 判断A与B的大小</p><ul><li>无符号数: ZF=0 &amp; CF=0则A&gt;B</li><li>带符号数: ZF=0 &amp; SF=OF则A&gt;B</b></li></ul><h3 id="指令设计风格"><a class="markdownIt-Anchor" href="#指令设计风格"></a> 指令设计风格</h3><p><strong>指令系统设计风格即指对于不同操作数地址的指定方式。</strong></p><ul><li>累加器型: 其中一个操作数(源操作数1)和目的操作数总在累加器中即只给出操作数的存储地址在操作数之一的地址</li><li>堆栈型: 总是将栈顶两个操作数进行运算，指令无需指定操作数地址</li><li>通用寄存器型: 操作数可以是寄存器或存储器数据(即A、B和C可以是寄存器或存储单元)</li><li>装入/存储型: 运算指令的操作数只能是寄存器数据，只有load/store能访问存储器</li></ul><h4 id="各种指令系统风格的比较"><a class="markdownIt-Anchor" href="#各种指令系统风格的比较"></a> 各种指令系统风格的比较</h4><p><img src="instruction_system_style_comparation.svg" alt="指令系统风格比较" /></p><h3 id="指令系统举例"><a class="markdownIt-Anchor" href="#指令系统举例"></a> 指令系统举例</h3><p>这里主要介绍两种指令集:</p><ul><li>复杂指令集计算机CISC (Complex Instruction Set Computer)</li><li>精简指令集计算机RISC (Reduce Instruction Set Computer)</li></ul><h4 id="cisc"><a class="markdownIt-Anchor" href="#cisc"></a> CISC</h4><p>早期CISC设计风格的主要特点:</p><ul><li>指令系统复杂: 变长操作码 / 变长指令字 / 指令多 / 寻址方式多 / 指令格式多</li><li>指令周期长: 绝大多数指令需要多个时钟周期才能完成</li><li>各种指令都能访问存储器: 除了专门的存储器读写指令外，运算指令也能访问存储器</li><li>采用微程序控制</li><li>难以进行编译优化来生成高效目标代码</li></ul><p>CISC的二八定律: 在程序中各种指令出现的频率悬殊很大，常用的简单指令占程序的80%，但只占指令系统的20%。在微程序控制的计算机中，程序中只占指令总数20%的复杂指令占用了控制存储器容量的80%。</p><h4 id="risc"><a class="markdownIt-Anchor" href="#risc"></a> RISC</h4><ul><li>简化的指令系统: 指令少 / 寻址方式少 / 指令格式少 / 指令长度一致</li><li>以RR方式工作: 除Load/Store指令可访问存储器外，其余指令都只访问寄存器</li><li>指令周期短: 以流水线方式工作， 因而除Load/Store指令外，其他简单指令都只需一个或一个不到的时钟周期就可完成</li><li>采用大量通用寄存器，以减少访存次数</li><li>采用硬连线控制器控制，不用或少用微程序控制</li><li>采用优化的编译系统，力求有效地支持高级语言程序</li></ul><h2 id="程序的机器级表示"><a class="markdownIt-Anchor" href="#程序的机器级表示"></a> 程序的机器级表示</h2><h3 id="mips的指令格式"><a class="markdownIt-Anchor" href="#mips的指令格式"></a> MIPS的指令格式</h3><p><strong>所有指令都是32位宽(字长)，按字地址对齐存储，字地址为4的倍数！</strong><br />在MIPS中指令共有三种格式:</p><ul><li>R型指令</li><li>I型指令</li><li>J型指令</li></ul><h4 id="r型指令"><a class="markdownIt-Anchor" href="#r型指令"></a> R型指令</h4><table><thead><tr><th style="text-align:center">op</th><th style="text-align:center">rs</th><th style="text-align:center">rt</th><th style="text-align:center">rd</th><th style="text-align:center">shamt</th><th style="text-align:center">func</th></tr></thead><tbody><tr><td style="text-align:center">6bits</td><td style="text-align:center">5bits</td><td style="text-align:center">5bits</td><td style="text-align:center">5bits</td><td style="text-align:center">5bits</td><td style="text-align:center">6bits</td></tr></tbody></table><p><strong>因为操作数全部来源于寄存器(register)因此称为R型指令。</strong></p><ul><li>op: 操作码，在R型指令中为固定值<code>000000</code>，操作类型通过func来指定</li><li>rs: 第一个源操作数</li><li>rt: 第二个源操作数</li><li>rd: 目的操作数</li><li>shamt: 对非移位指令为<code>00000</code>。移位指令为移位次数<br /><img src="R_type_instruction.png" alt="R型指令" /></li></ul><h4 id="i型指令"><a class="markdownIt-Anchor" href="#i型指令"></a> I型指令</h4><table><thead><tr><th style="text-align:center">op</th><th style="text-align:center">rs</th><th style="text-align:center">rt</th><th style="text-align:center">imm</th></tr></thead><tbody><tr><td style="text-align:center">6bits</td><td style="text-align:center">5bits</td><td style="text-align:center">5bits</td><td style="text-align:center">16bits</td></tr></tbody></table><p><strong>指令中包含了一个立即数，所以称为I型指令。</strong></p><ul><li>op: 操作码，指明指令功能</li><li>rs: 第一个源操作数</li><li>rt: 目的操作数</li><li><strong>imm: 16位的立即数，在执行时需要按需扩展为32位的立即数</strong>，根据指令不同有以下三种用法:<ol><li>以立即数寻址方式提供的一个源操作数(自己本身就是参加运算的数)</li><li>作为偏移量，与寄存器rs组成偏移寻址方式，提供一个存储器操作数</li><li>作为偏移量，与PC寄存器组成相对寻址方式，提供一个转移目的地址</li></ol></li></ul><p><img src="I_type_instruction.png" alt="I型指令" /></p><p>addi rt, rs, imm : rt = (rs) + imm(rs内的数据与立即数imm相加将结果存入rt，在相加之前需要对16位imm进行<strong>符号扩展</strong>)<br />andi/ori/xori rt, rs, imm : rt = (rs) &amp;/|/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊕</span></span></span></span> imm(rs内的数据与立即数imm做与/或/异或操作并将结果存入rt，在相与之前需要对16位imm进行<strong>0扩展</strong>)<br />lw rt, offset(rs) : rt = mem[(rs)+offset](从rs内容的offset偏移量地址取出数放入rt寄存器，offset同样取<strong>符号扩展</strong>)<br />sw rt, offset(rs) : mem[(rs)+offset] = rt(将rt内容存入mem[(rs)+offset]中，offset同样取<strong>符号扩展</strong>)<br />bne rs, rt, imm : if rs != rt then PC = PC + 4 + (imm&lt;&lt;2)(如果rs不等于rt，则PC跳转到PC+4+imm，相加前进行符号扩展，左移2位是为了保证字地址对齐，因为一条指令为4个字节长左移2位刚好放大4倍，因此imm表示转移指令条数而不是地址偏移量)<br /><strong>beq与bne相同，但bne为不等转移，beq为相等转移。</strong><br />lui rt, imm : rt = imm&lt;&lt;16(将立即数imm扩展左移16位即高位为立即数低位为0存入rt寄存器)</p><h4 id="j型指令"><a class="markdownIt-Anchor" href="#j型指令"></a> J型指令</h4><table><thead><tr><th style="text-align:center">op</th><th style="text-align:center">target</th></tr></thead><tbody><tr><td style="text-align:center">6bits</td><td style="text-align:center">26bits</td></tr></tbody></table><p><strong>指令作用主要为跳转(jump)，因此称为J型指令。</strong></p><ul><li>op: 操作码，指明指令功能</li><li><strong>target: 跳转目的地址，需要根据指令进行按需扩展操作</strong></li></ul><p><img src="J_type_instruction.png" alt="J型指令" /><br />J型指令数量比较少。</p><p>j target : <strong>PC = target(PC高4位不变，将target左移2位送入PC的低28位，|op高4位|target|00|)</strong><br />jal target : <strong>ra = PC + 4, PC = target(将下一条指令地址放入ra寄存器，将转移地址按j指令方式放入PC)</strong></p><h3 id="mips的寄存器"><a class="markdownIt-Anchor" href="#mips的寄存器"></a> MIPS的寄存器</h3><p><strong>MIPS有32个32位的通用寄存器！</strong><br /><img src="MIPS_register.png" alt="通用寄存器" /></p><ul><li>0号寄存器$zero为固定值零，不能改变</li><li>1号寄存器$at被汇编器保留为专用</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mn>0</mn><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">k0和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">0</span><span class="mord cjk_fallback">和</span></span></span></span>k1是留给操作系统专用</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>p</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">栈</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">指</mi><mi mathvariant="normal">针</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">但</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">编</mi><mi mathvariant="normal">译</mi><mi mathvariant="normal">器</mi><mo stretchy="false">(</mo><mi mathvariant="normal">如</mi><mi>M</mi><mi>I</mi><mi>P</mi><mi>S</mi><mi mathvariant="normal">的</mi><mi>C</mi><mi mathvariant="normal">编</mi><mi mathvariant="normal">译</mi><mi mathvariant="normal">器</mi><mo stretchy="false">)</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">为</mi></mrow><annotation encoding="application/x-tex">fp是用于过程调用时，访问保存在栈中的数据的指针。但有的编译器(如MIPS的C编译器)不使用，将它作为</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">指</span><span class="mord cjk_fallback">针</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">编</span><span class="mord cjk_fallback">译</span><span class="mord cjk_fallback">器</span><span class="mopen">(</span><span class="mord cjk_fallback">如</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">编</span><span class="mord cjk_fallback">译</span><span class="mord cjk_fallback">器</span><span class="mclose">)</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">为</span></span></span></span>s8寄存器使用</li><li>在汇编语言中使用寄存器时可以用寄存器名，也可以用寄存器号，前面加上&quot;$&quot;,例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mi mathvariant="normal">或</mi></mrow><annotation encoding="application/x-tex">8或</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord cjk_fallback">或</span></span></span></span>t0</li><li>MIPS还提供了32个32位的单精度浮点寄存器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mn>0</mn><mtext> </mtext></mrow><annotation encoding="application/x-tex">f0~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace nobreak"> </span></span></span></span>f31。它们可配对成16个64位的双精度浮点寄存器</li></ul><h3 id="mips的指令寻址方式"><a class="markdownIt-Anchor" href="#mips的指令寻址方式"></a> MIPS的指令寻址方式</h3><p>**MIPS没有专门的寻址方法字段！**因此只能根据指令类型来判断操作数的寻址方式。</p><ul><li>寄存器寻址: 广泛出现在R型指令和I型指令中，因为这两种指令均至少有一个操作数是寄存器，因此寄存器寻址必然存在</li><li>立即数寻址: 在I型指令中有专门的16位imm作为立即数，因此一定存在立即数寻址，比如addi、ori、xori等均为立即数寻址方式</li><li>偏移寻址: 在I型指令中某些涉及读写内存的指令可能为偏移寻址，比如lw、sw等均为偏移寻址方式</li><li>PC相对寻址: 在I型指令中存在地址跳转指令如bne、beq，在跳转的过程中即可能用到PC相对寻址</li><li>伪直接寻址: 在J型指令中target字段就是一段目标跳转地址，但是该立即数不是直接使用，与立即数寻址有所差异，而是通过一定的运算(取PC前4位和加上target后左移2位)得到的，因此属于伪直接寻址方式</li></ul><h3 id="mips的汇编形式与指令的对应"><a class="markdownIt-Anchor" href="#mips的汇编形式与指令的对应"></a> MIPS的汇编形式与指令的对应</h3><h4 id="反汇编"><a class="markdownIt-Anchor" href="#反汇编"></a> 反汇编</h4><p>例: 32位指令为<code>0000 0000 1010 1111 1000 0000 0010 0000</code>求汇编形式:<br />指令的前6位为000000(操作码)，根据指令编码表知，是一条R型指令，按照R型指令的格式得到: rs=00101, rt=01111, rd=10000, shamt=00000, funct=100000<br /><img src="reverse_example.png" alt="example" /><br />根据R型指令表，它是&quot;add&quot;操作(非移位操作)，rs、rt、rd的十进制值分别为5、15、16，从MIPS寄存器功能表知: rs、rt、rd分别为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mn>1</mn><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">a1、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">1</span><span class="mord cjk_fallback">、</span></span></span></span>t7、$s0，故对应的汇编形式为: <code>add $s0, $a1, $t7</code>，功能为将a1寄存器和t7寄存器相加，结果存入s0寄存器。<br /><strong>注意: 汇编的寄存器摆放顺序与指令的操作数顺序不尽相同，如结果寄存器在汇编中为第一个寄存器而在指令中在操作数寄存器后。</strong><br /><img src="assembly_order.png" alt="汇编与指令顺序关系" /></p><h4 id="高级语言语句的汇编指令表示"><a class="markdownIt-Anchor" href="#高级语言语句的汇编指令表示"></a> 高级语言语句的汇编指令表示</h4><p>高级语言一般提供顺序、选择和循环结构语句，通过编译器将它们翻译成响应的机器级指令。<br />例: 将C语言赋值语句<code>f = (g + h) - (i + j)</code>翻译为汇编指令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add </span>$<span class="hljs-built_in">s5</span>, $<span class="hljs-built_in">s1</span>, $<span class="hljs-built_in">s2</span> <span class="hljs-comment"># 计算g+h  </span><br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">s6</span>, $<span class="hljs-built_in">s3</span>, $<span class="hljs-built_in">s4</span> <span class="hljs-comment"># 计算i+j  </span><br><span class="hljs-keyword">sub </span>$<span class="hljs-built_in">s0</span>, $<span class="hljs-built_in">s5</span>, $<span class="hljs-built_in">s6</span> <span class="hljs-comment"># 计数(g + h) - (i + j) </span><br></code></pre></td></tr></table></figure><p>例: 设A为100个<strong>字</strong>的数组，变量g和h分配寄存器s1和s2，用基址寻址从存储器取元素A[8]送s4，分配s3作基址寄存器。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lw</span> $s4, <span class="hljs-number">32</span>($s3) # 将A[<span class="hljs-number">8</span>]的值送s4但注意偏移量为<span class="hljs-number">8</span>*<span class="hljs-number">4</span>(一个字为<span class="hljs-number">4</span>个字节)=<span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p><strong>在使用I型指令时，如果立即数超过16位补码表示范围，就不能直接给出操作数或偏移量，但可以用lui指令来设置32位寄存器的高16位，可得到一个较大的值。</strong></p><p>例: if-then-else语句和&quot;==&quot;判断</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">if</span> (i == j)&#123;<br>    f = g + <span class="hljs-built_in">h</span>;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    f = g - <span class="hljs-built_in">h</span>;<br>&#125;<br>// Assuming variables i, j, f, g, <span class="hljs-built_in">h</span>, ~ <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s2</span>, <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">bne <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s2</span>, <span class="hljs-keyword">else</span> <span class="hljs-comment"># 如果i!=j，跳转到else</span><br>add <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span> <span class="hljs-comment"># 计算i+j</span><br>j <span class="hljs-keyword">exit</span> <span class="hljs-comment"># 跳转到exit</span><br><span class="hljs-keyword">else</span>: sub <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span> <span class="hljs-comment"># 计算i-j</span><br></code></pre></td></tr></table></figure><p>编译器和汇编语言程序员不必计算分支指令的地址，而只要用标号即可！汇编器完成地址计算。</p><p>例: &quot;&lt;&quot;判断</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">if</span> (a &lt; b)&#123;<br>    f = g + <span class="hljs-built_in">h</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    f = g - <span class="hljs-built_in">h</span>;<br>&#125;<br>// Assuming variables a, b, f, g, <span class="hljs-built_in">h</span>, ~ <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s2</span>, <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">slt <span class="hljs-variable">$s6</span>, <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s2</span> <span class="hljs-comment"># 如果a&lt;b，$s6=1，否则$s6=0(slt: set on less than在小于的时候置1)</span><br>beq <span class="hljs-variable">$s6</span>, <span class="hljs-variable">$0</span>, <span class="hljs-keyword">else</span> <span class="hljs-comment"># 如果$s6=0，跳转到else</span><br>add <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span> <span class="hljs-comment"># 未转移则计算i + j</span><br>j <span class="hljs-keyword">exit</span> <span class="hljs-comment"># 跳转到exit</span><br><span class="hljs-keyword">else</span>: sub <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span>, <span class="hljs-variable">$s5</span> <span class="hljs-comment"># 如果$s6=1，则转移到else计算i - j</span><br></code></pre></td></tr></table></figure><p>例: loop循环</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">Loop: g = g + A[i];<br>    i = i + j;<br>   <span class="hljs-built_in"> if </span>(i != h) &#123;<br>       <span class="hljs-built_in"> goto </span><span class="hljs-class">Loop;</span><br>    &#125;<br>// Assuming variables g, h, i, j  ~ $s1, $s2, $s3, $s4<span class="hljs-built_in"> and </span>base address<br>of<span class="hljs-built_in"> array </span>is in $s5<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Loop: <span class="hljs-built_in">add</span> <span class="hljs-variable">$s7</span>, <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s3</span> # 计算i<span class="hljs-number">*2</span><br>      <span class="hljs-built_in">add</span> <span class="hljs-variable">$s7</span>, <span class="hljs-variable">$s7</span>, <span class="hljs-variable">$s7</span> # 计算i<span class="hljs-number">*4</span><br>      <span class="hljs-built_in">add</span> <span class="hljs-variable">$s7</span>, <span class="hljs-variable">$s7</span>, <span class="hljs-variable">$s5</span><br>      lw <span class="hljs-variable">$s6</span>, 0(<span class="hljs-variable">$s7</span>) #<span class="hljs-variable">$s6</span>=A[i]<br>      <span class="hljs-built_in">add</span> <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s1</span>, <span class="hljs-variable">$s6</span># g = g + A[i]<br>      <span class="hljs-built_in">add</span> <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s4</span># i = i + j<br>      bne <span class="hljs-variable">$s3</span>, <span class="hljs-variable">$s2</span>, Loop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算方法和运算部件</title>
    <link href="/2022/06/04/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/"/>
    <url>/2022/06/04/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-3-arithmetic-methods-and-components"><a class="markdownIt-Anchor" href="#chapter-3-arithmetic-methods-and-components"></a> Chapter 3: Arithmetic Methods and Components</h1><h2 id="高级语言与机器语言涉及的运算及alu"><a class="markdownIt-Anchor" href="#高级语言与机器语言涉及的运算及alu"></a> 高级语言与机器语言涉及的运算及ALU</h2><h3 id="高级语言程序中涉及的运算以c语言为例"><a class="markdownIt-Anchor" href="#高级语言程序中涉及的运算以c语言为例"></a> 高级语言程序中涉及的运算(以C语言为例)</h3><p>在C语言中除了基本的加、减、乘、除运算之外，还有以下几类运算:</p><ul><li><p>按位运算:</p><ul><li>用途: 对位串实现&quot;掩码&quot;(mask)操作或相应的其他处理</li><li>操作: 按位与: &amp;<br />         按位或: |<br />         按位取反: ~<br />         按位异或: ^</li></ul></li><li><p>逻辑运算:</p><ul><li>用途: 用于关系表达式的运算</li><li>操作: 逻辑与: &amp;&amp;<br />         逻辑或: ||<br />         逻辑非: !</li></ul></li><li><p>移位运算:</p><ul><li>用途: 提取部分信息<br />         扩大或缩小数值的2、4、8<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋯</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\cdots 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>倍</li><li>操作: 左移: x&lt;&lt;k; 右移: x&gt;&gt;k;<br />         不区分是逻辑移位还是算术移位，由x的类型确定。<ol><li>x为无符号数: 逻辑左移时，高位移出，低位补0，当移出位为1时发生了溢出。算术左移时，低位移出，<strong>高位补0</strong>，当移出位为1时发生了有效数据丢失。</li><li>x为带符号数: 逻辑左移时，高位移出，低位补0，当移出位为1时发生了溢出。算术左移时，低位移出，<strong>高位补符号位</strong>，当移出位为1时发生了有效数据丢失。</li></ol></li></ul></li><li><p>位扩展和位截断运算:</p><ul><li>用途: 完成不同类型数据间转换时可能会出现的数据扩展或截断操作</li><li>操作: 高级语言没有提供运算符，而是在编译器层面解决</li><li>扩展:<ol><li>无符号数: 无符号数采用0扩展的方式进行扩展</li><li>带符号数: 带符号数采用符号位扩展的方式进行扩展</li></ol></li><li>截断: 强行将<strong>高位丢弃</strong>，故可能发生&quot;溢出&quot;<br /><strong>说明: 截断后再扩展可能造成数据的错误。</strong></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i = <span class="hljs-number">32768</span>; <span class="hljs-comment">// i = 00 00 80 00</span><br><span class="hljs-type">short</span> si = (<span class="hljs-type">short</span>)i; <span class="hljs-comment">// si = 80 00</span><br><span class="hljs-type">int</span> ii = (<span class="hljs-type">int</span>)si; <span class="hljs-comment">// ii = FF FF 80 00 = -32768</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="指令集中涉及到的运算以mips为例"><a class="markdownIt-Anchor" href="#指令集中涉及到的运算以mips为例"></a> 指令集中涉及到的运算(以MIPS为例)</h3><p>本节会介绍需要掌握含义和用法的MIPS指令集，在后面指令系统中也会用到这里的指令，因此需要记忆大部分指令的含义。<br /><img src="mips1.svg" alt="MIPS指令集" /><br /><img src="mips2.svg" alt="MIPS指令集" /><br /><img src="mips3.svg" alt="MIPS指令集" /><br /><img src="mips4.svg" alt="MIPS指令集" /><br /><img src="mips5.svg" alt="MIPS指令集" /><br /><img src="mips6.svg" alt="MIPS指令集" /><br /><img src="mips7.svg" alt="MIPS指令集" /></p><h3 id="基本运算部件alu的设计"><a class="markdownIt-Anchor" href="#基本运算部件alu的设计"></a> 基本运算部件ALU的设计</h3><h4 id="加法器串行-并行"><a class="markdownIt-Anchor" href="#加法器串行-并行"></a> 加法器(串行、并行)</h4><ul><li><p>串行加法器: 由多个全加器串行连接而成。<br /><img src="fulladder.png" alt="全加器" /><br />全加器的A和B均为1位bit的输入，sum为1位bit的输出，CarryIn为上一个全加器的进位，而CarryOut为本位的进位。<br /><img src="serial_adder.png" alt="串行加法器" /><br />C0为0，Cn为溢出被截断了。<br /><strong>串行加法器的缺点: 进位按串行方式传递，速度慢！<strong>例如: n位串行加法器从C0到Cn的延迟时间为</strong>2n级门延迟</strong>！最后一位和数的延迟时间为<strong>2n+1级门延迟</strong>！<br />(假设与/或门的延迟时间为1级门延迟，异或门的延迟时间为3级门延迟)</p></li><li><p>并行加法器: 串行进位加法器采用串行逐级传递进位，电路延迟与位数成正比关系。因此，现代计算机采用一种先行进位(Carry look ahead)方式。因此<strong>并行加法器比串行加法器快的原因即是串行加法器的进位需要逐级传达而并行加法器的进位之间不等待，相互独立并同时产生。</strong></p><ol><li>全先行进位加法器:<br /><img src="full_ahead_adder.svg" alt="全先行进位加法器" /><br />全先行进位加法器是将<strong>所有输入同时传输到进位生成部件中</strong>，再通过进位生成结果与输入数据在求和部件中计算得到结果。</li><li>局部先行进位加法器<br /><img src="local_ahead_adder.svg" alt="局部先行进位加法器" /><br />局部先行进位加法器则是采用了串行和并行两种方式的结合，将输入分为多个不同的部分，同时将这些部分分别传输到进位生成部件，然后将这些<strong>全先行进位加法器进行串联行成一个大的局部先行进位加法器</strong>。</li><li>多级先行进位加法器<br /><img src="multi_ahead_adder.svg" alt="多级先行进位加法器" /><br />多级先行进位加法器是局部先行加法器的更高级形式，多级先行进位加法器采用的是组内并行但组间是串行的形式，而多级先行进位加法器是实现了<strong>不同组之间的并行进位</strong>(实现方法是BCLA部件即多引入一组新的传递函数可以直接进行不同组的并行进位)。</li></ol></li></ul><h4 id="alu的功能说明"><a class="markdownIt-Anchor" href="#alu的功能说明"></a> ALU的功能说明</h4><p><img src="alu.svg" alt="ALU" /></p><ul><li>A、B为n位的输入，C为n位的输出</li><li>ALUop为ALU的控制信号，用来说明本次计算的类型(&amp;,|,+,-等)</li><li>Zero为计算结果是否为0的标志，如果结果为0，则Zero为1，否则为0</li><li>CarryOut为进位或者借位信号，如果有进位或借位发生则为1</li><li>Overflow为溢出标志，如果溢出则为1</li></ul><p><strong>这里只是ALU功能的示意图，并非真实的ALU结构图。</strong><br />这是1位基本ALU的逻辑电路图:<br /><img src="1_bit_alu.png" alt="1位ALU" /><br />MUX为多路选择器。</p><h2 id="定点数运算及其运算部件"><a class="markdownIt-Anchor" href="#定点数运算及其运算部件"></a> 定点数运算及其运算部件</h2><h3 id="补码加减运算及其运算部件"><a class="markdownIt-Anchor" href="#补码加减运算及其运算部件"></a> 补码加/减运算及其运算部件</h3><p>首先由数据的机器级表示章我们可以知道，定点数在现代计算机中的表示方法均为<strong>补码</strong>。对于加减运算由于补码的特性我们可以知道:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>+</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[A+B]_{补}=[A]_{补}+[B]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>A</mi><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[A-B]_{补}=[A]_{补}+[-B]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>由上面等式可以知道，ALU只需要实现补码的<strong>加法</strong>功能和<strong>求补</strong>(求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[-B]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称为求补)功能即可完成定点数的加减运算。而求补功能其实是比较好实现的，其公式如下:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>B</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><msub><mover accent="true"><mrow><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">补</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">[-B]_{补}=\overline{[B]}_{补}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2497em;vertical-align:-0.29969999999999997em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9500000000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span><span style="top:-3.87em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.29969999999999997em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p><strong>在求补运算中的取反是对补码的所有位进行的(包括符号位)。</strong></p><p><img src="integer_adder.png" alt="整数加减运算部件" /></p><ul><li>Sub: 减法信号位，当为1时表示减法，当为0时表示加法，在MUX的作用下会影响B输入到加法器的值</li><li>Cin: 前一加法器的进位或借位信息</li><li>Cout: 为本位加法器的进位或借位信息</li><li><strong>溢出标志OF(Overflow Flag): <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>F</mi><mo>=</mo><msub><mi>C</mi><mi>n</mi></msub><mo>⊕</mo><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">OF=C_n\oplus C_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">C_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为符号位进位, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">C_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>为最高数值位进位)</strong></li><li><strong>符号位标志SF(Sign Flag): <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>F</mi><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">SF=F_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>(即最高位MSB)</strong></li><li><strong>零标志ZF(Zero Flag): ZF=1当且仅当Sum=0</strong></li><li><strong>进位/借位标志CF(Carry Flag): <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo>=</mo><mi>C</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo>⊕</mo><mi>S</mi><mi>u</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">CF=Cout\oplus Sub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo>=</mo><mi>C</mi><mi>o</mi><mi>u</mi><mi>t</mi><mo>⊕</mo><mi>C</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">CF=Cout\oplus Cin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></strong></li></ul><p><strong>条件标志位(OF、SF、ZF、CF)的产生公式需要掌握!并且条件标志会保存到寄存器中。</strong></p><p><img src="adder_example.svg" alt="example" /></p><h3 id="原码加减运算"><a class="markdownIt-Anchor" href="#原码加减运算"></a> 原码加/减运算</h3><p>原码加/减运算是浮点数运算的基础之一，因为浮点数的尾数由原码表示，在进行浮点数运算时一定会涉及到原码的加减运算。<br />原码加/减运算思路为<strong>将符号位和数值部分分开处理</strong>，对数值部分进行加减运算，符号位起判断和控制作用。</p><ol><li>比较两数符号，对加法执行&quot;同号求和，异号求差&quot;，对减法执行&quot;异号求和，同号求差&quot;。</li><li>求和：数值位相加，和的符号取被加数(或被减数)的符号。若最高位产生进位，则结果溢出。</li><li>求差：加数(或减数)求补后与被加数(被减数)相加。</li><li><ol><li>最高位产生进位(Cout=1)则无借位(CF=0)，表示够减结果为正，该结果即为“差”的数值位的原码。</li><li>最高位无进位(Cout=0)则CF=1，结果为负，它是“差”的数值位的补码形式，需对结果求补，还原为原码形式的数值位。</li><li>差的符号位：对于a)情况，符号位取被加数（被减数）的符号；       对于b)情况，符号位为被加数（被减数）的符号取反。</li></ol></li></ol><p><img src="true_form_example.svg" alt="example" /></p><h3 id="移码加减运算"><a class="markdownIt-Anchor" href="#移码加减运算"></a> 移码加/减运算</h3><p>移码同样是浮点数运算的基础之一，因为浮点数的阶码由移码表示，在进行浮点数运算时一定会涉及到移码的加减运算。<br />但是移码加/减运算<strong>符号位和数值部分可以一起处理</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>+</mo><mo stretchy="false">[</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><mo>+</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[E1]_{移}+[E2]_{移}=[E1+E2]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>−</mo><mo stretchy="false">[</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>=</mo><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><mo>−</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[E1]_{移}-[E2]_{移}=[E1-E2]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>**移码的和/差等于和/差的补码！**再根据标准移码和补码的关系可以得到结果的移码: 将符号位取反，其余位不变。<br />运算规则:</p><ol><li>加法：直接将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub></mrow><annotation encoding="application/x-tex">[E1]_移</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub></mrow><annotation encoding="application/x-tex">[E2]_移</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>进行模<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>加</strong>，然后<strong>对结果的符号取反</strong>。</li><li>减法: 先将减数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>2</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub></mrow><annotation encoding="application/x-tex">[E2]_移</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">2</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>求补(各位取反，末位加1)</strong>，然后再与被减数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>E</mi><mn>1</mn><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub></mrow><annotation encoding="application/x-tex">[E1]_移</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>进行模<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>相加</strong>，最后<strong>对结果的符号取反</strong>。</li><li><strong>溢出判断：进行模<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>相加时，如果两个加数的符号相同，并且与和数的符号也相同，则发生溢出。</strong>(因为和是补码，加数是移码)</li></ol><p><img src="shift_code_example.svg" alt="example" /></p><h3 id="乘法运算及其运算部件"><a class="markdownIt-Anchor" href="#乘法运算及其运算部件"></a> 乘法运算及其运算部件</h3><h4 id="无符号数乘法"><a class="markdownIt-Anchor" href="#无符号数乘法"></a> 无符号数乘法</h4><p>设: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>x</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>x</mi><mi>n</mi></msub><mo separator="true">,</mo><mtext> </mtext><mo stretchy="false">[</mo><mi>Y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><msub><mi>y</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">[X]_{原}=x_0.x_1\cdots x_n,\ [Y]_{原}=y_0.y_1\cdots y_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>X</mi><mo>×</mo><mi>Y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub></mrow><annotation encoding="application/x-tex">[X\times Y]_{原}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />观察人手算乘法过程:<br /><img src="human_calculate.png" alt="手算过程" /><br />发现在整个运算过程中一直重复加法运算和移位运算两种运算，因此在计算机中可以通过ALU和移位器来实现乘法运算。<br />无符号数乘法的机器实现基本步骤:</p><ol><li>每次得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X\times y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>后，与前面所得结果累加，得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称之为部分积。</li><li>每次得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X\times y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>后，不是左移与前次部分积Pi相加，而是将部分积<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>右移后与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>×</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X\times y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相加。</li><li>对乘数中为&quot;1&quot;的位执行加法和右移，对为&quot;0&quot;的位只执行右移，而不执行加法运算。</li></ol><p><img src="proof.svg" alt="推导过程" /></p><p><img src="multiply_example.svg" alt="example" /></p><h4 id="乘法运算硬件实现"><a class="markdownIt-Anchor" href="#乘法运算硬件实现"></a> 乘法运算硬件实现</h4><p><img src="multiplication_hardware.svg" alt="乘法硬件实现" /><br />32位$\times$32位=64位，因此结果需要64位寄存器来保存。而结果在乘法开始时乘数可以利用结果暂时未产生的空间来存储，因此结果的低32位作为乘数寄存器。当运算开始后，没计算出一位结果就需要右移一位，同时乘数寄存器也需要右移一位，但此时丢失的数据已经在本次运算中被保存了。</p><h4 id="原码乘法算法和mips中的乘除法运算处理"><a class="markdownIt-Anchor" href="#原码乘法算法和mips中的乘除法运算处理"></a> 原码乘法算法和MIPS中的乘除法运算处理</h4><h5 id="原码乘法算法"><a class="markdownIt-Anchor" href="#原码乘法算法"></a> 原码乘法算法</h5><p>用于浮点数尾数乘法运算，符号与数值分开处理: 积符由异或得到，数值用无符号乘法运算。<br />例: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo>=</mo><mn>01110</mn><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo>=</mo><mn>11101</mn></mrow><annotation encoding="application/x-tex">[x]_{原}=01110, [y]_{原}=11101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span><br />符号位: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>⊕</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>1110</mn><mo>×</mo><mn>1101</mn><mo>=</mo><mn>100110110</mn></mrow><annotation encoding="application/x-tex">0 \oplus 1 = 1, 1110\times 1101=100110110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo>×</mo><mi>y</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">原</mi></msub><mo>=</mo><mn>1100110110</mn></mrow><annotation encoding="application/x-tex">[x\times y]_{原}=1100110110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">原</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span></p><h5 id="mips中的乘除法运算处理"><a class="markdownIt-Anchor" href="#mips中的乘除法运算处理"></a> MIPS中的乘除法运算处理</h5><p>指令: mult, multu, div, divu。MIPS中有一对32位寄存器Hi与Lo，Hi与Lo结合起来实现64位运算器。</p><ul><li>乘法: Hi中存放高32位积，Lo中存放低32位积(与上面图硬件实现相同)。</li><li>除法: Hi中存放余数，Lo中存放商</li></ul><p>mflo/mfhi指令用来把Lo/Hi中的32位数据取到通用寄存器，两种乘法指令都忽略overflow, 而由软件自行处理溢出，并且不检测除数为零的异常。</p><h3 id="定点运算器"><a class="markdownIt-Anchor" href="#定点运算器"></a> 定点运算器</h3><p>所有运算都可通过&quot;加&quot;和&quot;移位&quot;操作实现，以一个或多个ALU(或加法器)为核心，加上移位器和存放中间临时结果的若干寄存器，在相应控制逻辑的控制下，可以实现各种运算。<br />运算部件通常指ALU、移位器、寄存器组，加上用于数据选择的多路选择器和实现数据传送的总线等构成的一个运算数据通路。</p><h2 id="浮点数运算及其运算部件"><a class="markdownIt-Anchor" href="#浮点数运算及其运算部件"></a> 浮点数运算及其运算部件</h2><p>首先直接给出浮点数运算的通用公式:<br />设: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>M</mi><mi>x</mi></msub><mo>⋅</mo><msup><mn>2</mn><msub><mi>E</mi><mi>x</mi></msub></msup><mo separator="true">,</mo><mi>y</mi><mo>=</mo><msub><mi>M</mi><mi>y</mi></msub><mo>⋅</mo><msup><mn>2</mn><msub><mi>E</mi><mi>y</mi></msub></msup></mrow><annotation encoding="application/x-tex">x=M_x\cdot 2^{E_x}, y=M_y\cdot 2^{E_y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.841331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.841331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><br />则:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>±</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mi>x</mi></msub><mo>+</mo><msub><mi>M</mi><mi>y</mi></msub><mo>⋅</mo><msup><mn>2</mn><mrow><msub><mi>E</mi><mi>x</mi></msub><mo>−</mo><msub><mi>E</mi><mi>y</mi></msub></mrow></msup><mo stretchy="false">)</mo><mo>⋅</mo><msup><mn>2</mn><msub><mi>E</mi><mi>x</mi></msub></msup></mrow><annotation encoding="application/x-tex">x \pm y = (M_x+M_y\cdot 2^{E_x-E_y}) \cdot 2^{E_x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.141331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mi>x</mi></msub><mo>+</mo><msub><mi>M</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>⋅</mo><msup><mn>2</mn><mrow><msub><mi>E</mi><mi>x</mi></msub><mo>+</mo><msub><mi>E</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x\times y = (M_x+M_y)\cdot 2^{E_x+E_y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>÷</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>M</mi><mi>x</mi></msub><mo>÷</mo><msub><mi>M</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>⋅</mo><msup><mn>2</mn><mrow><msub><mi>E</mi><mi>x</mi></msub><mo>−</mo><msub><mi>E</mi><mi>y</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">x \div y = (M_x\div M_y)\cdot 2^{E_x-E_y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285716em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>可能会出现的异常:</p><ul><li>阶码上溢: 一个正指数超过了最大允许值 =&gt; +∞/-∞/溢出</li><li>阶码下溢: 一个负指数超过了最大允许值 =&gt; +0/-0</li><li>尾数溢出: 最高有效位有进位 =&gt;右规 =&gt; 阶码增加</li><li>非规格化尾数: 数值部分高位为0 =&gt; 左规 =&gt; 阶码减少</li><li>右规或对阶时: 右段有效位丢失 =&gt; 尾数舍入 =&gt; 运算过程添加附加位(暂时保留右规移出的位，参加中间过程的计算最后再舍去)</li></ul><h3 id="浮点数加减运算"><a class="markdownIt-Anchor" href="#浮点数加减运算"></a> 浮点数加减运算</h3><ol><li>通过计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">Δ</mi><mi>E</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta E]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来判断两数的阶差，对于标准移码(对IEEE754移码同样成立)有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">Δ</mi><mi>E</mi><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>x</mi></msub><mo>−</mo><msub><mi>E</mi><mi>y</mi></msub><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>x</mi></msub><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>−</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>Y</mi></msub><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>x</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mo>−</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>y</mi></msub><msub><mo stretchy="false">]</mo><mi mathvariant="normal">移</mi></msub><msub><mo stretchy="false">]</mo><mi mathvariant="normal">补</mi></msub></mrow><annotation encoding="application/x-tex">[\Delta E]_{补}=[E_x-E_y]_{补}=[E_x]_{移}-[E_Y]_{移}=[E_x]+[-[E_y]_{移}]_{补}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">移</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><strong>(但当溢出时无法通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">\Delta E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>来判断阶差)</strong></li><li><strong>对阶</strong>: 使得两数阶码相等(原则上为小阶向大阶看齐): <strong>阶小的那个数的尾数右移</strong>，右移位数等于两个阶码差的绝对值(对单精度浮点数来说，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">\Delta E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>大于24时结果直接等于大阶的数，因为尾数仅有23位，右移24位尾数为0)</li><li><strong>尾数加减，并且尾数的附加位需要参加运算</strong></li><li>将<strong>结果规格化</strong>，即尾数高位为0，则需左规;尾数最高位有进位，需右规(阶码溢出异常处理：阶码上溢，则结果溢出;阶码下溢，则结果为0)</li><li>如果尾数比规定位数长，则需考虑<strong>舍入</strong><ul><li>就近舍入: 舍入为最近可表示的数(即最靠近LSB位为1则进，为0则舍，若为中间值: 如<code>100</code>则取决于LSB，若LSB为0则舍，为1则进)</li><li>朝+∞方向舍入: 舍入为右边最近可表示数(正向舍入)</li><li>朝-∞方向舍入: 舍入为左边最近可表示数 (负向舍入)</li><li>朝0方向舍入: 直接截取所需位，后面的位丢弃(丢弃全部附加位)</li></ul></li><li>若运算结果尾数是0，则需要将阶码也置0(尾数和阶码均为0时表示0，见<a href="https://thm-lab.github.io/2022/06/02/%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/">数据的机器级表示</a>)。</li></ol><p><img src="order_example.svg" alt="example" /><br /><img src="float_calculate.example.svg" alt="example" /></p><h3 id="浮点数乘除运算"><a class="markdownIt-Anchor" href="#浮点数乘除运算"></a> 浮点数乘除运算</h3><ol><li>求阶: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>x</mi></msub><mo>±</mo><msub><mi>E</mi><mi>y</mi></msub><mo>∓</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">E_x \pm E_y \mp 127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∓</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span></li><li>尾数相乘除: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>x</mi></msub><mo>×</mo><msub><mi>M</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">M_x \times M_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>x</mi></msub><mo>÷</mo><msub><mi>M</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">M_x \div M_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li><li>两数符号相同，结果为正；两数符号相异，结果为负</li><li>尾数高位为0，需左规；当尾数最高位有进位，需右规</li><li>如果尾数比规定的长，则需考虑舍入(与加减法舍入相同)</li><li>若尾数是0，则需要将阶码也置0。</li><li>阶码溢出判断</li></ol><h3 id="浮点数运算的精度问题"><a class="markdownIt-Anchor" href="#浮点数运算的精度问题"></a> 浮点数运算的精度问题</h3><p>其实在上面的浮点数加减法运算和乘除法运算时可以发现，可能会出现阶码上溢、阶码下溢、尾数溢出等等溢出问题，因此浮点数运算始终存在一个精度的问题，即便是没有发生溢出的情况下也有其他的问题，如在Java语言中就会存在一个很经典的问题<code>0.1 + 0.2 = 0.30000000000000004</code>。因此很多bug其实就是出现在对计算机内部浮点数的实现理解不深，这里很值得思考。</p><p><img src="float_overflow.png" alt="Overflow" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据的机器级表示</title>
    <link href="/2022/06/02/%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2022/06/02/%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-2-machine-level-representation-of-data"><a class="markdownIt-Anchor" href="#chapter-2-machine-level-representation-of-data"></a> Chapter 2: Machine Level Representation of Data</h1><p>计算机信息表示可分为外部信息与内部机器级数据:</p><ul><li>外部: 数值、文字、图形图像、声音等等</li><li>内部: 都是用二进制来表示</li></ul><p>机器级数据分两大类:</p><ul><li>数值数据: 无符号整数、带符号整数、浮点数（实数）、十进制数</li><li>非数值数据: 逻辑数(包括位串)、西文字符和汉字</li></ul><p>计算机内部所有信息都用二进制(0和1)进行编码<br />二进制编码的原因:</p><ul><li>制造二个稳定态的物理器件容易</li><li>二进制编码、计数、运算规则简单</li><li>正好与逻辑命题对应，便于逻辑运算，并可方便地用逻辑电路实现算术运算</li></ul><p>机器数和真值</p><ul><li>机器数: 用0和1编码的计算机内部的0/1序列</li><li>真值: 机器数真正的值，即：现实中带正负号的数</li></ul><h2 id="数值数据的表示"><a class="markdownIt-Anchor" href="#数值数据的表示"></a> 数值数据的表示</h2><p>数值数据主要有三种方式表示:</p><ul><li>定点数</li><li><strong>浮点数</strong></li><li>十进制数</li></ul><p>本节主要内容就是计算机内部是如何通过这三种方式来表示数据的。</p><ul><li><p>定点数:</p><ul><li>进位计数制</li><li>定点数的二进制编码(原码、补码、移码，反码几乎不用)</li><li>定点整数的表示: 无符号整数和带符号整数</li></ul></li><li><p>浮点数:</p><ul><li>浮点数格式和表示范围</li><li>浮点数的规格化</li><li>IEEE754浮点数标准: 单精度浮点数、多精度浮点数和特殊数的表示形式</li></ul></li><li><p>十进制数:</p><ul><li>ASCII码表示</li><li>BCD码表示</li></ul></li></ul><p><strong>数值数据表示的三要素:</strong></p><ul><li><strong>进位计数制</strong>: 确定一个机器数的真值必须要知道该数是按什么进制进行表示的</li><li><strong>定点/浮点表示</strong>: 定点或者浮点指的是数字的小数点位置，定点说明小数点不能移动而浮点通过一些表示方法是可以的</li><li><strong>编码的格式</strong>: 现在存在的编码格式有四种: 原码、<s>反码</s>、补码、移码，但反码基本不再使用</li></ul><p>在进行机器数和真值之间转换时，一定要知道这三要素，否则无法进行正确转换。</p><h3 id="原码-补码-移码"><a class="markdownIt-Anchor" href="#原码-补码-移码"></a> 原码、补码、移码</h3><p>首先复习原码、补码、移码的表示。</p><ul><li><strong>原码: 正数是其二进制本身；负数是符号位为1,数值部分取X绝对值的二进制</strong></li><li><strong>补码: 正数的补码和原码，反码相同；负数是符号位为1，其它位是原码取反，未位加1。</strong></li><li><strong>移码: 补码将符号位取反(标准移码)</strong></li></ul><p><strong>现在所有计算机都用补码来表示定点整数。</strong></p><p><b>值得说明的是(以8位为例): 原码中<code>0000 0000</code>和<code>1000 0000</code>均表示0，因此8位原码表示的范围为-127~127=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^8 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。但补码却解决了两个0的问题，因此补码表示的范围为-128~127=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">2^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>并且<code>1000 0000</code>刚好为-128即最小负数，移码的计算为补码将符号位取反，因此移码也能够表示128个数字。</b></p><p>上面只说了移码的计算方法，这里补充一下移码的定义:<br /><img src="shift_code.svg" alt="移码" /></p><table><thead><tr><th style="text-align:center">example</th><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><msub><mn>8</mn><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">108_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th><th style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>10</mn><msub><mn>8</mn><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">-108_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></th></tr></thead><tbody><tr><td style="text-align:center">原码</td><td style="text-align:center">01101100</td><td style="text-align:center">11101100</td></tr><tr><td style="text-align:center">反码</td><td style="text-align:center">01101100</td><td style="text-align:center">10010011</td></tr><tr><td style="text-align:center">补码</td><td style="text-align:center">01101100</td><td style="text-align:center">10010100</td></tr><tr><td style="text-align:center">移码</td><td style="text-align:center">11101100</td><td style="text-align:center">00010100</td></tr></tbody></table><h3 id="定点数"><a class="markdownIt-Anchor" href="#定点数"></a> 定点数</h3><p>定点数可以用来表示整数，包括无符号整数和带符号整数。</p><ul><li>无符号整数: 无符号整数的编码中没有符号位</li><li>带符号整数: 带符号整数的编码中有符号位(符号位在最高位MSB, Most Significant Bit)或者不需要符号位但能够表示负数的编码方式(移码)</li></ul><h4 id="带符号整数和无符号数的比较"><a class="markdownIt-Anchor" href="#带符号整数和无符号数的比较"></a> 带符号整数和无符号数的比较</h4><ol><li>扩充操作有差别<ul><li>无符号数: 0扩展即在高位直接补加0至指定位数</li><li>带符号数: 符号扩展即在高位直接补加符号位至指定位数</li></ul></li><li>数的比较有差异<ul><li>无符号数：MSB为1的数比MSB为0的数大</li><li>带符号数： MSB为1的数比MSB为0的数小(移码除外)</li></ul></li><li>溢出判断有差异(无符号数根据最高位是否有进位判断溢出，通常不判)</li></ol><p><img src="extend_example.svg" alt="example" /></p><h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h3><p>浮点数的实现思想: 可以将任意一个带小数点的数用科学计数法表示，在基数确定的情况下分别通过尾数和阶码两个数来表示一个数，在这个过程中因为阶码可以改变即意味着小数点的位置也可以改变，因此称为浮点数表示法。<br /><img src="float_point.svg" alt="浮点数" /></p><h4 id="浮点数格式"><a class="markdownIt-Anchor" href="#浮点数格式"></a> 浮点数格式</h4><p>根据IEEE754标准，浮点数分为单精度格式和双精度格式。<br /><img src="float_format.svg" alt="浮点数格式" /><br />浮点数的表示均为<strong>MSB为符号位</strong>来说明数的正负，然后由<strong>一定的位数(单精度为8位双精度为11位)非标准移码</strong>来表示数的阶码，最后的剩余的位数以原码的方式来表示尾数(单精度为23位双精度为52位，并且在规格化数中尾数只表示小数点后的数字，小数点前隐含一个<code>1</code>)。<br />因为规格化尾数最高位总是1，被隐含表示，省了1位。实际尾数位数:1+23=24 bits(单精)，1+52=53bits(双精)<br /><b>注意: 在浮点数中阶码的表示为非标准移码即单精度偏移值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">2^7-1=127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span>，双精度偏移值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>1023</mn></mrow><annotation encoding="application/x-tex">2^10-1=1023</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">3</span></span></span></span>。并且在规格化数中阶码不能为全0和全1(用来表示特殊含义)即单精度的阶码取值范围为<code>0000 0001</code>~<code>1111 1110</code></b></p><p>浮点数计算公式(基本不用但可以作为检验方式):</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">单</mi><mi mathvariant="normal">精</mi><mi mathvariant="normal">度</mi><mo>:</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>127</mn></mrow></msup></mrow><annotation encoding="application/x-tex">单精度: (-1) \times (1 + M) \times 2^{E - 127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">双</mi><mi mathvariant="normal">精</mi><mi mathvariant="normal">度</mi><mo>:</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>1023</mn></mrow></msup></mrow><annotation encoding="application/x-tex">双精度: (-1) \times (1 + M) \times 2^{E - 1023}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">双</span><span class="mord cjk_fallback">精</span><span class="mord cjk_fallback">度</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><img src="float_binary_to_decimal.svg" alt="二进制转十进制" /><br /><img src="decimal_to_float_binary.svg" alt="十进制转二进制" /></p><p>在规格化数中，阶码不能全为0或全为1，因为全0和全1具有特殊含义，其含义如下:</p><table><thead><tr><th style="text-align:center">阶码</th><th style="text-align:center">尾数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">非零值</td><td style="text-align:center">非规格化数(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.</mn><mi>f</mi><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>126</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.f \times 2^{-126}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>, 即隐含位为0)</td></tr><tr><td style="text-align:center"><code>0000 0001</code>~<code>1111 1110</code></td><td style="text-align:center">任意</td><td style="text-align:center">规格化数(正常情况)</td></tr><tr><td style="text-align:center"><code>1111 1111</code>(255)</td><td style="text-align:center">0</td><td style="text-align:center">+/-无穷大</td></tr><tr><td style="text-align:center"><code>1111 1111</code>(255)</td><td style="text-align:center">非零</td><td style="text-align:center">NaN</td></tr></tbody></table><p><img src="not_regular_number.svg" alt="数轴表示" /></p><h3 id="十进制数"><a class="markdownIt-Anchor" href="#十进制数"></a> 十进制数</h3><p>由于人类直接大量使用十进制数，计算机内部在特殊情况下也会使用十进制数，通常十进制数用0和1来表示有2种方式: ASCII码和BCD码。</p><ul><li>ASCII码: 使用ASCII码表示十进制数需要表示两个部分: 符号位和数字位，而符号位有2种方式来表示(前分隔数字串和后嵌入数字串)。<a href="https://tool.oschina.net/commons?type=4">ASCII码表</a><br />快速得到数字对应的ASCII码方法: 数字<code>x</code>对应的ASCII码为<code>3xH</code>。<ul><li>前分割字符串: 表示正负的符号单独用一个字节表示，位于数字串之前。正号用“+”的ASCII码(2BH)表示；负号用“-”的ASCII码(2DH)表示。<br />如: <code>+236</code>=<code>2B 32 33 36H</code>; <code>-236</code>=<code>2D 32 33 36H</code></li><li>后嵌入数字串: 将符号嵌入最低位数字的ASCII码高4位中。嵌入式方法：正数不变；负数高4位变为0111。<br />如: <code>+236</code>=<code>32 33 36H</code>; <code>-236</code>=<code>32 33 76H</code></li></ul></li><li>BCD(8421)码: 编码思想: 每1位十进制数用4位二进制表示。而4位二进制数可组合成16种状态，只需要选10种状态来表示十进制数。<br />如<code>-2369</code>=<code>1101 0000 0010 0011 0110 1001</code><br />        ⬆(不足3字节需要在符号与数字之间补0至整数字节，而ASCII码不需要补0)</li></ul><p>BCD码表:</p><table><thead><tr><th style="text-align:center">十进制数</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">+</th><th style="text-align:center">-</th></tr></thead><tbody><tr><td style="text-align:center">BCD码</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0010</td><td style="text-align:center">0011</td><td style="text-align:center">0100</td><td style="text-align:center">0101</td><td style="text-align:center">0110</td><td style="text-align:center">0111</td><td style="text-align:center">1000</td><td style="text-align:center">1001</td><td style="text-align:center">1100</td><td style="text-align:center">1101</td></tr></tbody></table><h2 id="非数值数据的表示"><a class="markdownIt-Anchor" href="#非数值数据的表示"></a> 非数值数据的表示</h2><h3 id="逻辑数的编码表示"><a class="markdownIt-Anchor" href="#逻辑数的编码表示"></a> 逻辑数的编码表示</h3><p>用<strong>一位二进制数表示</strong>。例如: 真:1;假: 0。N位二进制数可表示N个逻辑数据，或一个位串。<br />运算: 按位进行。如按位与/按位或/逻辑左移/逻辑右移等。<br />位串: 用来表示若干个状态位或控制位。</p><h3 id="西文字符的编码表示"><a class="markdownIt-Anchor" href="#西文字符的编码表示"></a> 西文字符的编码表示</h3><p>常用<strong>ASCII码</strong>进行表示: <code>A</code>从ASCII码表中可以得到为<code>65H</code>，<code>a</code>从ASCII码表中可以得到<code>97H</code>(<code>A</code>与<code>a</code>在ASCII码表种相差32，因为中间有其他字符)。</p><h3 id="汉字的编码表示"><a class="markdownIt-Anchor" href="#汉字的编码表示"></a> 汉字的编码表示</h3><p>汉字是表意文字，一个字就是一个方块图形。因此汉字主要有3种编码形式:</p><ul><li>输入码(外码): 对汉字用键盘上的一个或多个按键进行编码表示，用于输入汉字。常用的汉字输入码有：各种<strong>拼音码</strong>、<strong>五笔字型</strong>等编码。</li><li>内码: 用于在系统中进行存储、查找、传送等处理。每个汉字至少需要2个字节才能表示(汉字数量超过6w个)。常见的汉字内码有：<strong>GBK编码</strong>、<strong>UTF-8编码</strong>等。</li><li>字模点阵码: 描述汉字字模点阵或轮廓，用于显示/打印。常见的字模点阵码有<strong>字模点阵描述</strong>和轮廓描述2种方法。其中轮廓描述有<strong>直线向量轮廓</strong>和<strong>曲线轮廓</strong>2种方法。</li></ul><h2 id="数据的宽度"><a class="markdownIt-Anchor" href="#数据的宽度"></a> 数据的宽度</h2><p>比特(bit)是计算机中处理、存储、传输信息的最小单位。二进制信息的计量单位是&quot;字节&quot;(Byte)，也称&quot;位组&quot;。现代计算机中，存储器<strong>按字节编址</strong>，<strong>字节是最小可寻址单位</strong>(addressable unit) ，如果以字节为一个排列单位，则LSB表示最低有效字节，MSB表示最高有效字节。除比特和字节外，还经常使用&quot;字&quot;(word)作为单位。**“字长” = CPU内部总线的宽度，或运算器的位数，或通用寄存器的宽度。**数据通路上的宽度基本上要一致，才能相互匹配。<br />不同的计算机系统，字长不一样。<br /><img src="data_unit.svg" alt="数据的度量单位" /></p><h2 id="数据的存储和排列顺序"><a class="markdownIt-Anchor" href="#数据的存储和排列顺序"></a> 数据的存储和排列顺序</h2><p>现代计算机几乎都是以<strong>字节</strong>为最小可寻址单位，但寻址时需要读取一个32位字的内容，这就会涉及到字内的字节存放方式，目前有2种方式用来进行存放:</p><ul><li>大端(Big Endian):  MSB所在的地址是数的地址,即高字节放低地址。常见机器: Intel 80x86, DEC VAX</li><li>小端(Little Endian):  LSB所在的地址是数的地址，即低字节放低地址。常见机器: IBM 360/370, Motorola 68k, MIPS, Sparc, HP PA</li></ul><p>有些机器两种方式都支持，可通过特定控制位来设定采用哪种方式。</p><p>在存放数据时，大端和小端会完全按照高地址放低字节和高地址放高字节的方式来进行存储。<br /><img src="be_le_example.svg" alt="example" /></p><p>但在存储指令时，由于指令有自己的格式(操作码+寄存器号+立即数等格式, 在指令系统章节详细讲解)，不会完全依赖于存储方式。<br /><img src="instruction_example.svg" alt="example" /><br />上面例子以MIPS指令为例，因此指令为大端存储。</p><p><strong>对齐: 要求数据存放的地址必须是相应的边界地址</strong><br />目前机器字长一般为32位或64位，而存储器地址按字节编址。各种不同长度的数据存放时，有两种处理方式:</p><ul><li>按边界对齐(假定存储字的宽度为32位，按字节编址):<ol><li>字地址：4的倍数(低两位为0)</li><li>半字地址：2的倍数(低位为0)</li><li>字节地址：任意</li></ol></li><li>不按边界对齐<br /><img src="aligne_example.svg" alt="example" /></li></ul><h2 id="数据的检错与纠错"><a class="markdownIt-Anchor" href="#数据的检错与纠错"></a> 数据的检错与纠错</h2><p>存取和传送时，由于元器件故障或噪音干扰等原因会出现差错。<br />解决问题的措施:</p><ul><li>从计算机硬件本身的可靠性入手，在电路、电源、布线等各方面采取必要的措施，提高计算机的抗干扰能力</li><li>采取相应的数据检错和校正措施，自动地发现并纠正错误</li></ul><p>常见的数据校验码有: 奇偶校验码、海明校验码、循环冗余校验码。<br />奇偶校验码和CRC校验码在<a href="https://thm-lab.github.io/2022/05/29/Computer-Network-Chapter-5/">Chapter 5: Link Layer</a>中有所介绍。这里补充海明校验码的计算方法:<br />海明码是一种能够检测出2位错，纠1位错的数据校验码。具体计算方法如下:</p><ol><li>从1开始给数字的数据位（从左向右）标上序号, 1，2，3，4，5…</li><li>将这些数据位的位置序号转换为二进制，1, 10, 11, 100, 101等</li><li>数据位的位置序号中所有为二的幂次方的位(编号1，2，4，8，等，即数据位位置序号的二进制表示中只有一个1)是校验位</li><li>所有其它位置的数据位(数据位位置序号的二进制表示中至少2个是1)是新的数据位</li><li>每一位的数据包含在特定的两个或两个以上的校验位中，这些校验位取决于这些数据位的位置数值的二进制表示</li></ol><p>上面算法比较繁琐，我们用一道题为例来解释:<br />问题: 对<code>11000010</code>进行汉明编码，求编码后的码字。</p><p>1.列出表格，从左往右（或从右往左）填入数字，但2的次方的位置不填。</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">数据</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>2.把数据行有1的列的位置写为二进制。</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">数据</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">二进制列</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0011</td><td style="text-align:center"></td><td style="text-align:center">0101</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1011</td><td style="text-align:center"></td></tr></tbody></table><p>3.收集所有二进制数字，求异或。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0011</mn><mo>⊕</mo><mn>0101</mn><mo>⊕</mo><mn>1011</mn><mo>=</mo><mn>1101</mn></mrow><annotation encoding="application/x-tex">0011 \oplus 0101 \oplus 1011 = 1101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span></p><p>4.把1101依次填入表格中2的次方的位置（低位在左）。</p><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th></tr></thead><tbody><tr><td style="text-align:center">数据</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">二进制列</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0011</td><td style="text-align:center"></td><td style="text-align:center">0101</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1011</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">校验</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>5.所以编码后的码字是101110010010。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概述</title>
    <link href="/2022/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-1-computer-system-overview"><a class="markdownIt-Anchor" href="#chapter-1-computer-system-overview"></a> Chapter 1: Computer System Overview</h1><h2 id="计算机的发展历程"><a class="markdownIt-Anchor" href="#计算机的发展历程"></a> 计算机的发展历程</h2><ol><li><p>第一代计算机: 真空管计算机，1940中期~1950后期。ENICA是第一台计算机有18000多个<strong>真空管</strong>，<strong>十进制</strong>表示和运算。采用手动编程，通过设置开关和插拔连线实现。</p></li><li><p>第二代计算机: 晶体管计算机，1950后期~1960初期。逻辑元件采用<strong>晶体管</strong>，内存由磁芯构成，外存为磁鼓和磁带。可进行浮点运算，采用了中央交换结构(非总线结构)。可使用高级语言编程，提供了系统软件。代表机为IBM 7094和DEC PDP-1。</p></li><li><p>第三代计算机: 中小规模集成电路计算机，1960中期~1970中期。逻辑元件和主存均由<strong>集成电路</strong>实现。特点为微程序控制、具有cache结构、虚拟存储器和流水线等。代表机为IBM 360和DEC PDP-8。</p><ul><li><p>IBM 360引入了兼容机的概念:</p><ul><li>相同的或相似的指令集</li><li>相同的或相似的操作系统</li><li>原来机器上的程序可以不改动而在新机器上运行，但性能不同。</li></ul></li><li><p>DEC PDP-8采用了总线结构:</p><ul><li>具有高度的灵活性</li><li>允许将模块化的功能部件插入总线<br /><img src="pdp-8.svg" alt="PDP-8" /></li></ul></li></ul></li><li><p>第四代计算机: 大规模/超大规模计算机，1970初期~今天。微处理器和半导体存储器技术发展迅猛，微型计算机出现(PC)。<strong>采用半导体作为存储器</strong>。<strong>微处理器把CPU所有元件放在一块芯片</strong>。特点: 共享存储器和分布式存储器及大规模并行处理系统。代表机有争议。</p></li></ol><h3 id="冯诺依曼机"><a class="markdownIt-Anchor" href="#冯诺依曼机"></a> 冯诺依曼机</h3><p>1945年冯诺依曼提出<b>存储程序(Stored-Program)</b>思想: 将事先编好的程序和原始数据送入主存中；启动执行后，在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。<br /><strong>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</strong></p><ul><li>存储器: 不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令。</li><li>控制器: 控制器应能自动执行指令。</li><li>运算器: 运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算。</li><li>输入和输出设备: 操作人员可以通过输入设备和输出设备与主机进行通信。</li></ul><p>内部以<strong>二进制数</strong>表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作的类型，地址码指出操作数的地址。<br />采用存储程序工作方式。</p><h2 id="计算机系统的基本组成"><a class="markdownIt-Anchor" href="#计算机系统的基本组成"></a> 计算机系统的基本组成</h2><p>计算机的定义: 计算机是一种能对数字化信息进行自动、高速的算术和逻辑运算的处理装置。<br />计算机的基本部件和功能:</p><ul><li>运算器(数据运算): ALU、GPRs、标志寄存器等。</li><li>存储器(数据存储): 存储阵列、地址译码器、读写控制电路。</li><li>总线(数据传送): 数据线(MDR)、地址线(MAR)、控制线。</li><li>控制器(控制): 对指令译码产生控制信号。</li></ul><p><img src="von_neumann.svg" alt="冯诺依曼架构" /><br /><img src="current_computer.svg" alt="现代计算机结构" /><br />几乎现代所有的通用计算机都采用冯诺依曼架构，因此IAS(Institue for Advance Study at Princeton,IAS普林斯顿高等研究院)计算机是现代计算机的原型机。<br /><b></p><ul><li>CPU: 中央处理器</li><li>ALU: 算术逻辑部件</li><li>PC: 程序计数器</li><li>IR: 指令寄存器</li><li>GPRs: 通用寄存器组</li><li>MAR: 存储器地址寄存器</li><li>MDR: 存储器数据寄存器<br /></b></li></ul><p><img src="excute.svg" alt="执行过程" /><br />在程序起始地址送入PC后，计算机能<strong>自动</strong>取出一条一条指令进行执行，在执行过程中无需人的干预。</p><h2 id="计算机系统的层次结构"><a class="markdownIt-Anchor" href="#计算机系统的层次结构"></a> 计算机系统的层次结构</h2><p>软件和硬件都是计算机使用中不可或缺的部分，软件通过使用硬件来得到结果，硬件根据软件的使用方法来计算结果，而软件和硬件的沟通就是通过<strong>ISA(Instruction Set Architecture</strong>, 指令集体系结构)来进行的。<br /><img src="computer_system_architecture.svg" alt="层次结构" /></p><h3 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h3><p>软件按照用途可以分为两大类型: 系统软件和应用软件。</p><ul><li>应用软件: 根据具体场景完成具体问题的软件。如信息管理系统、网页浏览软件等</li><li>系统软件: 为应用软件的编写提供资源，使硬件资源被有效利用。<ol><li>操作系统: 实现硬件资源管理，用户接口，系统调度等功能。</li><li>语言处理系统: 翻译程序+Linker+Debug等，即高级语言的基础。<ul><li>汇编程序: 将汇编语言编写的程序翻译为机器码。</li><li>编译程序: 将高级语言程序编译为汇编语言程序或直接编译为机器码。</li><li>解释程序: 将高级语言逐句翻译为机器码且立即执行，不生成目标文件。</li></ul></li><li>实用程序: 如磁盘碎片整理程序、备份程序等。<br /><img src="computer_system_architecture_detail.svg" alt="详细层次结构" /></li></ol></li></ul><h4 id="不同层级语言之间的转换"><a class="markdownIt-Anchor" href="#不同层级语言之间的转换"></a> 不同层级语言之间的转换</h4><ul><li>第一代程序设计语言: 程序员直接编写机器码，将程序起始地址放入PC即可直接执行。</li><li>第二代程序设计语言: 使用汇编语言编写程序，经过汇编程序翻译后得到机器码，再将程序起始地址放入PC即可直接执行。</li><li>第三代程序设计语言: 使用过程式高级语言(如C语言)，程序员编写高级语言代码，经过编译语言(编译器)编译后得到汇编语言程序，再通过汇编程序翻译为机器码才能执行。</li><li>第四代程序设计语言: 非过程类语言(如面向对象型语言,C++)，与第三代语言类似，均需要通过编译程序和汇编程序转换为机器码才能执行。</li></ul><p><img src="language_layer.svg" alt="不同层级语言之间的转换" /></p><h3 id="指令系统"><a class="markdownIt-Anchor" href="#指令系统"></a> 指令系统</h3><p>ISA是一种规约(Specification)，它规定了如何使用硬件。<br />规定包括:</p><ul><li>可执行的指令的集合，包括指令格式、操作种类以及每种操作对应的操作数的相应规定。</li><li>指令可以接受的操作数的类型。</li><li>操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途。</li><li>操作数所能存放的存储空间的大小和编址方式。</li><li>操作数在存储空间存放时按照大端还是小端方式存放。</li><li>指令获取操作数的方式，即寻址方式。</li><li>指令执行过程的控制方式，包括程序计数器、条件码定义等。</li></ul><p><strong>不同ISA规定的指令集不同</strong>，如，IA-32、MIPS、ARM、RISC-V等。计算机组成必须能够实现ISA规定的功能即<strong>硬件必须要能够满足ISA要求的功能</strong>。<strong>同一种ISA也可以有不同的计算机组成</strong>，只要硬件抽象的功能能够满足ISA的需求。</p><p><img src="abstract_layer.svg" alt="计算机的不同层级" /></p><h2 id="计算机系统性能评价"><a class="markdownIt-Anchor" href="#计算机系统性能评价"></a> 计算机系统性能评价</h2><p><strong>衡量计算机性能的基本指标:</strong></p><ul><li>响应时间(Respone Time): 指从作业提交开始到作业完成所用的时间</li><li>吞吐率(Throughput): 指单位时间内所完成的工作量(在有些场合下也被称为带宽)</li></ul><p><strong>计算机性能测量:</strong></p><ul><li><p>指令执行速度(MIPS、MFLOPS/TFLOPS/PFLOPS):</p><ul><li>MIPS指每秒执行多少百万条<strong>指令</strong>(定点数指令), MIPS= 时钟频率/ (CPI x <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>)。因为不同指令执行时间不同，所以MIPS总是一个平均值。</li><li>MFLOPS: 每秒能执行的<strong>浮点运算</strong>有多少百万次，反映机器对浮点数处理的速度。<strong>注意: MFLOPS不是用执行浮点数指令数来描述</strong></li></ul></li><li><p>基准程序(Benchmark): 基准测试程序是专门用来进行性能评价的一组程序。不同用户使用的计算机用不同的基准程序，通过运行实际负载来反映计算机的性能，最好的基准程序是用户实际使用的程序或典型的简单程序。<strong>基准程序中最好包含编译器，避免编译器所产生的特殊作用!</strong></p></li></ul><p>通常把用户感觉到的执行时间分成以下两个时间:</p><ul><li>CPU时间: 指CPU真正花在执行该程序的时间。<ul><li>系统CPU时间: 为了执行用户程序而需要运行操作系统程序的时间</li><li>用户CPU时间: 用来运行用户代码的时间</li></ul></li><li>其他时间: 等待I/O操作完成或CPU花在其他用户程序的时间</li></ul><p>CPI(Cycles Per Instruction): 指每条指令所花费的时钟周期数。</p><ul><li>对于某一条特定的指令，其CPI是一个确定的值。</li><li>对于某一个程序或一台机器，其CPI是一个平均值，表示该程序或该机器指令集中一条指令执行时平均需要多少个时钟周期。</li></ul><p><strong>CPI = CPU时钟周期数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">÷</span></span></span></span> 指令条数</strong><br /><strong>用户CPU时间 = CPU时钟周期数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 时钟周期 = CPU时钟周期数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">÷</span></span></span></span> 时钟频率 = CPI <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 指令数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 时钟周期</strong></p><p>但单靠CPI不能反映CPU性能。如单周期CPU的CPI=1，但性能差。<br /><img src="cpi_example.svg" alt="example" /><br /><img src="mips_example.svg" alt="example" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Organization and Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Chapter 5</title>
    <link href="/2022/05/29/Computer-Network-Chapter-5/"/>
    <url>/2022/05/29/Computer-Network-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-5-link-layer"><a class="markdownIt-Anchor" href="#chapter-5-link-layer"></a> Chapter 5: Link Layer</h1><p><strong>数据链路层的职责：将数据帧通过一个链路，从一个节点传输到临近的另一个节点。</strong><br />节点:主机和路由器(包括网桥和交换机)。<br />链路: 沿着通信路径连接相邻节点的通信信道。</p><ul><li>有线链路</li><li>无线链路</li><li>局域网</li></ul><p>链路层的特点:</p><ul><li>分组传输可以经过不同的链路使用不同的协议实现即链路上可以在不同段采用不同的协议</li><li>每个链路协议提供不同的服务</li></ul><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h2><ul><li>成帧:<ul><li>把网络层数据报加头和尾，封装成帧。</li><li>帧头中包括指明目的和源的&quot;物理地址&quot;(不同于IP地址)。</li></ul></li><li>链路访问:<ul><li>Medium Access Control,MAC(媒体访问控制)协议。</li><li>共享媒体的多路访问。</li></ul></li><li>在邻接节点间的可靠传输</li><li>差错检测:<ul><li>差错由信号衰减和噪声引起。</li><li>接收者检测错误：如果发现差错要求发送方重传或丢弃。</li></ul></li><li>纠错: 接收者检测和纠正错误，不需发送者重传。</li><li>半双工和全双工:<ul><li>半双工，一个节点不能同时传输和接收。</li><li>全双工，节点可以同时传输和接收。</li></ul></li><li>流量控制: 在邻接的发送节点和接收节点间的同步调节</li></ul><p><img src="link_layer.svg" alt="Link Layer" /></p><h2 id="error-detection-and-correction-techniques错误检测和纠正技术"><a class="markdownIt-Anchor" href="#error-detection-and-correction-techniques错误检测和纠正技术"></a> Error Detection and Correction Techniques(错误检测和纠正技术)</h2><p>通过EDC位(Error Detection and Correction bits)检验，UDP校验和也是同样的思想。因此错误检测并不是100%可靠，而是存在漏掉错误的可能性，大的EDC域能提供更好的检错和纠错能力。<br />三种常用的检测方法:</p><ul><li>奇偶校验:<ul><li>单字节奇偶校验:<ol><li>奇校验: 那么把每个位相加结果为奇数则校验位为0，否则为1。</li><li>偶校验: 那么把每个位相加结果为偶数则校验位为0，否则为1<br />只能检测出单个位错误，没有纠错能力。</li></ol></li><li>二维偶数奇偶校验:<br /><img src="two_dimension_detection.svg" alt="二维偶数奇偶校验" /><br />检测和纠正单个位的错误,检测任意组合的两个错误。</li></ul></li><li>Internet校验和: 在UDP校验和计算部分有详细说明。<a href="https://thm-lab.github.io/2022/05/26/Computer-Network-Chapter-3/">UDP checksum</a></li><li><strong>CRC(Cyclic Redundancy Check)</strong>:<br /><img src="crc.svg" alt="CRC" /><ol><li>商定多项式(r+1位)，并得到G(r+1位)。<br />example:<br />多项式: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^3 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mn>1001</mn></mrow><annotation encoding="application/x-tex">G=1001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span><br />多项式: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>x</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">x^3 + x^2 + x^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span> =&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mn>1110</mn></mrow><annotation encoding="application/x-tex">G=1110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span></li><li>给D补加r位0得到d+r位作为被除数</li><li>计算出r位的冗余位。<br /><img src="crc_example.svg" alt="example" /><br />从例子来看，将D以二进制数形式作为被除数，G作为除数，当被除数与除数位数相同时，结果上1，当被除数与除数位数不同时，结果上0。最后的余数即是冗余位。</li></ol></li></ul><h2 id="multiple-access-link-and-protocols多路访问链路和协议"><a class="markdownIt-Anchor" href="#multiple-access-link-and-protocols多路访问链路和协议"></a> Multiple Access Link and Protocols(多路访问链路和协议)</h2><p>链路按照使用方式不同可以大致的分为2组:</p><ul><li>点对点: PPP （用于拨号访问）或HDLC</li><li>广播: 传统以太网以及802.11无线局域网(多路访问链路即指的是该类型链路)</li></ul><p>对于点对点链路是单条连接使用对应的所有的链路资源，但对广播链路则是所有连接使用相同的链路资源，因此当两个或多个节点同时传输时，就会产生冲突。在某个时刻只有一个节点发送数据才可以发送成功信息。</p><p>为避免冲突来保障数据的正确传输，提出了多路访问协议。<br />多路访问协议:</p><ul><li>分布式算法决定各节点如何共享信道，即决定节点什么时候可以传数据。</li><li>共享信道既要负责进行数据传输，又要负责分布式算法的控制信息的传输(即控制信息没有带外信道来传输，只能在共享信道上传输)。</li></ul><h3 id="理想的多路访问协议"><a class="markdownIt-Anchor" href="#理想的多路访问协议"></a> 理想的多路访问协议</h3><p>在速率为R bps的广播信道上:</p><ul><li>当一个节点有数据发送时，它能以R bps的速率发送。(独享时满载运行)</li><li>当有M个节点要发送数据，每个节点的平均发送速率为R/M(公平均分信道)</li><li>完全分散:<ol><li>不需要主节点协调传输(分布式要求)</li><li>不需要时钟、时隙同步(半自主)</li></ol></li><li>简单</li></ul><h3 id="多路访问协议的实现"><a class="markdownIt-Anchor" href="#多路访问协议的实现"></a> 多路访问协议的实现</h3><ul><li><p>信道划分:</p><ol><li>时分: Time Division Multiple Access协议。<br />将一个周期分为不同的时隙(时隙长度通常为数据服务单元的发送时间)，每个节点分配到一个固定的时隙，节点只能在自己的时隙上发送数据。空闲时隙则被浪费。<br /><img src="tdma.svg" alt="TDMA" /></li><li>频分: Frequency Division Multiple Access协议。<br />将信道按照频率划分，每个节点分配到一个固定的频率，节点只能在自己的频率上任何时间发送数据。<br /><img src="fdma.svg" alt="FDMA" /></li><li><strong>码分:</strong> Code Division Multiple Access协议。<br />每个节点分配一个唯一的编码，每个节点用它唯一的编码来对它发送的数据进行编码，节点可以在任何时间发送而不产生冲突。(编码通过正交等数学手段实现同时发送却仍然可以不冲突)</li></ol></li><li><p>随机访问:<br />当节点需要发送数据时候立马以满速率进行发送而不考虑是否会发生冲突。但要求随机访问能够<strong>检测冲突</strong>和<strong>从冲突中恢复</strong>。</p><ol><li><p>ALOHA:</p><ul><li>无需时隙同步。</li><li>当有数据到达即里面发送而不检测冲突。</li><li>由于不检测当前信道情况因此冲突概率高。</li><li>多节点时效率低。<br /><img src="aloha.svg" alt="ALOHA" /></li></ul></li><li><p>时隙ALOHA:</p><ul><li>假设所有帧大小相同</li><li>时间被划分为相同大小的时隙，一个时隙等于传送一帧的时间</li><li>节点需要同步</li><li>需要节点有检测冲突能力</li></ul><p>具体实现:</p><ol><li>当节点要发送新帧，它等到下一时隙开始时传送</li><li>没有冲突，节点可以在下一时隙发送新帧</li><li>如果有冲突，节点在随后的时隙以概率p重传该帧，直到成功为止。</li></ol><p>与ALOHA不同，时隙ALOHA会在发送前检测信道是否有冲突，如果无才发送，有则延迟发送来降低冲突发生的概率。但相对ALOHA来说时隙ALOHA对时隙的浪费更为严重，却优于信道划分中的时分。</p><p><img src="timeslots_aloha.svg" alt="Time-slots ALOHA" /></p></li><li><p>CSMA-&gt;<strong>CSMA/CD</strong>: Carrier Sense Multiple Access(载波侦听多路访问)协议。</p><ol><li>CSMA: 在发送前侦听，如果信道闲：传送整个帧，如果信道忙：延迟传送。但冲突还是可能发生: 传播延迟可能导致两个节点没侦听到其它节点的传送。<br /><img src="csma.svg" alt="CSMA" /></li><li>CSMA/CD:<ol><li>当一个节点要发送数据时，首先监听信道，看是否有载波。</li><li>如果信道空闲，则发送数据；如果信道忙，则继续对信道进行监听。一旦发现空闲，便立即发送。</li><li>如果在发送过程中未检测到碰撞，则传输成功；否则停止正常发送，转而发送一短暂的干扰信号jam，强化冲突，使其它站点都能知道出现了冲突。</li><li>发送了干扰信号后，指数退避一随机时间,即假设该帧经过n次冲突后，适配器在{0,1,2,…,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>}中随机选取一个K值，其中m=min(n,10),然后等待K*512比特时间后,回到第2步。(512bits是因为以太网的<strong>最小帧长度为64bytes</strong>)</li></ol></li></ol><p>  <b>jam拥塞信号: 48比特，确保所有传送者知道冲突发生。</br>  指数回退: 在{0,1,2,…,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^m-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>}中随机选取一个K值来计算回退时间</br>  比特时间: 对于10 Mbps Ethernet为0.1微秒，当K=1023，回退时间大约50毫秒。</b><br /><img src="csma_cd.svg" alt="CSMA/CD" /></p></li></ol></li><li><p>轮转:<br />信道划分在低负载情况下只能利用少数信道，对信道的浪费很多但高负载下信道公平分配。随机访问在高负载情况下冲突开销大但低负载利用率高。轮转协议是信道划分和随机访问的折中方案。<br />轮转的两种实现方案:</p><ul><li>轮询: 主节点轮流 “邀请”从属节点传送数据。但是有一定的缺点: 轮询开销、延迟、主节点失效，整个网络失效。</li><li>令牌传递: 控制令牌从一个节点顺序传到下一个节点。但也存在令牌的开销、延时和令牌失效的问题。</li></ul></li></ul><p><img src="mac_summary.svg" alt="总结" /></p><h2 id="switched-local-area-networks交换局域网"><a class="markdownIt-Anchor" href="#switched-local-area-networks交换局域网"></a> Switched Local Area Networks(交换局域网)</h2><p>多址访问协议广泛应用于局域网。基于随机访问的CSMA/CD广泛应用于局域网。基于令牌传递技术的令牌环和FDDI在局域网技术中变得次要。链路层技术的发展，局域网、城域网、广域网的概念变得越来越模糊和不重要。<br /><img src="lan.svg" alt="局域网" /></p><h3 id="link-layer-addressing-and-arp链路层编址和地址解析协议"><a class="markdownIt-Anchor" href="#link-layer-addressing-and-arp链路层编址和地址解析协议"></a> Link Layer Addressing and ARP(链路层编址和地址解析协议)</h3><h4 id="link-layer-addressing"><a class="markdownIt-Anchor" href="#link-layer-addressing"></a> Link Layer Addressing</h4><p>网络层使用32位IP地址来表示一个接口。而链路层使用48位的MAC地址来表示一个接口。MAC地址由IEEE统一分配，厂商需要购买一块MAC地址空间用来给每台设备分配一个MAC地址。<br />但是网络层传送下来的为IP地址，无法得到目的节点的MAC地址。因此便提出了ARP协议来从IP地址转换到MAC地址从而进行链路层转发。<br /><img src="dataframe.svg" alt="数据帧" /></p><h4 id="address-resolution-protocol"><a class="markdownIt-Anchor" href="#address-resolution-protocol"></a> Address Resolution Protocol</h4><p>每个在局域网上的IP节点(Host, Router)都有ARP表，其中ARP表中有着局域网上一些节点的IP/MAC地址映射关系，通过ARP表即可实现从IP地址到MAC地址的转换。<br /><strong>ARP表结构: &lt; IP address; MAC address; TTL&gt;</strong><br />TTL(Time To Live): 映射地址的失效时间 (典型为20分钟)。<br />若ARP表中不存在目的IP地址与其MAC地址的映射，则当前节点会发送ARP请求，通过向<code>FF-FF-FF-FF-FF-FF</code>广播地址发送ARP查询，在局域网上的所有机器都能收到ARP查询。当收到需要查询的IP地址为自己时，该节点会将自己的MAC地址通过包单播(unicast)的方式发送给ARP查询的节点。于是查询节点更新自己的ARP表。<br /><img src="link_layer_example.svg" alt="example" /></p><h3 id="ethernet以太网"><a class="markdownIt-Anchor" href="#ethernet以太网"></a> Ethernet(以太网)</h3><p>以太网是主流的LAN技术，具有价格便宜、高速率的优点。</p><h4 id="ethernet-frame"><a class="markdownIt-Anchor" href="#ethernet-frame"></a> Ethernet Frame</h4><p><img src="ethernet.svg" alt="以太网帧结构" /></p><ul><li>Preamble: 是后续加的结构，这里不做说明，计算时也不参加。</li><li>目的MAC地址和源MAC地址: 是以太网帧的主要内容，每个地址都是48bits(6bytes)，用来查找传输接口。</li><li>Type: 指明上层协议的类型，如IP协议等。</li><li>Data: <strong>注意: Data区最小为46字节，哪怕只有1字节的数据需要传输也需要将其补全为46字节，因此以太网的最小帧为64bytes(6 + 6 + 2 + 46 + 4) = 64</strong></li><li>CRC: 存放冗余校验码。</li></ul><p>以太网不提供可靠的数据传输服务，因为它是无连接不确认的一种协议。</p><ul><li>无连接：发送和接收适配器间不握手。</li><li>不可靠：接收适配器不向发送适配器发送确认帧，因此没有确保数据完整传输和按序到达的服务。</li></ul><p>以太网使用CSMA/CD来进行发送数据，因此没有时隙，会在发送前监听冲突和在发生冲突后发出警告，监听到冲突后也会有一个避让冲突的重传机制。</p><h4 id="hub集线器"><a class="markdownIt-Anchor" href="#hub集线器"></a> hub(集线器)</h4><p><img src="hub.svg" alt="集线器" /><br />集线器本质为物理层中继器，只有将bit信号整形放大和转换功能，没有其他更多的特性和功能。<br /><img src="hub_detail.svg" alt="集线器" /><br /><strong>使用hub的网段仍然处于同一个冲突域内。</strong></p><h4 id="switch交换机"><a class="markdownIt-Anchor" href="#switch交换机"></a> switch(交换机)</h4><p>交换机的本质是多口网桥，可以将多个网络接口连接在一起，从而实现多个网络接口之间的互联。在收到以太网帧后会检查帧头,并根据目的MAC地址有选择的转发帧。当MAC帧被转发到某一共享网段时,交换机会使用CSMA/CD访问该网段。<br />交换机有自学习功能，会根据过往记录来自己生成和更新交换表从而知道转发方式。当目的地址不在交换表中时，交换机会将帧发给所有连接的接口(除收到该帧的接口外)。<br /><img src="switch_example.svg" alt="example" /><br />通过交换机把子网划分为多个LAN网段后，每个LAN网段都变成一个独立的冲突域。因此在内部可以同时交换，不会发生冲突。</p><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><p><img src="review1.svg" alt="review" /><br /><img src="review2.svg" alt="review" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Chapter 4</title>
    <link href="/2022/05/28/Computer-Network-Chapter-4/"/>
    <url>/2022/05/28/Computer-Network-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-4-network-layer"><a class="markdownIt-Anchor" href="#chapter-4-network-layer"></a> Chapter 4: Network Layer</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>网络层负责将数据报从发送方主机传输到接收方主机，网络层协议存在于每台主机和路由器上，路由器将检查所有经过它的IP分组的分组头。<br />网络层的主要功能:</p><ul><li>转发: 路由器将收到的分组移动到适当的输出链路。</li><li>选路: 决定分组从源端到目的端所经过的路径.<br />网络层还有第三种功能: 连接建立，但这只在某些网络体系结构上有所实现，在Internet上并没有提供这种功能。</li></ul><p>网络服务模型:</p><ul><li>网络层为单个数据分组提供的服务:<ol><li>确保交付</li><li>具有时延上界（不到40ms ）的确保交付</li></ol></li><li>网络层为分组的流提供的服务:<ol><li>有序的分组递交</li><li>确保最小带宽</li><li>确保最大时延抖动<br />**但是！**现在的因特网网络层并没有提供上述服务，因特网只提供了尽力而为的服务(实际上就是没有提供任何特定的服务)。<br /><img src="service_model.svg" alt="网络层服务模型" /></li></ol></li></ul><p>routing: 决定分组从源端到目的端所经过路径的过程。<br />forwarding: 将分组从一个输入链路接口转移到适当输出链路接口的过程。</p><h2 id="principles-of-router"><a class="markdownIt-Anchor" href="#principles-of-router"></a> Principles of Router</h2><p>路由器的主要功能:</p><ul><li>运行路由算法(RIP, OSPF, BGP)，为选路服务</li><li>将分组从输入链路转发到适当的输出链路，转发服务<br /><img src="router.svg" alt="路由器" /><br />由上图可以看到，路由器的工作原理就是将分组从输入链路根据转发表转发到输出链路。涉及到的问题主要就是路由表的更新、路由算法的运行和转发的实现。</li></ul><p>其中实现转发功能的我们称之为Data Plane(数据平面)，实现选路功能的我们称之为Control Plane(控制平面)。</p><h2 id="data-plane数据平面"><a class="markdownIt-Anchor" href="#data-plane数据平面"></a> Data Plane(数据平面)</h2><h3 id="router路由器"><a class="markdownIt-Anchor" href="#router路由器"></a> Router(路由器)</h3><h4 id="input-port"><a class="markdownIt-Anchor" href="#input-port"></a> Input Port</h4><p><img src="input_port.svg" alt="输入端口" /><br />输入端口从链路层拿到数据帧，通过缓存查询转发表后将其通过交换结构转发到对应的输出端口。</p><h5 id="转发表格式"><a class="markdownIt-Anchor" href="#转发表格式"></a> 转发表格式</h5><p>由于在网络层没有呼叫建立，路由器没有像端到端那样的连接概念，因此对分组的转发只能根据目的主机地址来确定。并且在同一个源-目的主机对中的分组可能走不同的路径，因为路由表是一张动态的表，会时常发生改变，即便是同一个传输层的连接也可能通过不同的路由器进行传输。</p><p>根据目的主机地址来转发的方法有最长前缀匹配法: 通过将分组发送到转发表内的匹配成功最长前缀项对应的输出链路来实现转发的功能。当转发表中有多个输出链路具有匹配前缀时，应当选取最长的匹配项作为输出链路。</p><p><img src="max_prefix_match.svg" alt="最长前缀匹配" /><br />通过示例的最长前缀匹配转发表可以知道，目的地址为<code>11001000 00010111 00010110 10100001</code>的分组应该转发到0号输出链路;目的地址为<code>11001000 00010111 00011000 10101010</code>的分组应该转发到1号输出链路。</p><h4 id="switch-structure交换结构"><a class="markdownIt-Anchor" href="#switch-structure交换结构"></a> Switch Structure(交换结构)</h4><p><strong>交换速度：分组从输入端到输出端的速度。</strong><br />交换结构的功能是将分组从输入缓冲区交换到适当的输出缓冲区。目前主要有3种不同的交换结构，分别是:</p><ul><li>Switching via memory(内存交换): 为第一代路由器采用的方案，分组被拷贝到系统内存，然后由CPU的直接控制完成。速度受内存带宽限制 (每个分组需要两次经过总线，一次拷贝进内存一次由内存拷贝进输出链路缓存)。不支持同时传输多个分组。</li><li>Switching via bus(总线交换): 分组从输入端口缓存经过一根共享总线到达输出端口缓存。交换速率受总线带宽限制(一般来说对接入路由器和企业路由器足以)。不支持同时传输多个分组。</li><li>Switching via interconnection network(互联网络交换): 通过内部互连网络，克服总线带宽限制，并且<strong>支持同时传输到多个输出端口</strong>。</li></ul><p><img src="switch_structure.svg" alt="交换结构" /></p><h4 id="output-port输出端口"><a class="markdownIt-Anchor" href="#output-port输出端口"></a> Output Port(输出端口)</h4><p><img src="output_port.svg" alt="输出端口" /></p><h4 id="queueing排队"><a class="markdownIt-Anchor" href="#queueing排队"></a> Queueing(排队)</h4><p>当网络中需要传输的数据报过多时，就会产生一个排队，尽管输入链路和输出链路上存在一定的缓冲区，但大小终究是有限的，当缓冲区满时，新到的数据报会导致缓存的溢出，这样就会导致分组的丢失。根据排队的位置不同可以分为:</p><ul><li><p>输入端口排队: 当交换速度比所有输入端口的综合速度慢时就会导致输入端口产生排队，排队过长当溢出时就会导致分组的丢失。输入端口有一种特殊的阻塞: 线头阻塞Head-of-the-Line (HOL) blocking:排在队列前面的分组阻止队列中其他的分组向前移动，因为内存交换和总线交换无法同时对不同输出端口进行交换，导致了部分端口繁忙但是其他端口空闲总体却阻塞严重的情况。<br /><img src="input_port_queueing.png" alt="输入端口排队" /></p></li><li><p>输出端口排队: 当分组从交换结构到达的速率快于输出链路速率时,需要缓存就会产生排队，排队过长当溢出时就会导致分组的丢失。<br /><img src="output_port_queueing.png" alt="输出端口排队" /></p></li></ul><h2 id="the-internet-protocolip协议"><a class="markdownIt-Anchor" href="#the-internet-protocolip协议"></a> The Internet Protocol(IP协议)</h2><p><strong>IP地址: 分配给主机或路由器接口的32-bit标识符。</strong><br />接口: 主机/路由器与物理链路之间的边界。</p><ul><li>路由器有多个接口</li><li>主机可以有多个接口</li><li>每个接口有一个IP地址</li></ul><p>IP地址:</p><ul><li>子网部分 (高位 bits)</li><li>主机部分 (低位 bits)</li></ul><h3 id="ipv4-datagram-formatipv4数据报格式"><a class="markdownIt-Anchor" href="#ipv4-datagram-formatipv4数据报格式"></a> IPv4 Datagram format(IPv4数据报格式)</h3><p><img src="ipv4_datagram.svg" alt="IPv4数据报格式" /><br />IPv4的典型首部为20Bytes(没有可变长的选项)。</p><ul><li>版本号: IPv4为4，IPv6具有自己的数据报格式。</li><li>头部长度: 头部长度是头部的字节数，不包括数据部分。<strong>注意，这个值是以4个字节为单位的。</strong></li><li>服务类型: 较少使用。</li><li>总长度: 数据报的总长度，包括头部和数据部分。<strong>注意，这个值是以单个字节为单位的。</strong></li><li>分片ID: 用于标识分片后的唯一标识，有助于分片后重组。</li><li>flag: 标志位，用于确定是否为最后一个分片(最后一片为1，非最后一片为0)。</li><li>offset: 偏移量，用于标识分片后的本片数据在原数据报的开始位置，可以保障是否丢片和用来重组。<strong>注意，这个值是以8个字节为单位的。</strong></li><li>ttl: 生存时间，路由器在路由到目的地之前，每过一个路由器这个字段的值会-1。</li><li>upper layer protocol: 协议类型，用于标识下一层协议。</li><li>校验和: 校验和用于校验数据报的正确性。</li><li>源IP地址和目的IP地址: 用以路由器转发。</li></ul><h3 id="ipv4-datagram-fregmentationipv4分片"><a class="markdownIt-Anchor" href="#ipv4-datagram-fregmentationipv4分片"></a> IPv4 Datagram Fregmentation(IPv4分片)</h3><p>网络链路有MTU(Maximum Transmission Unit)限制，不同的链路类型有不同的MTUs。因此在底层链路层采用不同链路类型，数据报允许的最大长度也不同，这样很难具有一个统一的标准并且链路不同段采用的类型也不同，数据报的大小会收到木桶效应的影响，对网络层造成了不好的影响，因此引入了分片和重组技术。</p><ul><li>分片: 大的IP数据报在网络中被划分，即一个数据报被分成多个小数据报，这些小数据报的长度不大于MTU。</li><li>分组: 最终目的地在收到数据报的片后进行重新组装成完整的初始数据报的操作。</li></ul><p><img src="fragmentation.svg" alt="IPv4分片" /><br /><img src="fragmentation_example.svg" alt="example" /><br />**注意: 分片后的数据报长度要算上头部长度后仍不超过MTU。**即MTU为1500bytes时，原数据报长度为4000bytes，其中数据部分为3980bytes，则第一个片只能承载1480bytes的数据部分，第二个片承载1480bytes的数据部分，第三片则承载1020btyes的数据部分，但每一片都有自己的20bytes的首部。分片在计算偏移量时不需要将头部长度加上，只需要对数据部分计算即可，<strong>千万记住offset的单位是8个字节！！！</strong>。</p><h3 id="ipv4-addressingipv4编址"><a class="markdownIt-Anchor" href="#ipv4-addressingipv4编址"></a> IPv4 Addressing(IPv4编址)</h3><p>子网: 为了确定子网，分开主机和路由器的每个接口，从而产生了几个分离的网络岛，这些独立网络中的每一个叫做一个子网</p><ul><li>设备接口的IP地址具有同样的网络部分</li><li>没有路由器的介入，物理上能够相互到达</li></ul><p><img src="subnet_example.svg" alt="子网" /></p><p>子网掩码的功能：给定IP地址和子网掩码，即可获得该IP地址主机所在的网络地址(作掩码计算)。</p><ul><li><p>分类IP地址:<br /><img src="subnet_mask.svg" alt="子网掩码" /></p></li><li><p>Classless Inter-Domain Routing(无类域间路由)<br />地址中的网络部分可以任意长。地址格式: a.b.c.d/x, 这里 x 是地址网络部分的bit数。<br /><img src="subnet_cidr_example.svg" alt="CIDR example" /></p></li></ul><h3 id="层次寻址和dhcp"><a class="markdownIt-Anchor" href="#层次寻址和dhcp"></a> 层次寻址和DHCP</h3><p>层次寻址允许有效的路由信息通告:<br /><img src="Hierarchical_addressing.svg" alt="层次寻址" /><br />可以看出层次寻址能体现更加具体的路由关系，更加体现出子网存在的意义，也减少了网络核心区域的传输压力，但同时也引出了子网下IP分配的问题，对此DHCP(Dynamic Host Configuration Protocol)协议可以解决。</p><p>DHCP:</p><ul><li>允许主机在加入网络时从网络服务器动态得到IP地址</li><li>能够在使用时续借地址租用</li><li>允许重用地址 (只是连接时拥有地址）</li><li>支持准备加入网络的移动用户 (更简单)</li></ul><p><img src="dhcp.svg" alt="DHCP" /></p><h3 id="internet-control-message-protocol控制消息协议"><a class="markdownIt-Anchor" href="#internet-control-message-protocol控制消息协议"></a> Internet Control Message Protocol(控制消息协议)</h3><p>ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议。<br />ICMP的功能包括:</p><ul><li>确认IP包是否成功到达目标地址。</li><li>通知在发送过程中IP包被丢弃的原因。</li></ul><p>从上面ICMP的功能可以看出，ICMP就是一个​​&quot;错误侦测与回报机制”​&quot;，​​其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性。<br /><img src="icmp.svg" alt="ICMP协议" /></p><h4 id="icmp主要运用"><a class="markdownIt-Anchor" href="#icmp主要运用"></a> ICMP主要运用</h4><ul><li>测试网络连通性和时延(ping)<br /><img src="ping.svg" alt="ping" /><br /><img src="ping_example.png" alt="ping" /></li><li>测试网络的可靠性(tracert)<br /><img src="tracert.png" alt="tracert" /></li></ul><h3 id="ipv6"><a class="markdownIt-Anchor" href="#ipv6"></a> IPv6</h3><p>初始动机: 32-bit地址空间即将用尽。<br />其他动机:</p><ul><li>首部格式可帮助加速处理/转发</li><li>改变首部利于QoS要求</li></ul><p><img src="ipv6_datagram.svg" alt="IPv6" /><br />IPv6的特点:</p><ul><li>地址长度为128bit</li><li>不允许分片</li><li>首部固定为40bytes(不允许存在选项)</li></ul><h4 id="ipv4过渡到ipv6的方式"><a class="markdownIt-Anchor" href="#ipv4过渡到ipv6的方式"></a> IPv4过渡到IPv6的方式</h4><p>并不是所有的路由器都能够同时升级，所以不存在标志日。</p><ul><li>双栈: 一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换。<br /><img src="double_stack.svg" alt="双栈方式" /></li><li>隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载。<br /><img src="tunnel.svg" alt="隧道方式" /></li></ul><h3 id="nat"><a class="markdownIt-Anchor" href="#nat"></a> NAT</h3><p>具体见<a href="https://www.overleaf.com/project/62342d1f865e4b293438089c">课程设计</a></p><h2 id="control-plane控制平面"><a class="markdownIt-Anchor" href="#control-plane控制平面"></a> Control Plane(控制平面)</h2><p>数据平面完成了逻辑上的转发功能，但前提要求是有一张路由表作为输入端口和输出端口间的映射，而控制平面的主要功能就是完成路由表的生成和更新，以及层次的选路算法。</p><h3 id="routing-algorithm选路算法"><a class="markdownIt-Anchor" href="#routing-algorithm选路算法"></a> Routing Algorithm(选路算法)</h3><p>选路算法根据当前掌握的信息不同而有不同的实现，如:</p><ul><li>具有全局信息——链路状态算法</li><li>仅知道直接相连的信息——距离矢量算法</li></ul><p>同时根据网络环境的不同也可以分为静态路由和动态路由两种，当链路质量相对稳定时，路由变化很慢，可以由人工进行设置最优或有所偏好的路由表。而当路由变化很快时，路由表需要时常更新，则需要选路算法来自适应链路状态的改变。</p><p>在控制平面的学习中主要还是考虑动态路由的实现，因此需要掌握链路状态路由协议和距离向量路由协议。</p><h4 id="the-link-state-routing-protocol链路状态路由协议"><a class="markdownIt-Anchor" href="#the-link-state-routing-protocol链路状态路由协议"></a> The Link-State Routing Protocol(链路状态路由协议)</h4><p>链路状态路由协议本质就是dijkstra算法的运用，在拥有全局信息的前提下可以找到从一个节点到任意一个节点的最短路径。<br />重温dijkstra算法:<br /><img src="dijkstra.svg" alt="dijkstra算法" /><br /><b>注意: 下一个加入trash点集的点为距离起点最近的点</b><br />通过dijkstra算法可以算出从当前节点到其他所有节点的最短路径，并且可以给出沿途经过的节点从而得到下一跳的路由器IP，最终得到转发表。<br />这里通过一个例子来详细说明如何使用dijkstra算法实现路由表计算:<br /><img src="dijkstra_example.svg" alt="example" /></p><p>在数据结构课程上有一个大作业就是利用dijkstra算法来实现路由表的生成与更新，当时并不知道链路状态路由协议是什么，但是通过对图的最短路径寻找同样能得到最优路由表。<br />代码与实验报告在<a href="%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C.zip">点击下载: (路由协议设计实验)</a>，可以作为参考。</p><h4 id="the-distance-vector-routing-protocol距离向量路由协议"><a class="markdownIt-Anchor" href="#the-distance-vector-routing-protocol距离向量路由协议"></a> The Distance Vector Routing Protocol(距离向量路由协议)</h4><p>距离向量路由协议的算法基础为Bellman-Ford方程:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_x(y) = min_v{c(x,v) + d_v(y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_x(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是从x到y的具有最低开销路径的开销值，V是x的相邻节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">min_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是对于与x相连的所有邻居而言。</p><p>距离向量的基本思想是每个节点周期性的给相邻节点发送自己的距离向量估值，当节点x从它的任何一个邻居v收到一个新的距离向量估值,就使用B-F 方程更新自己的距离向量估值。从远处节点的链路状态改变后需要时间逐渐传向起点的路由器，因此距离向量路由协议是一个随着时间而收敛的路由算法，新的最优路径无法瞬间得到，但链路状态路由协议如果不考虑算法计算的时间则是瞬间即可得到新路径的算法。<br /><img src="distance_vector_example.svg" alt="example" /><br /><img src="distance_vector_solution.svg" alt="example" /></p><h4 id="comparation-of-ls-and-dv链路状态和距离向量的比较"><a class="markdownIt-Anchor" href="#comparation-of-ls-and-dv链路状态和距离向量的比较"></a> Comparation of LS and DV(链路状态和距离向量的比较)</h4><p><img src="ls_dv_comparation.svg" alt="比较" /></p><h3 id="internets-routing-protocol互联网的路由协议"><a class="markdownIt-Anchor" href="#internets-routing-protocol互联网的路由协议"></a> Internet’s Routing Protocol(互联网的路由协议)</h3><p>迄今为止，我们的路由研究都是理想化的，所有路由器一样的，网络是平面的，但实际中并不是这样的。<br />因为Internet具有超过20亿个节点，路由表中不可能存储所有的节点。路由表的信息交换将淹没数据链路。同时由于具有很多子网具有自己的路由规则，并不按照最短路径来安排路由。</p><p><b>AS: 一个区域内的路由器组成集合称为自治系统。</b>同一个自治系统的路由器运行相同的路由协议，不同的AS内可以运行不同的区域内路由协议。<br />网关路由器: 和其他自治系统内的路由器直接相连的路由器，运行域间路由协议，与其他网关路由器交互，同自治系统内的所有其他路由器一样也运行域内路由协议。即<b>网关路由器同时运行域间和域内2种路由协议。</b></p><h3 id="域间选路"><a class="markdownIt-Anchor" href="#域间选路"></a> 域间选路</h3><p>AS互联: AS内的路由器接收到了目的端是AS外的分组，则路由器需要将分组转发给网关路由器，而网关路由器则需要将自己连接到的AS信息传播给AS内的所有路由器，这样就能实现AS互联。</p><h4 id="border-gateway-protocol边界网关协议"><a class="markdownIt-Anchor" href="#border-gateway-protocol边界网关协议"></a> Border Gateway Protocol(边界网关协议)</h4><p>BGP提高的服务:</p><ul><li>从相邻AS获取子网可达信息。</li><li>向网关路由器所在AS内部的所有路由器传播这些可达性信息。</li><li>基于该可达信息和AS策略，决定到达子网的&quot;好&quot;路由。</li><li>宣布AS的存在。<br /><img src="bgp_example.svg" alt="example" /></li></ul><p>eBGP: 域间路由协议。(external)<br />iBGP: 域内路由协议。(internal)</p><h4 id="hot-potato热土豆"><a class="markdownIt-Anchor" href="#hot-potato热土豆"></a> Hot Potato(热土豆)</h4><p>Hot Potato: 当AS内路由器知道某分组通过多个AS均可到达，热土豆原则就会选择将该分组转发给最近的网关路由器。</p><h3 id="域内选路"><a class="markdownIt-Anchor" href="#域内选路"></a> 域内选路</h3><p>也被称为Internal Gateway Protocol(内部网关协议)，它是一种域内路由协议，它的目的是为了解决域间路由协议的不足。</p><h4 id="routing-information-protocol路由信息协议"><a class="markdownIt-Anchor" href="#routing-information-protocol路由信息协议"></a> Routing Information Protocol(路由信息协议)</h4><p>RIP协议: 采用距离向量算法，对距离的衡量通过跳数。距离向量: 每隔30秒,通过响应报文在邻居间进行交换(也被称为RIP通告，通过UDP报文发送)。<br /><img src="rip.svg" alt="RIP" /><br />链路失败及恢复: 若180秒后没有收到通告，则认为邻居死机或链路中断，通过故障邻居的路由失败，新的公告发送给其他邻居，链路故障信息快速传播到整个网络。<br />毒性逆转用于防止乒乓循环(无限距离 = 16 跳)。当收到无限距离的包时会直接丢弃。</p><h4 id="open-shortest-path-first短路径优先"><a class="markdownIt-Anchor" href="#open-shortest-path-first短路径优先"></a> Open Shortest Path First(短路径优先)</h4><p>OSPF采用链路状态算法 ，路由器会分发LS分组，每个节点都具有拓扑图，路由计算使用dijkstra算法。<strong>注意: OSPF信息直接通过IP传输而不是TCP和UDP。</strong><br />OSPF的优点:</p><ul><li>安全: 所有OSPF 消息需要认证 (防止恶意入侵)</li><li>允许多个相同开销的路径(在RIP中只有一条路径)</li><li>对于每个链路, 有多个消费尺度用于不同的服务类型TOS</li><li>单播和多播综合支持: 多播OSPF(MOSPF)使用和OSPF同样的链路数据库</li></ul><p>在大区域内采用层次OSPF:<br /><img src="ospf.svg" alt="层次OSPF" /></p><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><p><img src="review1.svg" alt="Review" /><br /><img src="review2.svg" alt="Review" /><br /><img src="review3.svg" alt="Review" /><br /><img src="review4.svg" alt="Review" /><br /><img src="review5.svg" alt="Review" /><br /><img src="review6.svg" alt="Review" /><br /><img src="review7.svg" alt="Review" /><br /><img src="review8.svg" alt="Review" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Chapter 3</title>
    <link href="/2022/05/26/Computer-Network-Chapter-3/"/>
    <url>/2022/05/26/Computer-Network-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-3-transport-layer"><a class="markdownIt-Anchor" href="#chapter-3-transport-layer"></a> Chapter 3: Transport Layer</h1><h2 id="transport-layer-services传输层服务"><a class="markdownIt-Anchor" href="#transport-layer-services传输层服务"></a> Transport Layer Services(传输层服务)</h2><p>传输层服务: 为在两个不同的主机上运行的应用程序之间提供<strong>逻辑通信</strong>。<br />传输层协议运行在端系统，发送方将应用程序报文分成数据段传递给网络层，接收方将数据段重新组装成报文传递到应用层。<br />在Internet上传输层主要有2个协议:</p><ul><li>TCP: 提供的服务有:<ul><li>连接建立</li><li>可靠按序递交</li><li>拥塞控制</li><li>流量控制</li></ul></li><li>UDP: “尽力传递”，是IP的直接扩展，不提供其他服务。<br /><strong>说明</strong>: TCP和UDP均不能提供延迟保证和带宽保证</li></ul><h2 id="multiplexing-and-demultiplexing多路复用和多路分解"><a class="markdownIt-Anchor" href="#multiplexing-and-demultiplexing多路复用和多路分解"></a> Multiplexing and Demultiplexing(多路复用和多路分解)</h2><p>多路分解发生在接受主机上，传输层将接收到的数据段传递到正确的套接字即为多路分解。<br />多路复用发生在发送主机上，传输层从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层即为多路复用。<br />多路的意思即是将一个数据段分给不同应用层的socket，因为同时可能会存在多个socket但都被封装为了数据段的格式。<br /><img src="multiplexing_demultiplexing.png" alt="Multiplexing and Demultiplexing" /></p><h3 id="demultiplexing-working-principle多路分解工作原理"><a class="markdownIt-Anchor" href="#demultiplexing-working-principle多路分解工作原理"></a> Demultiplexing Working Principle(多路分解工作原理)</h3><p>主机从网络层收到IP数据报，每个数据报搬运一个数据段，每个数据段有源和目的端口号，主机用数据报中的IP地址和数据段的端口号来指明数据段属于哪个合适的套接字。</p><ul><li><p>无连接多路分解(UDP): UDP套接字由两个因素指定:(目的IP地址, 目的端口号)。当主机收到UDP数据段时，检查数据段中的目的端口号并且用端口号指示UDP数据段属于哪个套接字。<br /><strong>具有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字。</strong><br /><img src="udp_demultiplexing.svg" alt="UDP Demultiplexing" /><br />从上图可以看到，来自不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字。</p></li><li><p>面向连接的多路分解(TCP): TCP套接字由两个因素指定:(源IP地址, 源端口号, 目的IP地址, 目的端口号)。<strong>接收主机使用所有四个值将数据段定位到合适的套接字。</strong><br /><img src="tcp_demultiplexing.svg" alt="TCP Demultiplexing" /><br />与UDP不同的是，即便是目的IP地址和目的端口号相同，但源IP地址和源端口号不同的IP数据报需要指向不同的套接字。</p></li></ul><h2 id="connectionless-transport-udp无连接传输-udp"><a class="markdownIt-Anchor" href="#connectionless-transport-udp无连接传输-udp"></a> Connectionless Transport: UDP(无连接传输: UDP)</h2><p>“无修饰”,&quot;不加渲染的&quot;因特网传输层协议。&quot;尽最大努力&quot;服务, UDP数据段可能: 丢失，会传递失序的报文到应用程序。<br />UDP的特点:</p><ul><li>不需要建立连接 (减少延迟)</li><li>简单: 在发送者接受者之间不需要连接状态</li><li>很小的数据段首部(8B)</li><li>没有拥塞控制: UDP 能够用想象的快的速度传递</li></ul><h3 id="udp-segment-structureudp数据段结构"><a class="markdownIt-Anchor" href="#udp-segment-structureudp数据段结构"></a> UDP Segment Structure(UDP数据段结构)</h3><p><img src="udp.svg" alt="UDP Segment Structure" /><br /><strong>特别的:</strong> UDP数据段的首部长度为<strong>8B</strong>，而不是TCP的20B。并且UDP数据段的首部中长度属性为整个UDP数据段的长度。</p><h3 id="udp-checksumudp校验和"><a class="markdownIt-Anchor" href="#udp-checksumudp校验和"></a> UDP checksum(UDP校验和)</h3><p>目标: 检测传输的数据段的&quot;错误&quot;(如bit丢失,bit错误)<br />计算方法:</p><ul><li>发送方: 将整个数据段(此时校验和位还没有产生)看成16bit的序列，将整个数据段视为16bit的序列，依次相加，如果有溢出需要将溢出回卷到最低位，将最终结果取反得到校验和。</li><li>接收方: 使用与校验和的计算方法将整个数据段(包括校验和)按照16bit的序列全部加起来(中间出现溢出也需要回卷)，若全为1则通过了校验和检验，但仍可能出现错误，若不全为1则一定出现了错误。<br /><img src="checksum_example.svg" alt="example" /></li></ul><h2 id="principles-of-reliable-data-transfer可靠数据传输原理"><a class="markdownIt-Anchor" href="#principles-of-reliable-data-transfer可靠数据传输原理"></a> Principles of Reliable Data Transfer(可靠数据传输原理)</h2><h3 id="rdt发展过程"><a class="markdownIt-Anchor" href="#rdt发展过程"></a> RDT发展过程</h3><h4 id="rdt10"><a class="markdownIt-Anchor" href="#rdt10"></a> RDT1.0</h4><p>RDT1.0: 完全可靠信道上的可靠数据传输。<br />前提:</p><ul><li>完全可靠信道上不会出现bit错误</li><li>完全可靠信道上不会出现分组丢失<br />在完全可靠信道上进行可靠数据传输十分简单，发送方只需要将数据发送到下层信道，接收方从下层信道上获取数据即可完成可靠数据传输。</li></ul><h4 id="rdt20"><a class="markdownIt-Anchor" href="#rdt20"></a> RDT2.0</h4><p>但完全可靠信道几乎不可能出现，RDT2.0: 具有bit错误的信道，但不会出现分组丢失。在RDT2.0上实现可靠数据传输需要提供新的机制:</p><ul><li>差错检验</li><li>接收方反馈</li><li>发送方重传</li></ul><p>为实现上述机制，需要明确指出当接收方发现bit错误时的处理方法。以下为RDT2.0的有限自动机示意图:<br /><img src="rdt2.0.svg" alt="RDT2.0" /></p><ul><li>发送方: 将数据发送到下层信道，然后等待接收方反馈的ACK(正确收信息到)或NAK(错误收到信息)，若接收到ACK则继续发送下个包，若接收到NAK则重新发送上个包。</li><li>接收方: 从下层信道获取数据，通过UDP或TCP中的校验和来检测是否发生bit错误，若无发生bit错误则向发送方发送ACK并且继续接收，若发生bit错误则向发送方发送NAK然后重新接收数据直到收到正确数据。</li></ul><p>但RDT2.0存在致命缺陷，即ACK与NAK可能发生混淆即ACK或NAK在向发送方传输过程中也有可能出现bit错误，这个问题由RDT2.1来解决。</p><h4 id="rdt21"><a class="markdownIt-Anchor" href="#rdt21"></a> RDT2.1</h4><p>RDT2.1为处理ACK或NAK混淆问题，选择在收到ACK或NAK时同样进行校验和检验，若检验和正确则按RDT2.0的方式处理，若检验和错误则发生了bit错误，需要重新发送上一包。但这样会存在ACK发生了bit错误但发送方又重新发送了一次的情况，为避免重复，<strong>RDT2.1需要给每个分组加上序号</strong>，当接收方收到相同序号的数据段时会将其丢弃。<br /><img src="rdt2.1_sender.svg" alt="RDT2.1 Sender" /><br /><img src="rdt2.1_receiver.svg" alt="RDT2.1 Receiver" /><br /><strong>这里需要提出一个新的概念，停-等协议: 发送方发送一个报文，然后等待接受方的响应。</strong> 可以发现RDT2.0和RDT2.1均为停-等协议，由此可以引发以下思考。</p><p>仔细观察上方图中RDT2.1的sender和receiver可以看出，发送方附加的序号其实并非是数据包的唯一标识，而是只需要在0和1之间进行选择即可，这个特点是取决于停-等协议而产生的，只有确定了发送成功才会更新序号，因此只需要2个序号就可以完全满足识别的需求。同时由于停-等协议的特点，此时也不会出现后发出的包先被交付给上层的情况即数据包乱序问题。</p><h4 id="rdt22"><a class="markdownIt-Anchor" href="#rdt22"></a> RDT2.2</h4><p>RDT2.2的特点在于取消了RDT2.0提出的NAK机制，由于RDT2.1中给每个分组加上了序号，因此在停-等协议中，接收方只需要在ACK中回复收到的数据包的序号即可实现ACK和NAK的功能。例如: sender发送了序号为0的包，receiver正确收到了序号为0的包则回复为0的ACK，若收到的数据包出现了bit错误，则回复为1的ACK。而接收方如果收到了与发送序号相同的ACK则为发送成功，若收到了与发送序号不同的ACK则为发送失败，需要重新发送。<br /><img src="rdt2.2_sender.jpg" alt="RDT2.2 Sender" /><br /><img src="rdt2.2_receiver.jpg" alt="RDT2.2 Receiver" /></p><h4 id="rdt30"><a class="markdownIt-Anchor" href="#rdt30"></a> RDT3.0</h4><p>RDT1.0: 具有bit出错和分组丢失的信道。与RDT2.0解决出现bit错误一样，当出现分组丢失的可能后需要引入新的机制来保障数据的可靠传输。在RDT3.0中选择的是倒计时定时器机制来实现保障。<br />定时器的工作原理:<br /><img src="rdt3.0_1.svg" alt="Principle of RDT3.0" /><br /><img src="rdt3.0_2.svg" alt="Principle of RDT3.0" /><br />由上面两张图可以看出，引入定时器后情况会立马复杂很多，在上面展示了4种可能出现的情况，为便于理解需要全部掌握。</p><ol><li>没有发生任何错误: 这是最为简单的情况，当没有发生任何错误时，RDT3.0与RDT2.2工作过程是完全相同的。</li><li>发生了分组丢失: 发生了分组丢失后，对接收方其实没有任何影响，因此接收方不会返回ACK，当超过定时器规定的时间后发送方仍然没有收到ACK的话，发送方则会进行重传，并且重置定时器。</li><li>发生了ACK丢失: 此时接收方是已经收到了分组，并且向发送方发送了ACK(无论是要求发送方重传还是发送成功)，但是由于ACK的丢失，在到达定时器规定的时间后发送方会认为本次发送失败于是会重新发送该分组，并且重置定时器。在收到重新发送的分组后接收方会发现已经收到了该分组，则会丢弃分组并且回复ACK。</li><li>发生了ACK阻塞: 此时接收方是已经收到了分组，并且向发送方发送了ACK(无论是要求发送方重传还是发送成功)，但是由于ACK的阻塞，在到达定时器规定的时间后发送方仍然没有收到ACK会认为本次发送失败于是会重新发送该分组，并且重置定时器。在收到重新发送的分组后接收方会发现已经收到了该分组，则会丢弃分组并且回复ACK。</li></ol><p>其实我认为定时器机制下只有2位的序号是无法保障可靠数据传输的，特别是在ACK发生阻塞的情况下，极有可能发生出现了错误但没有纠正回来的情况。但是在课程中并没有做深入的讨论，我认为RDT的发展过程只是为我们实现可靠数据传输提供一个思路，并且在实际实现中TCP的可靠数据传输是比RDT3.0更复杂一些的，因此无需过于纠结本节的不完美之处。</p><h3 id="pipeline流水线技术"><a class="markdownIt-Anchor" href="#pipeline流水线技术"></a> Pipeline(流水线技术)</h3><p>RDT3.0的效率其实是非常低的，当数据在传播时和接收方进行处理和回复的过程中的时间是被浪费的同时还有停-等协议要求的定时器等待时间也被白白浪费了，因此出现了流水线的方法来提高传输效率，就跟HTTP中的流水线一样。<br />流水线: 发送方允许发送多个&quot;在路上的&quot;, 还没有确认的报文。但使用流水线技术对传输新增了以下要求:</p><ul><li>用于标志分组序号的范围应当增加，因为采用流水线技术后不再能通过2位的序号来标志分组的唯一性。</li><li>发送方/接收方需要有缓冲区，由于采用流水线方法后，分组存在不按序到达的情况，但上层要求按序递交因此需要将先到的后序分组缓冲起来等待前面分组到达后再行递交。<br /><img src="pipeline.svg" alt="流水线" /><br />这里出现了一个很重要的概念: <strong>发送窗口长度</strong>，即流水线操作中允许的最大未确认分组数量。从上面流水线运行示意图可以看到，利用率为相对于RDT3.0利用率的发送窗口倍，发送窗口越大利用率越大直到发送窗口对应分组传输时延大于一个RTT的时间。</li></ul><h4 id="go-back-n滑动窗口"><a class="markdownIt-Anchor" href="#go-back-n滑动窗口"></a> Go-Back-N(滑动窗口)</h4><p>在分组头中规定一个k位的序号。</p><ul><li>发送方: 发放方为最早未被确认的分组启动定时器，然后发送所有在发送窗口内的分组，直到发送窗口内的分组全部发送完毕。当收到ACK为n时，确认所有的报文直到(包含)序号n。若定时器超时，则重发窗口中的报文n及以上更高序号的报文(只有一个定时器记录最早的未被确认报文的发送时间)。</li></ul><p><img src="gbn.svg" alt="滑动窗口" /></p><ul><li>接收方: 发送累积ACK，假如收到分组与前面的分组之间有间隙，则不发送ack且丢弃失序分组(因此接收方无需缓冲区)。<br /><img src="gbn_example.svg" alt="example" /></li></ul><p><b>重要说明: GBN的窗口大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(k为序号位数)</b></p><h4 id="selective-repeat选择性重传"><a class="markdownIt-Anchor" href="#selective-repeat选择性重传"></a> Selective Repeat(选择性重传)</h4><p>在分组头中规定一个k位的序号。</p><ul><li>发送方: 发送方需要对每个没有确认的报文都要启动一个定时器(每个未被确认的报文都有一个定时器)，并只重发没有收到确认的分组。<br /><img src="sr.svg" alt="选择性重传" /></li><li>接收方: 接收方分别确认已经收到的分组，必要(收到分组并非按序)时，缓冲分组, 最后按序提交给上层。<br /><img src="sr_example.svg" alt="example" /></li></ul><p><b>重要说明: SR的窗口大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mn>2</mn><mi>k</mi></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{2^k}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3879199999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429199999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9270285714285713em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(k为序号位数)即发送窗口长度小于等于序号空间的一半(由两难选择决定)</b></p><p><img src="gbn_sr_example.svg" alt="example" /></p><h2 id="principles-of-congestion-control拥塞控制原理"><a class="markdownIt-Anchor" href="#principles-of-congestion-control拥塞控制原理"></a> Principles of Congestion Control(拥塞控制原理)</h2><p>太多源主机发送太多的数据，速度太快以至于网络来不及处理时，在网络核心区域(核心区域的路由器缓冲区溢出或排队)可能会出现分组丢失或高时延的情况。<br />拥塞产生的原因:</p><ul><li>在路由器的排队时延趋向于无穷大，因此分组的总时延趋向于无穷大导致定时器超时重传。</li><li>路由器的缓冲区有限，当大量的分组涌入时，路由器只能丢弃一些分组，因此会导致某些分组的丢失。</li></ul><p>拥塞控制的方法主要有2种:</p><ul><li>端到端拥塞控制</li><li>网络辅助的拥塞控制</li></ul><h3 id="端到端拥塞控制"><a class="markdownIt-Anchor" href="#端到端拥塞控制"></a> 端到端拥塞控制</h3><p>没有从网络中得到明确的反馈，是从端系统观察到的丢失和延迟推断出拥塞。具体实现会在下面的TCP拥塞控制中提到。</p><h3 id="网络辅助的拥塞控制"><a class="markdownIt-Anchor" href="#网络辅助的拥塞控制"></a> 网络辅助的拥塞控制</h3><p>由路由器给端系统提供反馈，从而控制拥塞。</p><ul><li>单bit指示拥塞 (SNA, DECbit, TCP/IP ECN, ATM)</li><li>指明发送者应该发送的速率</li></ul><h2 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h2><p>TCP是一个最经典的传输层协议具有以下特点:</p><ul><li>点到点: TCP在网络层的支持下实现点到点的传输，只存在一个发送方一个接收方。</li><li>面向连接: TCP要求发送方和接收方在数据交换前交换控制信息。</li><li>提供可靠的按序递交传输服务: 使用TCP作为传输层协议可以确保数据的可靠传输和按序向上层递交。</li><li>流水线服务: TCP提供流水线服务，提供了较高的效率，发送窗口大小由流量控制和拥塞控制共同决定。</li><li>全双工数据: 同一个连接上可以双向传输数据。</li><li>流量控制: TCP会控制发送方发出的数据包的速率，以保证不会淹没接收方。</li><li>拥塞控制: TCP会根据网络状况来控制发送方的窗口大小，避免无意义重传。</li></ul><h3 id="tcp-segment-structuretcp数据段结构"><a class="markdownIt-Anchor" href="#tcp-segment-structuretcp数据段结构"></a> TCP Segment Structure(TCP数据段结构)</h3><p><img src="tcp_segment.svg" alt="TCP数据段" /><br />TCP的典型首部为20Bytes(没有可变长的选项)。</p><ul><li>源端口号和目的端口号: 为TCP递交上层寻找socket提供帮助。</li><li>序号和确认号(seq and ack): 为TCP的可靠数据传输提供帮助。</li><li>标志位: 为TCP的控制信息提供帮助，包括建立连接等。</li><li>接收窗口: 为TCP的流量控制提供帮助。</li><li>校验和: 为TCP的可靠数据传输提供帮助。</li><li>紧急数据指针: 很少用。</li><li>数据: 承载应用层数据。</li></ul><h3 id="the-tcp-connectiontcp连接"><a class="markdownIt-Anchor" href="#the-tcp-connectiontcp连接"></a> The TCP Connection(TCP连接)</h3><p>TCP要求在发送方和接收方进行数据交换前需要交换控制信息，即约定seq等控制信号量。</p><h4 id="三次握手建立连接"><a class="markdownIt-Anchor" href="#三次握手建立连接"></a> 三次握手建立连接</h4><ol><li>发送方发送一个特殊的TCP数据段称为SYN包(将标准TCP数据段的首部中SYN位置为1，同时需要将<strong>seq置为自己的开始序号</strong>)，指明要建立连接，接收方接收到后，发送ACK包，指明要建立连接。</li><li>当接收方收到SYN包后，需要为TCP连接分配缓存并计算自己的开始序号，当准备完成后向发送方发送SYNACK包(SYN为1，<strong>seq为接收方的开始序号</strong>，ACK号为<strong>发送方的seq+1</strong>)，指明要建立连接。</li><li>接收方收到SYNACK包，也需要为连接分配缓存，此时连接已经建立因此发送数据段的<strong>SYN位为0</strong>，但为了回应对SYNACK的正确收到，ACK为<strong>接收方的seq+1</strong>。</li></ol><p>值得说明的是: 在第三次握手过程时，发送方可以在数据段的数据部分加上需要传输的数据了，但在前两次握手中数据部分均为空。<br /><img src="tcp_connection.svg" alt="TCP建立连接" /></p><h4 id="四次挥手断开连接"><a class="markdownIt-Anchor" href="#四次挥手断开连接"></a> 四次挥手断开连接</h4><p>TCP连接上的<strong>任何一方</strong>均能终止该连接。</p><ol><li>发起断开连接的一方发送FIN包(数据段首部中FIN位为1)，指明要断开连接。</li><li>收到FIN包后，需要返回ACK确认收到FIN包，指明要断开连接，收到FIN的ACK后，发起断开连接的一方进入等待另一方FIN包的状态。</li><li>接受连接断开的一方发送FIN包，指明要断开连接。</li><li>另一方发送FIN的ACK包，指明要断开连接，此时双方资源都将释放。</li></ol><h3 id="tcps-reliable-data-transporttcp的可靠数据传输"><a class="markdownIt-Anchor" href="#tcps-reliable-data-transporttcp的可靠数据传输"></a> TCP’s Reliable Data Transport(TCP的可靠数据传输)</h3><p>TCP的可靠数据传输仍然是通过<strong>序号+ACK+定时器</strong>机制来实现的，但在具体细节上与RDT3.0有较大的不同。同时TCP采用了流水线技术，相对于RDT3.0的效率大大提高，因此也扩展了序号位的大小，但又不是完全采用了流水线的Go-Back-N和Selective Repeat策略，而是有自己的快速重传方案，这里需要注意。</p><h4 id="tcp的重传机制"><a class="markdownIt-Anchor" href="#tcp的重传机制"></a> TCP的重传机制</h4><b>序号:数据段中第一个字节在数据流中的位置编号。<br>确认号:期望从另外一边收到的下一个字节的序号。  </b>与RDT3.0不同之处: - RDT3.0: ACK号为正确收到的数据段序号。序号为一段循环的数字。- TCP: ACK号为下一次期望收到的数据段序号。序号为从某位开始的递增数字。<p>TCP规范没有明确规定如何处理失序的数据段, 由编程人员处理。<br /><img src="tcp_ack.svg" alt="TCP交换过程" /><br /><strong>ACK的计算方法: 收到数据段的seq+收到数据段数据部分的长度。</strong><br /><img src="tcp_example.svg" alt="example" /></p><p>上面是TCP通过序号+ACK实现重传的方式，接下来是TCP使用定时器机制来避免分组丢失导致的数据丢失问题。</p><h4 id="tcp的定时器设定"><a class="markdownIt-Anchor" href="#tcp的定时器设定"></a> TCP的定时器设定</h4><p>设置TCP定时器的要求和问题:</p><ul><li>比RTT长，但RTT变化无法确定。</li><li>设置时间太短: 不成熟的超时会导致不必要的重传。</li><li>设置时间太长: 对数据段丢失响应慢。</li></ul><p>因此需要估计RTT来确定定时器的超时时间。<br /><strong>样本RTT(SampleRTT): 测量从报文段发送到收到确认的时间。</strong><br /><strong>样本RTT均值计算:</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>α</mi><mo>∗</mo><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">EstimatedRTT = (1 - \alpha) * EstimatedRTT + \alpha * SampleRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p><strong>典型的:</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span></span></span></span><br /><img src="rtt_example.svg" alt="example" /></p><p>再通过EstimtedRTT 加上&quot;安全余量&quot;来设置定时器的超时时间。<br /><strong>安全余量的计算:</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mi>β</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>−</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">DevRTT = (1 - \beta) * DevRTT + \beta * |SampleRTT - EstimatedRTT|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">∣</span></span></span></span></span></p><p><strong>典型的:</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>β</mi><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">\beta = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">5</span></span></span></span></p><p>最后<strong>算出定时器的超时时间:</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>E</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><mn>4</mn><mo>∗</mo><mi>D</mi><mi>e</mi><mi>v</mi><mi>R</mi><mi>T</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">TimeoutInterval = EstimatedRTT + 4 * DevRTT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p><h4 id="tcp的流水线与定时器机制"><a class="markdownIt-Anchor" href="#tcp的流水线与定时器机制"></a> TCP的流水线与定时器机制</h4><p><strong>TCP只有一个定时器。</strong><br />用序号创造一个数据段，如果没有启动定时器，则启动定时器 (定时器是最早没有被确认的数据段发送时启动的)TCP的ACK仍然为累计确认，即当收到ACK为n时，确认所有的报文直到(包含)序号n。<br />TCP中ACK的产生:<br /><img src="tcp_ack_produce.svg" alt="ACK产生" /><br />在上图可以看出，当只有期待序号数据段到达时，TCP不会要求接收方立马发生ACK而是会稍微延迟发送ACK的时间，这样会减少需要ACK的数量，但在计算时不需要考虑。<br />同时当收到乱序数据段时，接收方会发送期望的ACK，这样有助于快速重传的触发。</p><p>当发送方收到确认了还未确认的数据段ACK时，定时器会被重置。</p><p>TCP中重传的产生:</p><ul><li>超时重传: 重发导致超时的数据段，而不需要重复所有未确认的数据段，然后重启定时器。</li><li>快速重传: 快速重传是为了避免超时周期往往太长导致的浪费时间。如果发送方收到3个对同样报文段的确认，则发送方认为该报文段据已经丢失，然后重传该报文段。</li></ul><p><img src="tcp_retransmit.svg" alt="example" /></p><h3 id="tcps-flow-controltcp的流量控制"><a class="markdownIt-Anchor" href="#tcps-flow-controltcp的流量控制"></a> TCP’s Flow Control(TCP的流量控制)</h3><p>接收方控制发送方，使发送方不会太快太多发送数据以致淹没接收方缓冲区。<br />实现方法: 接收方使用TCP头部消息中rwnd字段(即接收窗口单位为Byte或报文段数量)来通知发送方剩余缓冲区大小。<br />发送方限制已发送但是未被确认的数据量不能超过rwnd的值来保证接受缓冲区不会被淹没。</p><h3 id="tcps-congestion-controltcp的拥塞控制"><a class="markdownIt-Anchor" href="#tcps-congestion-controltcp的拥塞控制"></a> TCP’s Congestion Control(TCP的拥塞控制)</h3><p>cwnd为拥塞窗口，单位为Byte或报文段数量。<br />MSS为报文段的最大长度。<br />TCP的拥塞控制方法:</p><ul><li>加性增，乘性减: 每个RTT内cwnd增加一个MSS直到丢包，丢包后cwnd减半。</li><li>慢启动: 连接开始的时候, 窗口大小 = 1 MSS，然后以2的指数方式增加速率直到发生分组丢失。</li></ul><p>对拥塞的反应:</p><ul><li>出现快速重传时(连续3个相同的ACK): 窗口大小减半+3，然后以线性增长。</li><li>超时时: TCP进入慢启动状态并且阈值为发送丢失前的一半(向下取整)。从MSS为1开始以2的指数方式增加，到达阈值后以线性增长。指数增长阶段称为<strong>慢启动阶段</strong>，线性增长阶段称为<strong>拥塞避免阶段</strong>。</li></ul><p><img src="tcp_congestion_control.svg" alt="example" /></p><h3 id="tcps-fairnesstcp的公平性"><a class="markdownIt-Anchor" href="#tcps-fairnesstcp的公平性"></a> TCP’s Fairness(TCP的公平性)</h3><p>公平目标: 如果K个TCP 共享带宽为R的瓶颈链路每个应该有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>R</mi><mi>K</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{R}{K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的平均速率。<br /><img src="tcp_fairness.svg" alt="TCP公平性" /></p><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><p>传输层作为计算机网络中十分重要的一层，是承接从网络层到应用层的数据传输的关键层。他在不稳定信道的网络层上工作，却能向应用层提供可靠的、按序递交的服务(TCP)，也能为应用层提供快速的、尽可能快的服务(UDP)。在学习传输层中，最重要的我认为是如何在不稳定信道上建立可靠数据传输的思想: 序号+ACK+定时器机制，这种思维是本章最重要的部分。在复习过程中应该着重理解从RDT1.0到RDT3.0的发展做出的改变和TCP在实际运用中的实现，来保障思维的学习。<br /><img src="review1.svg" alt="Review" /><br /><img src="review2.svg" alt="Review" /><br /><img src="review3.svg" alt="Review" /><br /><img src="review4.svg" alt="Review" /><br /><img src="review5.svg" alt="Review" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Chapter 2</title>
    <link href="/2022/05/25/Computer-Network-Chapter-2/"/>
    <url>/2022/05/25/Computer-Network-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-2-application-layer"><a class="markdownIt-Anchor" href="#chapter-2-application-layer"></a> Chapter 2: Application Layer</h1><h2 id="principles-of-network-application"><a class="markdownIt-Anchor" href="#principles-of-network-application"></a> Principles of Network Application</h2><h3 id="network-application-architectures网络应用程序体系结构"><a class="markdownIt-Anchor" href="#network-application-architectures网络应用程序体系结构"></a> Network Application architectures(网络应用程序体系结构)</h3><p>网络应用程序体系结构可以大致的分为3种结构:</p><ul><li>C/S架构(Client/Server):<ul><li>Client(客户端): 同服务器端通信，需要间断的同服务器连接，可以拥有动态IP地址，客户机相互之间不直接通信。</li><li>Server(服务器): 总是打开的主机，具有固定的、众所周知的IP地址，主机群集常被用于创建强大的虚拟服务器。</li></ul></li><li>P2P架构(Peer to Peer): 没有总是打开的服务器，任意一对主机直接相互通信，对等方向其他对等方提供服务，同时接受其他对等方的服务。具有高扩展性和难以管理的特点。</li><li>C/S与P2P混合架构: 既有服务器也存在不同用户的P2P直接通信。如即时讯息两个聊天用户之间是P2P，上线注册、查询通过服务器。</li></ul><h3 id="process进程"><a class="markdownIt-Anchor" href="#process进程"></a> Process(进程)</h3><p>进程：运行在端系统中的程序，同一主机上的两个进程通过内部进程通信机制进行通信，不同主机上的进程通过交换报文相互通信。<br />进程寻址: 每个主机上的进程具有唯一的端口号，因此可以通过端口号来识别交换报文的进程。</p><table><thead><tr><th style="text-align:center">常见应用程序</th><th style="text-align:center">端口号</th></tr></thead><tbody><tr><td style="text-align:center">Web服务(HTTP)</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">邮件服务(SMTP)</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">文件传输(FTP)</td><td style="text-align:center">21(认证、控制)<br>20(传输)</td></tr></tbody></table><h3 id="transport-services-provided-by-the-internetinternet提供的传输服务"><a class="markdownIt-Anchor" href="#transport-services-provided-by-the-internetinternet提供的传输服务"></a> Transport Services Provided by the Internet(Internet提供的传输服务)</h3><p>Internet为应用程序提供了2个传输层协议: TCP和UDP。</p><ul><li>TCP:<ol><li>面向连接的服务: 在客户机程序和服务器程序之间必须建立连接。</li><li>可靠的传输服务: 通过TCP进行传输能够保障无差错、按照设当顺序交付所有发送的数据。</li><li>流量控制: 发送方不会淹没接收方。</li><li>拥塞控制: 当网络出现拥塞时会抑制发送。</li></ol></li><li>UDP: 无需连接，尽力发送数据，但不保证接收到数据。也无流量控制和拥塞控制。</li></ul><h2 id="the-web-and-httpweb应用和http协议"><a class="markdownIt-Anchor" href="#the-web-and-httpweb应用和http协议"></a> The Web and HTTP(Web应用和HTTP协议)</h2><p>网页（Web页，或称文档）由许多对象组成。 对象就是文件，可以是HTML文件, JPEG图像, Java applet, 音频文件等。<strong>每个对象被一个URL(统一资源定位符)寻址</strong>，因此在获取时一次请求只能获取一个对象。<br />HTTP: hypertext transfer protocol(超文本传输协议)，目前有两种协议：HTTP1.0和HTTP1.1。<br />HTTP共有2种报文: 请求报文和响应报文。</p><ul><li>请求报文<br /><img src="request.svg" alt="HTTP请求报文格式" /><br />请求报文的第一行为请求行，请求行与请求体之间为可变长的首部行和一个空行。首部行为key:value格式并通过cr+lf进行分隔。请求体内则为表单或其他需要上传的数据。<br />请求行内容包括请求方法、请求资源路径(URL)、HTTP版本号: 路径和版本号由请求方情况确定，这里只介绍需要掌握的不同请求方法之间的区别:<ul><li>HTTP/1.0<ul><li>GET: 请求体为空，服务器的响应报文会包含请求对象(正常响应)或错误状态码。</li><li>POST: 一般会将表单等需要上传数据放在请求体中，服务器会做出响应回复响应报文。</li><li>HEAD: 服务器收到请求时，用HTTP报文进行响应，但不返回请求对象</li></ul></li><li>HTTP/1.1<ul><li>GET: 与HTTP/1.0相同</li><li>POST: 与HTTP/1.0相同</li><li>HEAD: 与HTTP/1.0相同</li><li>PUT: 文件在实体主体中被上载到URL字段指定的路径</li><li>DELETE: 删除URL字段指定的文件</li></ul></li></ul></li><li>响应报文<br /><img src="reply.jpg" alt="HTTP相应报文格式" /><br />响应报文与请求报文几乎相同，唯一的区别只在于第一行，请求报文第一行为请求行，响应报文第一行为状态行。<br />状态行内容包括版本、状态编码和对状态编码的简单解释短语。常见的状态编码含义可以在这里查询: <a href="http://tools.jb51.net/table/http_status_code">状态码查询</a></li></ul><h3 id="none-persistent-connection非持久连接"><a class="markdownIt-Anchor" href="#none-persistent-connection非持久连接"></a> None-Persistent Connection(非持久连接)</h3><p>一次TCP连接只能传输一个对象，如果要传输多个对象，需要创建多个TCP连接。<br /><strong>RTT(往返时间): 1个小分组从客户主机到服务器再到客户主机所花费的时间(来回需要的传播时间)。</strong><br />一次HTTP请求和回复的过程: TCP三次握手，但在第三次握手的同时，客户主机就可以发送一个HTTP请求报文，服务器在收到请求报文后，会返回一个HTTP响应报文，TCP连接断开，如果需要请求其他对象则需要重新建立连接。<br /><img src="http_connection.png" alt="HTTP一次请求与回复过程" /></p><h3 id="persistent-connection持久连接"><a class="markdownIt-Anchor" href="#persistent-connection持久连接"></a> Persistent Connection(持久连接)</h3><p>服务器发送响应消息后保持连接而不会结束TCP连接，同客户/服务器的后续HTTP消息继续在该连接上传送。<br />在使用同一条连接的方式上有使用流水线方法和不使用流水线方法两种。</p><ul><li>不使用流水线的持久HTTP连接: 不使用流水线当有多个请求需要发送时，仍然是要先建立连接，等待服务器响应，在响应完成后通过已经建立好的连接重新发送请求。</li><li>使用流水线的持久HTTP连接: 而使用流水线的方式时，如果有多个请求需要发送，无需等待第一个请求响应到达才能发送下一请求，而是直接同时发送所有需要的请求，然后等待服务器的响应。</li></ul><p><img src="problem_8.svg" alt="example" /></p><p><b>Tip: </b><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mn>2</mn></msub><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">RTT_1+RTT_2+···+RTT_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><b>为DNS请求时间</b></p><h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h3><p>HTTP协议是一种无状态协议，是没有维护客户先前的状态信息的，但在Web应用中经常会需要得知用户前段时间的状态Cookie便是一种跟踪用户的技术。<br />Cookie的实现实际非常简单，当用户第一次发送请求时，服务器会生成一个Cookie并保存到数据库中，在响应报文中附加上Cookie，当下次用户发送请求时，需要将Cookie附加在请求报文内，这样服务器就能够获取到用户的信息了。因此Cookie追踪的是主机而不能追踪特定的人。</p><h3 id="web缓存"><a class="markdownIt-Anchor" href="#web缓存"></a> Web缓存</h3><p>Web缓存为一个代理服务器，在一个局域网下或者一个机构内网中有专门的服务器来处理当前子网下的所有HTTP请求。使用Web缓存需要配置浏览器或者其他发起HTTP请求工具，将HTTP请求重定向到Web缓存服务器。<br /><img src="web_cache.svg" alt="Web Cache" /><br />Web缓存的工作原理: 当客户需要对象时，向Web缓存发出请求报文，</p><ul><li>请求对象在Web缓存中存在且为最新版本: 由Web缓存直接返回对象。</li><li>请求对象在Web缓存存在但不是最新版本: 由Web缓存进行代请求，得到响应后返回对象。</li><li>请求对象不在Web缓存中: 由Web缓存进行代请求，得到响应后返回对象。</li></ul><p><strong>说明:</strong> 判断Web缓存中对象是否为最新版本采用条件GET方法，即在请求报文首部行中增加<code>If-modified-since: &lt;date&gt;</code>，如果没有修改则返回304响应码，如果有修改则返回最新对象。Web缓存会定期进行条件GET操作。<strong>特别的</strong>: 一般响应报文中的<code>Data:</code>属性并非是最后修改时间，而是响应报文的生成时间。</p><p>命中率: 请求对象在Web缓存中能直接返回的概率。<br />Web缓存的优点: <strong>减少对客户机请求的响应时间</strong>、<strong>减少内部网络与接入链路上的通信量</strong>、<strong>能从整体上大大降低因特网上的Web流量</strong>。</p><p><img src="problem_9.svg" alt="example" /></p><h2 id="file-transfer-protocol文件传输协议"><a class="markdownIt-Anchor" href="#file-transfer-protocol文件传输协议"></a> File Transfer Protocol(文件传输协议)</h2><p>FTP协议的主要场景为传输文件到远程主机或从远程主机下载文件。<br />FTP过程:</p><ol><li>FTP客户首先发起建立1个与FTP服务器端口号21之间的TCP控制连接, 指定TCP作为传输层协议。</li><li>客户在建立的控制连接上获得身份认证。</li><li>客户在建立的控制连接上发送命令来浏览远程主机的目录。</li><li>当服务器接收到1个文件传输命令时, 在服务器端口号20创建1个与客户的TCP数据连接。</li><li>1个文件传输后,服务器结束这个TCP数据连接。<strong>这个TCP连接指端口20的那个传输文件TCP连接</strong>。<br /><img src="ftp.png" alt="FTP" /><br /><img src="ftp_order.svg" alt="FTP order" /></li></ol><h2 id="electronic-mail电子邮件"><a class="markdownIt-Anchor" href="#electronic-mail电子邮件"></a> Electronic mail(电子邮件)</h2><p>电子邮件在Internet中的传输可以分为3个主要组成部分:</p><ul><li>Mail Server: 实现邮件的存储和收发功能的服务器。</li><li>SMTP: 邮件服务器之间的传输协议。</li><li>User Agent: 用户代理，用于用户从邮件服务器查看邮件。</li></ul><h3 id="simple-mail-transfer-protocol简单邮件传输协议"><a class="markdownIt-Anchor" href="#simple-mail-transfer-protocol简单邮件传输协议"></a> Simple Mail Transfer Protocol(简单邮件传输协议)</h3><p><img src="smtp.svg" alt="SMTP约定邮件格式" /><br />SMTP协议的传输过程:</p><ol><li>握手</li><li>邮件消息的传输</li><li>结束<br />SMTP的总结:</li></ol><ul><li>SMTP使用TCP作为传输层协议，并且使用持久连接。</li><li>SMTP 要求邮件消息(header &amp; body)必须是7-bit ASCII</li><li>SMTP服务器使用CRLF.CRLF 来判断邮件消息的结束。<br />SMTP与HTTP的区别:</li></ul><table><thead><tr><th style="text-align:center">HTTP</th><th style="text-align:center">SMTP</th></tr></thead><tbody><tr><td style="text-align:center">拉协议</td><td style="text-align:center">推协议</td></tr><tr><td style="text-align:center">对象在响应报文体中存放且每个报文只有一个对象</td><td style="text-align:center">邮件内的多个对象在同一邮件的多目部分发送</td></tr><tr><td style="text-align:center">命令、状态码、为ASCII码</td><td style="text-align:center">邮件消息均为7-bit ASCII码</td></tr></tbody></table><h3 id="post-office-protocol邮局协议-and-internet-message-access-protocol因特网邮件访问协议"><a class="markdownIt-Anchor" href="#post-office-protocol邮局协议-and-internet-message-access-protocol因特网邮件访问协议"></a> Post Office Protocol(邮局协议) and Internet Message Access Protocol(因特网邮件访问协议)</h3><p>POP3和IMAP都是用户代理与邮件服务器之间的协议，用于验证用户身份、读取邮件、管理邮件和编辑并发送邮件。大致可以分为身份认证阶段和传输阶段，实际上十分的复杂并且两者之间也有很多不同的规则。但是需要知道的是POP3和IMAP是用户通过用户代理来访问邮件服务器的协议，而不是邮件服务器之间的邮件传输协议即可。</p><h2 id="domain-name-system域名系统"><a class="markdownIt-Anchor" href="#domain-name-system域名系统"></a> Domain Name System(域名系统)</h2><p>通过DNS可以实现:</p><ul><li>主机名与IP地址的映射。</li><li>主机名与别名的映射。</li><li>域名与该域权威名字服务器的主机名的映射。</li><li>邮件服务器主机别名与邮件服务器主机名的映射。<br />其中第三和第四稍微有点绕，后面将展示如何通过DNS进行域名的访问和邮件服务器的访问。</li></ul><h3 id="dns-rrdns资源记录"><a class="markdownIt-Anchor" href="#dns-rrdns资源记录"></a> DNS RR(DNS资源记录)</h3><p>从上面DNS实现的功能可以看出至少需要能够表示4种不同的映射关系，在这里RR是通过其中的type字段来表示不同的映射关系。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>R</mi><mo>:</mo><mo stretchy="false">(</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>t</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">RR: (name, value, type, ttl)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p><p>type:</p><ul><li>A: name = 主机名, value = IP地址</li><li>CNAME: name = 别名, value = 主机名</li><li>MX: name = 邮件服务器主机别名, value = 邮件服务器主机名</li><li>NS: name = 域名, value = 域名服务器主机名<br />当已知主机名时，只需要查询type为A的记录即可得到该主机的IP地址。<br />当已知主机别名时，需要先查询type为CNAME的记录获取主机名，再查询type为A的记录才能得到该主机的IP地址。<br />当已知邮件服务器主机别名时，需要先查询type为MX的记录获取邮件服务器主机名，再通过查询type为A的记录才能得到该邮件服务器的IP地址。<br />当已知域名时，需要先查询type为NS的记录获取域名服务器主机名，再通过查询type为A的记录才能得到该域名服务器的IP地址。</li></ul><h3 id="dns-protocoldns协议"><a class="markdownIt-Anchor" href="#dns-protocoldns协议"></a> DNS Protocol(DNS协议)</h3><p>DNS协议 : 查询报文与应答报文 , 但具有同样的报文格式<br /><img src="dns.svg" alt="DNS Message" /></p><ul><li>标识符: 16位，查询和应答报文使用相同的标识符</li><li>标志:有若干个标志构成，分别标识不同的功能<ul><li>查询/应答－0/ 1</li><li>查询希望是/非递归查询－1/0</li><li>应答可/否获得(支持)递归查询－1/0</li><li>应答是/否来自权威名字服务器－1/ 0</li></ul></li><li>问题部分: 查询的name和type</li><li>回答部分: 对于查询,应答的资源记录。可以多个资源记录，因为可以有多个IP地址</li><li>权威部分: 权威名字服务器的其他资源记录</li><li>附加信息部分: 其他有帮助的记录</li></ul><h3 id="dns-architecturesdns层次结构"><a class="markdownIt-Anchor" href="#dns-architecturesdns层次结构"></a> DNS Architectures（DNS层次结构）</h3><p><img src="dns_architectures.svg" alt="DNS Architecture" /></p><ul><li>根名字服务器: 负责记录顶级域名服务器的信息。</li><li>顶级域服务器:负责顶级域名 com, org, net, edu, etc等, 和所有国家的顶级域名 uk, fr, ca, jp等。</li><li>权威DNS服务器: 在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录。</li></ul><p>还有不属于层次结构的DNS服务器: 本地DNS服务器。每个ISP（如居民区ISP、公司、大学）都有一个本地DNS，也叫默认服务器。当主机发出DNS请求时，该请求被发往本地DNS服务器。起着代理的作用，转发请求到层次结构中。</p><h3 id="dns-querydns查询"><a class="markdownIt-Anchor" href="#dns-querydns查询"></a> DNS Query(DNS查询)</h3><ul><li>递归查询: 名字解析的负担交给被查询的名字服务器。<br /><img src="dns_recursive.png" alt="DNS recursive query" /></li><li>迭代查询: 被查询的名字服务器 回复可以被查询的名字服务器的IP地址，然后重新去回复的名字服务器查询。<br /><img src="dns_iteration.png" alt="DNS iterative query" /></li></ul><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><p><img src="review.svg" alt="Review" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Chapter 1</title>
    <link href="/2022/05/24/Computer-Network-Chapter-1/"/>
    <url>/2022/05/24/Computer-Network-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-1-computer-network-and-the-internet"><a class="markdownIt-Anchor" href="#chapter-1-computer-network-and-the-internet"></a> Chapter 1: Computer Network and the Internet</h1><h2 id="concept概念"><a class="markdownIt-Anchor" href="#concept概念"></a> Concept(概念)</h2><p>首先需要介绍本章会用到的一些概念:</p><ul><li>计算机网络: 两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。这很教科书，但也很精炼。</li><li>Internet: 这个概念很泛化，无法给出一个具体的定义，但我们可以通过其特征来描述。<ol><li>从组成结构来看，Internet可以分为网络核心和网络边缘两部分，网络边缘主要是各种主机host和端系统end-system等设备，网络核心则是大量的路由器、交换机以及通信链路。</li><li>从具体构成来看，Internet是由网络构成的网络，一个个主机连接在一起形成局域网，而所有的局域网连接起来组成一个大的网络，这便是Internet。</li></ol></li><li>协议:<ol><li>定义了两个或多个通信实体间所交换<strong>报文的格式</strong>和<strong>次序</strong>，以及在<strong>报文发送和/或接收或者其他事件方面所采取的行动（响应）</strong>。</li><li>协议的<strong>基本要素</strong>: <strong>语法</strong>、<strong>语义</strong>和<strong>同步</strong>。</li></ol></li></ul><h2 id="the-network-edge网络边缘"><a class="markdownIt-Anchor" href="#the-network-edge网络边缘"></a> The Network Edge(网络边缘)</h2><p>网络边缘部分由主机/端系统组成，主机/端系统在服务角色方面分别有客户和服务器两种身份可以选择。</p><h3 id="access-network接入网络"><a class="markdownIt-Anchor" href="#access-network接入网络"></a> Access Network(接入网络)</h3><p>接入网络的分类:</p><ul><li>住宅接入网络: 拨号线路上使用modem调制解调，理论最高值为56Kbps,不能同时网上冲浪和拨打电话。(电话拨号上网)</li><li>机构接入网络: 即局域网，在局域网下有自己的网络结构，但作为整个网络接入Internet。传输速率一般为10Mbps、100Mbps、1Gbps、10Gbps。</li><li>无线接入网络: 通过AP(access point)和STA(station)来实现无线网络的接入。<ol><li>无线局域网(wireless LANs): 通过无线信道来传输数据，典型为WiFi。</li><li>广域无线接入网: 由ISP(Internet Service Provider)提供的无线接入网，典型为3G、4G。</li></ol></li></ul><h3 id="physical-media物理介质"><a class="markdownIt-Anchor" href="#physical-media物理介质"></a> Physical Media(物理介质)</h3><p>物理介质的分类:</p><ul><li>双绞线(网线): 两根彼此绝缘、相互缠绕成螺旋状的铜线。缠绕的目的是减少电磁干扰，提高传输质量。</li><li>同轴电缆(铜线): 两根彼此绝缘的同心导体，双向传输。</li><li>光纤线缆: 光纤传导光脉冲, 每个光脉冲代表1位，高速传输:高速点对点传输 (可达数十或数百 Gbps)误码率，中继到更远传输距离;，防止电磁干扰，难以被分光窃听。</li><li>无线电磁波: 以电磁频谱承载信号，没有物理连线，双向。<ol><li>地面微波: 45 Mbps 信道。</li><li>局域无线通道: WiFi 11Mbps, 54Mbps。</li><li>广域无线通道: GPRS,CDMA，3G: hundreds of kbps。</li><li>卫星通信: 高达数百Mbps信道。</li></ol></li></ul><h2 id="the-network-core网络核心"><a class="markdownIt-Anchor" href="#the-network-core网络核心"></a> The Network Core(网络核心)</h2><h3 id="packet-switching分组交换"><a class="markdownIt-Anchor" href="#packet-switching分组交换"></a> Packet Switching(分组交换)</h3><p>每个端到端的数据流被划分成分组，每个分组通过网络来离散地发送。</p><p>优点:</p><ul><li>所有分组共享网络资源</li><li>每个分组使用全部链路带宽</li><li>资源按需使用</li></ul><h3 id="circuit-switching电路交换"><a class="markdownIt-Anchor" href="#circuit-switching电路交换"></a> Circuit Switching(电路交换)</h3><p>每次会话预留沿其路径（线路）所需的独占资源－－电话网，实现方式: 将网络资源(带宽)分片。每个分片分配到会话，分片没有被会话使用的情况下，分片空载。但电路交换提供电路级性能保障，传输准确性高。建立一个专门的端到端线路即每个链路上预留一个线路。</p><ol><li>frequency division(频分)</li><li>time division(时分)<br /><img src="division.svg" alt="frequency division and time division" /></li></ol><h3 id="电路交换与分组交换的比较"><a class="markdownIt-Anchor" href="#电路交换与分组交换的比较"></a> 电路交换与分组交换的比较</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">电路交换</th><th style="text-align:center">分组交换</th></tr></thead><tbody><tr><td style="text-align:center">是否需要预留线路</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否需要创建链路</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否需要分片</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否可以共享资源</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">是否提供可靠数据传输</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">是否提供带宽保障</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr></tbody></table><h2 id="delay-loss-and-troughput-in-packet-switched-networks分组交换网络中的延迟和丢失"><a class="markdownIt-Anchor" href="#delay-loss-and-troughput-in-packet-switched-networks分组交换网络中的延迟和丢失"></a> Delay, Loss and Troughput in Packet-Switched Networks(分组交换网络中的延迟和丢失)</h2><h3 id="delay时延"><a class="markdownIt-Anchor" href="#delay时延"></a> Delay(时延)</h3><p>分组延迟:</p><ul><li>nodal processing delay(节点处理延时): 节点处理到达数据的时间。量级: 微秒级。<ol><li>检查错误位</li><li>选择输出链路</li></ol></li><li>queueing delay(排队时延): 分组处理完成后等待到输出链路上的时间。量级: 取决于当前的拥塞程度。</li><li>transmission delay(传输延时): 分组在从输出链路上开始输出到输出结束的时间。量级: 取决于分组长度和当前节点传输速率。</li><li>propagation delay(传播时延): 分组在物理介质上传播的时间。量级: 物理介质的类型和物理链路的长度。</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><msub><mi>d</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>a</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{nodal} = d_{processing} + d_{queueing} + d_{transmission} + d_{propagation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><h4 id="detail-of-queueing-delay"><a class="markdownIt-Anchor" href="#detail-of-queueing-delay"></a> Detail of Queueing Delay</h4><p>Asuming: R=链路传输速率 (bps)，L=分组长度 (bits)，a=平均分组到达率，<br />Then: traffic intensity(流量强度) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="bold">L</mi><mo>∗</mo><mi mathvariant="bold">a</mi></mrow><mi mathvariant="bold">R</mi></mfrac></mrow><annotation encoding="application/x-tex">\pmb{\frac{L*a}{R}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.239553222222222em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="inner"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8945532222222221em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:1.217331em;vertical-align:-0.3227777777777778em;"></span><span class="inner"><span class="mord"><span class="mspace" style="margin-right:0.022222222222222223em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8945532222222221em;"><span style="top:-3.022222222222222em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3227777777777778em;"><span></span></span></span></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3227777777777778em;"><span></span></span></span></span></span><span class="mord"><span class="mspace" style="margin-right:0.044444444444444446em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span><br />当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>L</mi><mo>∗</mo><mi>a</mi></mrow><mi>R</mi></mfrac><mspace width="1em"/><mo>−</mo><mo>&gt;</mo><mspace width="1em"/><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{L*a}{R}\quad -&gt;\quad 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，分组稀疏到达,无队列,平均排队延迟极小接近于0<br />当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>L</mi><mo>∗</mo><mi>a</mi></mrow><mi>R</mi></mfrac><mspace width="1em"/><mo>−</mo><mo>&gt;</mo><mspace width="1em"/><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{L*a}{R}\quad -&gt;\quad 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大<br />当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>L</mi><mo>∗</mo><mi>a</mi></mrow><mi>R</mi></mfrac><mspace width="1em"/><mo>&gt;</mo><mspace width="1em"/><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{L*a}{R}\quad &gt;\quad 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大。</p><h3 id="loss丢包"><a class="markdownIt-Anchor" href="#loss丢包"></a> Loss(丢包)</h3><p>当Queueing Delay很大时即traffic intensity大于或趋向于1时，路由器或交换机会选择丢弃一些到达的分组，这时候分组就会丢失，称为丢包。</p><h3 id="throughput吞吐量"><a class="markdownIt-Anchor" href="#throughput吞吐量"></a> Throughput(吞吐量)</h3><p>定义: 在发送方和接收方之间单位时间内成功地传送数据的数量。因此可以分为平均吞吐量和瞬间吞吐量。<br />每个端到端的连接吞吐量取决于连接上所有链路中吞吐量最小的链路吞吐量，该链路称为<strong>瓶颈链路</strong>。瓶颈链路一般出现在网络核心到网络边缘的链路上。</p><h2 id="protocol-layers-and-their-service-models网络协议层和其服务模型"><a class="markdownIt-Anchor" href="#protocol-layers-and-their-service-models网络协议层和其服务模型"></a> Protocol Layers and Their Service Models(网络协议层和其服务模型)</h2><h3 id="protocol-layers网络协议层"><a class="markdownIt-Anchor" href="#protocol-layers网络协议层"></a> Protocol Layers(网络协议层)</h3><p><img src="protocol_layer.svg" alt="网络协议栈模型(五层模型)" /><br /><strong>每层的主要任务:</strong></p><ul><li>应用层: 应用层负责传输端系统中应用程序的数据报文信息，并且是网络应用程序及它们的应用层协议存留的地方。典型协议: HTTP;FTP;SMTP;</li><li>传输层: 传输层负责传输数据段，在应用程序端点之间传输数据段。典型协议: TCP;UDP;</li><li>网络层: 网络层负责将数据报从一台主机移动到另一条主机。典型协议: IP;OSPF;BGP;</li><li>链路层: 链路层负责将数据帧从一个网络节点移动到另一个网络节点。典型协议: PPPoE;Ethernet;</li><li>物理层: 物理层负责将比特从一个网络元素移动到邻近的网络元素。<br /><img src="ISO_OSI.svg" alt="ISO/OSI模型(七层模型)" /></li></ul><p>七层模型相较于五层模型增加了表示层和会话层，其他层次结构相同。</p><ul><li>presentation: 使通信的应用程序能够解释交换数据的含义。</li><li>session: 提供数据交换定界和同步功能。</li></ul><h2 id="review"><a class="markdownIt-Anchor" href="#review"></a> Review</h2><p><img src="review.svg" alt="Review" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Database Storage Structure</title>
    <link href="/2022/05/09/database-storage-structure/"/>
    <url>/2022/05/09/database-storage-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="database-storage-structure"><a class="markdownIt-Anchor" href="#database-storage-structure"></a> Database Storage Structure</h1><p>本文介绍数据库在磁盘上的存储格式与层次:Table-&gt;Block-&gt;Record</p><h2 id="record-structure"><a class="markdownIt-Anchor" href="#record-structure"></a> Record Structure</h2><p>数据在磁盘上布局的基本单位:record;对关系型数据库而言，一条record就是对应关系中的一行，而对NoSQL数据库而言，record并不是数据存储的唯一方式。</p><h3 id="定长record"><a class="markdownIt-Anchor" href="#定长record"></a> 定长record</h3><p>  如果一条record的长度是固定值时，数据库存储起来会比较容易，并且record的结构也会相对简单。如下面定长record图所示，record分为两大部分:header和data;<br /><img src="fixed_length_record.png" alt="定长record" /><br />  如图所示:record的前端为header，后部分为data部分。其中header内包含了to schema、整条record长度、时戳等信息，其中schema可以简单理解为record的是表ID属性，但其实并不准确，后续会详细介绍schema的概念，而to schema是指向该record对应的schema的指针或者其他一些访问方式，不同数据库的实现方式具有一定不同。data部分则是直接将字段值按顺序存放，而没有其他的间隔或者区分方式，这是因为schema中保存了不同字段的长度，在需要解析的时候可以根据schema把需要的字段直接定位出来。</p><h3 id="变长record"><a class="markdownIt-Anchor" href="#变长record"></a> 变长record</h3><p>  但在实际使用中record为定长的可能性比较低，因为很可能会存在某字段需要使用不同长度的变量来描述，同时因为field为变长，record也必须是变长的。下面是一张关于变长record可能的结构图。<br /><img src="non_fixed_length_record.png" alt="变长字段的record" /><br />  可以看到，与定长record相似，都是分为header和data部分。header部分与定长record相同，都是一些record的信息，如to schema整条record的长度和时戳等，但是data部分与定长record却有较大的不同，变长record在存放具体字段值时与定长record相同，并没有采用特殊的分隔符等操作，但是在存放之前有一段指针数组，其中存放的时指向不同字段起始位置的指针，值得强调的是:这里说的指针并非内存中的指针，而是相对偏移量。通过这个偏移量数组即可确定不同字段的长度和内容从而做到识别字段。</p><p>  除了record中有变长字段的情况，还有一种情况也会导致record为变长record——具有重复字段，如下图所示:name、address都是定长字段，而movies也是定长字段，但特殊的是在record中可能会出现多个movies的情况，因此record也无法是一个定长的record而是一条变长record来保证上述情况的保存。<br /><img src="repeated_field_record.png" alt="重复字段的record" /><br />解决方案与具有变长字段类型，就是在data部分增加一个指针数组，指向不同的字段起始位置来区别不同字段。如果从变长字段的角度来理解的话，则movies不再是一个定长字段而是一个变长字段，这样有重复字段的处理方式其实与有变长字段的处理方式是一模一样的。</p><p>  在变长record中还有一种情况——变字段record，即是一条record对应的字段数量、字段类型和字段含义是不相同的，而是record中具有一定的自解释能力，严格来说这已经不再属于关系型数据库的范围，因此在这里不做详细展开。</p><h3 id="my-record-implementation"><a class="markdownIt-Anchor" href="#my-record-implementation"></a> My Record Implementation</h3><p>  该记录为数据库原理与实现课程老师给出雏形，后参照InnoDB和MySQL的实现设计而成。具体如图所示:<br /><img src="my_record.png" alt="My Record" /><br />其中header为固定的1Byte大小，其结构为:</p><center><B>| T | M | x | x | x | x | x | x |</B></center>  其中T为tombstone标志，用来说明这条record是否存活，M为最小记录，x均为保留位供其他使用。在使用过程中需要掩码参与进行操作。  <p><strong>特别说明:</strong></p><ul><li>上图虽然header放在offset数组后面，但在代码实际实现中，header仍然位于record的最前方，而其他相对位置不变。</li><li>当Record删除时，其占据的空间不会立刻被回收，而是仅仅把Record的Header中tombstone标记为死亡，当空间不足时，才会被回收。</li></ul><h2 id="block-structure"><a class="markdownIt-Anchor" href="#block-structure"></a> Block Structure</h2><p>  Block是数据库的基本IO单位，当进程需要调用数据库中的record的时，至少需要调入一整个Block而无法仅仅访问一个record。</p><h3 id="简单block实现"><a class="markdownIt-Anchor" href="#简单block实现"></a> 简单Block实现</h3><p><img src="simple_block.png" alt="简单Block" /><br />  如图所示:Block一般由header和record构成，头部主要包含指向后继Block的指针，标记记录是否延续到下一个block，时戳，剩余空间大小，剩余空间起始位置等关键信息。而record区则是一个变长的数组，其中每一个元素都是一个完整的record。</p><h3 id="相对复杂但更合理的block实现"><a class="markdownIt-Anchor" href="#相对复杂但更合理的block实现"></a> 相对复杂但更合理的Block实现</h3><p><img src="complex_block.png" alt="较复杂Block" /><br />  上图是Block的另一种可行的Block实现方案，前部分与简单Block相同，都是有着header和record区，但是在record区域后方，这里相比简单Block，添加了一个tail来为record的数组进行排序，具体排序实现在My Block Implementation中进行详细说明。在record数组和tail之间存在free space，当有新record插入时，record数组向后延伸，而tail则向前延伸，从而压缩free space空间。</p><h3 id="my-block-implementation"><a class="markdownIt-Anchor" href="#my-block-implementation"></a> My Block Implementation</h3><p><img src="my_block.png" alt="My Block" /><br />  由上图可以看见，Block的结构为：Block Header + Data Header + Data + Free Space + Slots + Trailer。其中Slots和Trailer共同作为tail。</p><p>  因为Block存在不同的类型，在实现时采用了基类和派生类的方法来进行不同Block的实现，uml图如下:<br /><img src="block_implement.png" alt="Class Structure" /><br />  其中Block作为基类，派生出了SuperBlock和MetaBlock类，而DataBlock为MetaBlock的直接派生。至于为什么要设置SuperBlock和MetaBlock具体原因可以参考下面对Table的设计。而不同类型Block的主要区别在于Header部分的不同，也就是上面图My Block中Data/Index Header与Data/Index部分体现出的不同。其中Common Header实现如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CommonHeader</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magic;       <span class="hljs-comment">// magic number(4B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> spaceid;     <span class="hljs-comment">// 表空间id(4B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> type;      <span class="hljs-comment">// block类型(2B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> freespace; <span class="hljs-comment">// 空闲记录链表(2B)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>magic为魔数，编码为小端时<code>0x31306264</code>，大端时为<code>0x64623031</code>，可用来判断Block是否损坏和防止缓冲区攻击。</li><li>spaceid用以标记该Block属于的表空间。</li><li>type用来说明当前Block的类型，可选项有:IdleBlock,SuperBlock,DataBlock,IndexBlock,MetaBlock以及LogBlock，其中MetaBlock与DataBlock的Header部分完全相同(DataBlock是MetaBlock的子类)。</li><li>freespace是空闲链表开始位置的偏移量，当有新的Record插入时，会根据freespace当前位置到slots数组之间的空间来分配空间，如果空间足够则将Record插入到freespace下需要的空间内，freespace下移;若freespace下到slots数组之间的空间不足并且freesize大于需要的空间，Block需要去将已经被删除了的Record空间回收回来并将freespace上部空闲空间进行挤压，然后重新确定freespace的偏移量。注意:因为回收死亡Record空间是开销很大的操作，因此当freespace还没有到达slots数组或者无法为新的Record分配空间时，不会进行回收。</li></ul><p>  tail的实现则更为简单。每一个Block的tail由两部分组成:slots数组和Trailer，slots数组在下面会详细介绍，而Trailer中仅有checksum一个变量类型为<code>unsigned int</code>作为校验和来保证Block的安全性。</p><p>  以下将仅介绍最重要和最常见的Block类型:DataBlock，其他Block暂时并不重要。其中SuperBlock作为Table管理Block的工具将会在Table的结构中介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataHeader</span> : CommonHeader &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next;       <span class="hljs-comment">// 下一个数据块(4B)</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> stamp;         <span class="hljs-comment">// 时戳(8B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> slots;    <span class="hljs-comment">// slots[]长度(2B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> freesize; <span class="hljs-comment">// 空闲空间大小(2B)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> self;       <span class="hljs-comment">// 本块id(4B)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>因为目前没有说到Table是如何组织不同Block间的关系，这里简单的提一下:在一个Table中一个是由一个单向链表来组织所有的Block，而SuperBlock则是链表的表头，每一个Block都是一个Node，Block中的next为下一个Block的id。</li><li>DataHeader中的slots为当前Block中slots数组的长度而不是指向slots数组的指针，因为在Block结构图中可以看到，slots数组一定在Block的尾部，只需要根据Block的大小定位到最后一位然后向前移动一个<code>unsigned int</code>的大小即可找到slots数组，而头部只需要提供当前Block中有多少个slots也就是当前Block中有多少个Record来方便使用。<br />  因为上面一直在讲slots数组但没有具体说明Slot到底是个啥，接下来先将Slot的概念叙述清楚。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Slot</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> offset; <span class="hljs-comment">// 记录偏移量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> length; <span class="hljs-comment">// 记录大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  slots数组是对应Block中的每一个Record在Block中的位置。Slot为Record在Block中的一个定位信息，而slots数组则是将所有Record的Slot放在一起并根据主键的大小进行排序，当需要在Block中定位Record时，只需要通过二分查找或者遍历的方法在slots数组中寻找到对应的Slot即可定位到目标Record的位置。Slot的定位方法还是通过Record相对于Block开始位置的偏移量来实现的，不过在Slot中还包含了Record的大小，这个可以为其他很多功能提供一个快速工具。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一台DIY主机</title>
    <link href="/2022/04/06/%E7%AC%AC%E4%B8%80%E5%8F%B0DIY%E4%B8%BB%E6%9C%BA/"/>
    <url>/2022/04/06/%E7%AC%AC%E4%B8%80%E5%8F%B0DIY%E4%B8%BB%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="我的第一台diy主机"><a class="markdownIt-Anchor" href="#我的第一台diy主机"></a> 我的第一台DIY主机</h1><h2 id="总花费4053rmb"><a class="markdownIt-Anchor" href="#总花费4053rmb"></a> 总花费：4053RMB</h2><p>首先是需求问题，平时电脑在实验室懒得带回来，上课也不用带电源那个大板砖，但是又想在宿舍摆烂因此萌生了自己diy主机的想法，不过由于显卡价格持续高涨，这个想法就一直被搁置了，直到出现了那张显卡。<br />某天我正在上课摸鱼，突然蛋哥给我甩了一个河畔上出1065的帖子，一看价格才<strong>900</strong>！！！我瞬间就心动了，正当我准备去找卖家时蛋哥告诉我他已经拿下了，果然蛋哥还是那个贴心好学长）。于是由一张显卡引发的银行卡惨案开始了~</p><h2 id="cpu与主板"><a class="markdownIt-Anchor" href="#cpu与主板"></a> CPU与主板</h2><p>直接上配置：10代i5+迫击炮（<strong>闲鱼二手购入：1322RMB</strong>） 具体型号为10400f+b560m，其实是一个比较尴尬的选择，但是没有办法，具体原因下面会解释。</p><h2 id="ssd"><a class="markdownIt-Anchor" href="#ssd"></a> SSD</h2><p>凯侠的RC20/1T （<strong>JD自营购入：629RMB</strong>）５年质保，2100MB/s的读速，本来对比的是西数SN550的2400速度，但其实实际体验基本没感觉，因此选择了哪个便宜买哪个，SN550太贵了这段时间，散热问题对我选的这款机箱基本没影响。</p><h2 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h2><p>二线小厂十铨（TForce）火神Z 3200频率 16G*2 （<strong>JD旗舰店购入：两条769RMB</strong>）这个价格可以说十分的良心了，也正是因为这个内存让我不得不选择了i5+b560m的搭配，因为10400f只能支持2666的频率，11代因特尔的牙膏懂得都懂，不想加那点钱，而b560m的内存选择可以支持2666和3200，所以最后选择了升级主板，但是如果要升级12代的话b560m又不行，所以是十分尴尬的处境，不过好在这机子只用2年半到时候直接丢给舍友就好，内存还方便带走。</p><h2 id="显卡"><a class="markdownIt-Anchor" href="#显卡"></a> 显卡</h2><p>1060 5G版本 不知名品牌铭影（<strong>清水河畔二手货：900RMB</strong>） 刚到手的时候灰特别大一度怀疑是矿卡，不过清灰后还是挺新的，主要是这个价格太香了。性能的话其实一般，打LOL<em>1080p</em>200帧轻轻松松，大镖客2<em>1080p</em>40帧左右吧，勉强能接受。</p><h2 id="机箱与散热器"><a class="markdownIt-Anchor" href="#机箱与散热器"></a> 机箱与散热器</h2><p>机箱是航嘉魔影师Ⅲ 带了4个蓝光风扇（<strong>JD第三方购入：179RMB</strong>）这个价位很不错一个机箱了，比那个暗夜猎手Ⅵ好。机箱宽敞，风道合理。散热器是九州风神玄冰400 （<strong>JD自营购入：79RMB</strong>），在烤机下CPU最高60°，平常使用才30°多点都冻感冒了，显卡在这个环境下都没加硅脂还能保持70°以下的水平。</p><h2 id="电源"><a class="markdownIt-Anchor" href="#电源"></a> 电源</h2><p>长城6800 600W （<strong>同学手中收的：175RMB</strong>）对这个配置来说600W绰绰有余了，金牌的电源也算说的过去。</p><h1 id="使用体验"><a class="markdownIt-Anchor" href="#使用体验"></a> 使用体验</h1><p>以后有空再说吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
