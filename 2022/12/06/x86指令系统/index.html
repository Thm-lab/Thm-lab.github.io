

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Thm">
  <meta name="keywords" content="谭泓旻">
  
    <meta name="description" content="X86指令系统  X86 32位寻址方式 寻址方式主要在三方面上进行运用:  操作数的寻址 转移地址的寻址 IO端口的寻址  以下分别对X86指令的三方面寻址方式进行说明  操作数寻址 由冯诺依曼架构可以得到这样的结论: 操作数的来源只有三处:  指令直接给出 存放在寄存器中 存放在内存单元中  其中最简单的方式就是由指令直接给出，最复杂的则为存放在内存单元中，以下将分别说明不同的寻址方式！">
<meta property="og:type" content="article">
<meta property="og:title" content="X86指令系统">
<meta property="og:url" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Thm&#39;s blog">
<meta property="og:description" content="X86指令系统  X86 32位寻址方式 寻址方式主要在三方面上进行运用:  操作数的寻址 转移地址的寻址 IO端口的寻址  以下分别对X86指令的三方面寻址方式进行说明  操作数寻址 由冯诺依曼架构可以得到这样的结论: 操作数的来源只有三处:  指令直接给出 存放在寄存器中 存放在内存单元中  其中最简单的方式就是由指令直接给出，最复杂的则为存放在内存单元中，以下将分别说明不同的寻址方式！">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/bias_formula.png">
<meta property="og:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/mov.png">
<meta property="og:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/div.png">
<meta property="og:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/bcd.png">
<meta property="og:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/big_shift.png">
<meta property="article:published_time" content="2022-12-06T09:25:26.000Z">
<meta property="article:modified_time" content="2023-01-01T09:44:12.244Z">
<meta property="article:author" content="Thm">
<meta property="article:tag" content="Assembly Language">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/12/06/x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/bias_formula.png">
  
  
  <title>X86指令系统 - Thm&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>life and study balance</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="X86指令系统">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Thm
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-12-06 17:25" pubdate>
        December 6, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      125 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">X86指令系统</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：January 1, 2023 pm
                
              </p>
            
            <div class="markdown-body">
              <h1 id="x86指令系统"><a class="markdownIt-Anchor" href="#x86指令系统"></a> X86指令系统</h1>
<h2 id="x86-32位寻址方式"><a class="markdownIt-Anchor" href="#x86-32位寻址方式"></a> X86 32位寻址方式</h2>
<p>寻址方式主要在三方面上进行运用:</p>
<ul>
<li>操作数的寻址</li>
<li>转移地址的寻址</li>
<li>IO端口的寻址</li>
</ul>
<p>以下分别对X86指令的三方面寻址方式进行说明</p>
<h3 id="操作数寻址"><a class="markdownIt-Anchor" href="#操作数寻址"></a> 操作数寻址</h3>
<p>由冯诺依曼架构可以得到这样的结论: 操作数的来源只有三处:</p>
<ol>
<li>指令直接给出</li>
<li>存放在寄存器中</li>
<li>存放在内存单元中</li>
</ol>
<p>其中最简单的方式就是由指令直接给出，最复杂的则为存放在内存单元中，以下将分别说明不同的寻址方式！</p>
<h4 id="立即寻址"><a class="markdownIt-Anchor" href="#立即寻址"></a> 立即寻址</h4>
<p>立即寻址即是<strong>由指令直接给出源操作数</strong>。<strong>立即寻址只能用于指令的源操作数！</strong><br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> <span class="hljs-number">1200H</span><span class="hljs-comment">; 将1200H这个数放如al中</span><br></code></pre></td></tr></table></figure>
<h4 id="寄存器直接寻址"><a class="markdownIt-Anchor" href="#寄存器直接寻址"></a> 寄存器(直接)寻址</h4>
<p>即操作数<strong>直接存放在寄存器中</strong>，处理器会直接从寄存器中拿取操作数。<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span> <span class="hljs-built_in">al</span><span class="hljs-comment">; 将al中的数移动到bl中</span><br></code></pre></td></tr></table></figure>
<h4 id="寄存器间接寻址"><a class="markdownIt-Anchor" href="#寄存器间接寻址"></a> 寄存器间接寻址</h4>
<p><strong>操作数存放在内存之中</strong>，其<strong>偏移地址存放在寄存器之中</strong>，处理器先从寄存器中拿到偏移地址，再得到在内存之中的物理地址，再去该物理地址拿取操作数。<br />
操作数的段基址取决于间址寄存器，若为EBP、ESP则默认在堆栈段，其他寄存器则为数据段。当然如果是flat模式则没有区别。<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">v1 <span class="hljs-built_in">dw</span> <span class="hljs-number">1024</span><span class="hljs-comment">; 定义字变量v1</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">ebx</span> v1<span class="hljs-comment">; 将v1的偏移地址取到ebx中，注意必须放置在32位寄存器中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 将ebx寄存器存储的内存单元的操作数取到ax中，中括号说明是寄存器间接寻址而非寄存器(直接)寻址，注意v1是dw类型变量，需要16位以上寄存器进行存放</span><br></code></pre></td></tr></table></figure>
<h4 id="直接寻址"><a class="markdownIt-Anchor" href="#直接寻址"></a> 直接寻址</h4>
<p>操作数<strong>存放在内存之中</strong>，偏移地址由变量表示。<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">v1 <span class="hljs-built_in">db</span> <span class="hljs-number">1</span><span class="hljs-comment">; 定义字节变量v1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> v1<span class="hljs-comment">; 将v1对应的偏移地址的数据传送到al中</span><br></code></pre></td></tr></table></figure>
<p>特别的，在X86保护模式下用户不能使用常数作为存储单元地址，若使用常数则视为立即寻址。<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span> [<span class="hljs-number">1200H</span>]<span class="hljs-comment">; 等价于 mov al 1200H</span><br></code></pre></td></tr></table></figure>
<h4 id="寄存器相对寻址"><a class="markdownIt-Anchor" href="#寄存器相对寻址"></a> 寄存器相对寻址</h4>
<p>操作数<strong>存放在内存中</strong>，操作数的偏移地址为间址寄存器的内容加上一个位移量，位移量可以是一个常数，也可以是变量<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">dd</span> <span class="hljs-number">1</span><span class="hljs-comment">; 相对偏移量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>+data]<span class="hljs-comment">; 将ebx+data寄存器存储的内存单元的操作数移动到ax中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, data[<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]+data<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>+<span class="hljs-number">5</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">5</span>[<span class="hljs-built_in">ebx</span>]<span class="hljs-comment">; 相同的含义不同的语句形式</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">ebx</span>]+<span class="hljs-number">5</span><span class="hljs-comment">; 相同的含义不同的语句形式</span><br></code></pre></td></tr></table></figure>
<p><strong>Hint</strong>: <code>mov ax,[ebx]5</code>是错误的用法，<strong>当常数或变量在后面时，必须加加号，在前面可加可不加</strong></p>
<h4 id="基址-变址寻址"><a class="markdownIt-Anchor" href="#基址-变址寻址"></a> 基址-变址寻址</h4>
<p>操作数<strong>存放在内存中</strong>，操作数的偏移地址为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">基</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">容</mi><mo>+</mo><mi mathvariant="normal">变</mi><mi mathvariant="normal">址</mi><mi mathvariant="normal">寄</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">容</mi><mo>×</mo><mi mathvariant="normal">比</mi><mi mathvariant="normal">例</mi><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="normal">位</mi><mi mathvariant="normal">移</mi><mi mathvariant="normal">量</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">基址寄存器的内容 + 变址寄存器的内容\times 比例 + (位移量)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">址</span><span class="mord cjk_fallback">寄</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">例</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">移</span><span class="mord cjk_fallback">量</span><span class="mclose">)</span></span></span></span></span></p>
<p><img src="bias_formula.png" srcset="/img/loading.gif" lazyload alt="公式" /><br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span> [<span class="hljs-built_in">ebp</span>+<span class="hljs-number">10</span>]+[<span class="hljs-built_in">edi</span>*<span class="hljs-number">8</span>]<span class="hljs-comment">; 将ebp内的内容+10+edi内容乘以8得到内存单元，再去该内存单元取得操作数</span><br></code></pre></td></tr></table></figure>
<h4 id="隐含寻址"><a class="markdownIt-Anchor" href="#隐含寻址"></a> 隐含寻址</h4>
<p>指令中隐含了一个或两个操作数的地址，即<strong>操作数在默认的地址中</strong>。<br />
例:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mul</span> <span class="hljs-built_in">bl</span><span class="hljs-comment">; 等价于 al * bl -&gt; ax</span><br></code></pre></td></tr></table></figure>
<h3 id="转移地址寻址"><a class="markdownIt-Anchor" href="#转移地址寻址"></a> 转移地址寻址</h3>
<p>转移地址一般分为两种寻址方式:</p>
<ul>
<li>直接寻址: 当前指令与目的地指令距离<strong>在-128~127字节</strong>内时，均采用<strong>立即寻址</strong>的方式，即将位移量(1B)放在指令中，形成<strong>2字节的jmp指令</strong></li>
<li>间接寻址: 当指令与目的地指令距离超过了短转移(-128~127字节)的限制时，位移量则为4B，形成<strong>5字节的jmp指令</strong></li>
</ul>
<h3 id="io端口寻址"><a class="markdownIt-Anchor" href="#io端口寻址"></a> IO端口寻址</h3>
<p>IO端口寻址也分为两种寻址方式:</p>
<ul>
<li>直接寻址: 端口地址为8位时(可寻址256个端口)，指令中的PORT直接由一个8位无符号常数提供，是立即寻址变体<br />
例:</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> acc, port<span class="hljs-comment">; acc是al/ax/eax，port为端口地址</span><br><span class="hljs-keyword">out</span> port, acc<span class="hljs-comment">; 立即寻址操作数不能为目的操作数，但在这里可以，所以为变体</span><br></code></pre></td></tr></table></figure>
<ul>
<li>间接寻址: 当端口地址超过255时，地址码为16位(可寻址64K个端口)，<strong>指令中的端口地址必须由DX指定(不能使用EDX指定)</strong>，其中端口地址为0~255时也可使用间接寻址<br />
例:</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">132</span><span class="hljs-comment">; 端口地址为132</span><br><span class="hljs-keyword">in</span> acc, <span class="hljs-built_in">dx</span><span class="hljs-comment">; acc是al/ax/eax，从132端口取数据到acc中</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, acc<span class="hljs-comment">; acc是al/ax/eax，将acc中数据输出到132端口</span><br></code></pre></td></tr></table></figure>
<h2 id="x86指令"><a class="markdownIt-Anchor" href="#x86指令"></a> X86指令</h2>
<p>学习汇编指令主要从五个角度出发:<br />
<b></p>
<ul>
<li>指令格式</li>
<li>指令功能</li>
<li>对操作数的要求</li>
<li>指令对操作数的影响</li>
<li>指令对标志位的影响<br />
</b></li>
</ul>
<p>在下面六大类的每条指令中均会说明该五个角度，并且需要记忆！</p>
<h3 id="数据传送指令"><a class="markdownIt-Anchor" href="#数据传送指令"></a> 数据传送指令</h3>
<p>数据传送指令一般对标志位无影响</p>
<h4 id="mov"><a class="markdownIt-Anchor" href="#mov"></a> mov</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> dest, src<br></code></pre></td></tr></table></figure>
<p>功能:<br />
将src的操作数送到dest内<br />
操作数要求:</p>
<ol>
<li>两操作数长度必须相同</li>
<li>存储单元之间不能直接传送(可以用串操作指令实现直接传送)</li>
<li>段寄存器CS只能作源操作数，段寄存器之间不能直接传送</li>
<li>在源操作数是立即数时，目标操作数不能是段寄存器</li>
<li>标志寄存器(EFLAGS或FLAGS)一般不作为操作数在指令中出现</li>
</ol>
<p><img src="mov.png" srcset="/img/loading.gif" lazyload alt="mov操作数要求" /><br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="movzxmovsx"><a class="markdownIt-Anchor" href="#movzxmovsx"></a> movzx/movsx</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">movzx</span> reg32, reg8/mem8<br><span class="hljs-keyword">movzx</span> reg32, reg16/mem16<br><span class="hljs-keyword">movzx</span> reg16, reg8/mem8<br><span class="hljs-keyword">movsx</span> reg32, reg8/mem8<br><span class="hljs-keyword">movsx</span> reg32, reg16/mem16<br><span class="hljs-keyword">movsx</span> reg16, reg8/mem8<br></code></pre></td></tr></table></figure>
<p>功能:<br />
将位数短的操作数传到较长的寄存器，并进行<strong>0扩展(movzx)<strong>或</strong>符号扩展(movsx)</strong><br />
操作数要求:</p>
<ol>
<li>源操作数位数要小于目的操作数长度</li>
<li>目的操作数必须为寄存器<br />
对操作数影响:<br />
源操作数无影响，目的操作数变为源操作数的0扩展或符号扩展<br />
对标志位影响:<br />
无影响</li>
</ol>
<h4 id="pushpoppushapushdpopapopdpushfdpopfd"><a class="markdownIt-Anchor" href="#pushpoppushapushdpopapopdpushfdpopfd"></a> push/pop/pusha/pushd/popa/popd/pushfd/popfd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">ABCDH</span><span class="hljs-comment">; 将16位立即数入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">ABCD0000H</span><span class="hljs-comment">; 将32位立即数入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">; 将ax内容入栈</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span>[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">; 将bx内容的存储字单元入栈</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">; 将出栈值放入ax</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span>[<span class="hljs-built_in">bx</span>]<span class="hljs-comment">; 将出栈值放入bx内容的存储字单元</span><br><span class="hljs-keyword">pusha</span><span class="hljs-comment">; 将8个16位通用寄存器按AX、CX、DX、BX、SP、BP、SI与DI的顺序入栈</span><br><span class="hljs-keyword">popa</span><span class="hljs-comment">; 从栈顶弹出8个字数据分别送入DI、SI、BP、SP、BX、DX、CX与AX</span><br>pushd<span class="hljs-comment">; 将8个32位通用寄存器按EAX、ECX、EDX、EBX、ESP、EBP、ESI与EDI的顺序入栈</span><br>popd<span class="hljs-comment">; 从栈顶弹出8个双字数据分别送入EDI、ESI、EBP、ESP、EBX、EDX、ECX与EAX</span><br><span class="hljs-keyword">pushfd</span><span class="hljs-comment">; EFLAGS进栈</span><br><span class="hljs-keyword">popfd</span><span class="hljs-comment">; 出栈送到EFLAGS</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
push/pop: 将16位数据入栈或出战<br />
pusha/popa: 将8个16位通用寄存器按AX、CX、DX、BX、SP、BP、SI与DI的顺序入栈和从栈顶弹出8个字数据分别送入DI、SI、BP、SP、BX、DX、CX与AX<br />
pushd/popd: 将8个32位通用寄存器按EAX、ECX、EDX、EBX、ESP、EBP、ESI与EDI的顺序入栈和从栈顶弹出8个双字数据分别送入EDI、ESI、EBP、ESP、EBX、EDX、ECX与EAX<br />
pushfd/popfd: 32位标志寄存器EFLAGS进栈/出栈指令<br />
操作数要求:<br />
<strong>若为存储器操作数，需要声明为字存储单元(PTR)</strong><br />
对操作数影响:<br />
对标志位影响:<br />
对标志位无影响，但会影响SP内的值<br />
push: SP变为SP-2<br />
pop: SP变为SP+2</p>
<h4 id="xchg"><a class="markdownIt-Anchor" href="#xchg"></a> xchg</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">xchg</span> reg/mem, mem/reg<br></code></pre></td></tr></table></figure>
<p>功能:<br />
交换寄存器和内存单元的值<br />
操作数要求:</p>
<ol>
<li>必须有一个操作数是寄存器操作数</li>
<li>不允许使用段寄存器<br />
对操作数影响:<br />
源操作数变为目的操作数，目的操作数变为源操作数<br />
对标志位影响:<br />
无影响</li>
</ol>
<h4 id="inout"><a class="markdownIt-Anchor" href="#inout"></a> in/out</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> acc, port<span class="hljs-comment">; 将端口数据传送到acc中</span><br><span class="hljs-keyword">out</span> port, acc<span class="hljs-comment">; 将acc中数据传送到端口中</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
对IO端口进行输入和输出<br />
操作数要求:<br />
port在0~255时可以是立即数，也可以是dx，port大于255时必须是dx<br />
acc可以是al、ax或eax，但不能是其他寄存器<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> lea</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lea</span> reg, mem<br></code></pre></td></tr></table></figure>
<p>功能:<br />
将一个存储单元的32位(保护模式)偏移地址取出送目标寄存器<br />
操作数要求:</p>
<ol>
<li>源操作数必须为存储单元操作数</li>
<li>目的操作数必须为16位或32位寄存器操作数<br />
对操作数影响:<br />
若目的操作数为32位寄存器操作数，目的操作数变为源操作数的偏移地址，若目的操作数为16位寄存器操作数，目的操作数变为源操作数的偏移地址的低16位<br />
对标志位影响:<br />
无影响</li>
</ol>
<h4 id="lahfsahf"><a class="markdownIt-Anchor" href="#lahfsahf"></a> lahf/sahf</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lahf</span><span class="hljs-comment">; 将FLAGS的低8位装入AH</span><br><span class="hljs-keyword">sahf</span><span class="hljs-comment">; 将AH装入FLAGS的低8位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
lahf: 将FLAGS的低8位装入AH<br />
sahf: 将AH装入FLAGS的低8位<br />
操作数要求:<br />
无要求，因为是隐含地址<br />
对操作数影响:<br />
lahf: AH内容变为FLAGS的低8位<br />
sahf: FLAGS低8位变为AH内容<br />
对标志位影响:<br />
lahf: 无影响<br />
sahf: 标志位低8位涉及到的标志位变为AH内容对应位</p>
<h3 id="算术运算指令"><a class="markdownIt-Anchor" href="#算术运算指令"></a> 算术运算指令</h3>
<p>算术运算指令的执行大多对状态标志位会产生影响，对标志位的影响是算术运算指令的应用思路之一。</p>
<h4 id="addadcinc"><a class="markdownIt-Anchor" href="#addadcinc"></a> add/adc/inc</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">add</span> oprd1, oprd2<span class="hljs-comment">; oprd1+oprd2送到oprd1内</span><br><span class="hljs-keyword">adc</span> oprd1, oprd2<span class="hljs-comment">; oprd1+oprd2+CF送到oprd1内</span><br><span class="hljs-keyword">inc</span> oprd<span class="hljs-comment">; oprd自增1</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
add: 将oprd1与oprd2相加送到oprd1中<br />
adc: 将oprd1与oprd2相加再加上CF标志位送到oprd1中。<strong>adc指令常用于多字节数相加，使用前要先将CF清零。</strong><br />
inc: oprd自增1<br />
操作数要求:<br />
add/adc: 与<a href="#mov">mov指令</a>基本相同<br />
inc:</p>
<ol>
<li>不能是立即数</li>
<li>不能是段寄存器<br />
对操作数影响:<br />
add/adc: oprd1变为oprd1+oprd2+(CF)，oprd2无影响<br />
inc: oprd自增1<br />
对标志位影响:<br />
add/adc: 对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)<br />
inc: <strong>不影响CF</strong>，其他5个状态标志位仍然受到影响</li>
</ol>
<p><strong>adc实现多字节数相加示例</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">m1 <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; m1是20个字节的大数</span><br>m2 <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(<span class="hljs-number">2</span>)<span class="hljs-comment">; m2是20个字节的大数</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span> m1<span class="hljs-comment">; 取得m1起始地址</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span> m2<span class="hljs-comment">; 取得m2起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span> <span class="hljs-number">20</span><span class="hljs-comment">; 大数字节数作为循环加法数</span><br><span class="hljs-keyword">clc</span><span class="hljs-comment">; 清空CF</span><br><span class="hljs-symbol">next:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将esi的数取到al中，因为adc不能直接用于两个存储器操作数之间</span><br><span class="hljs-keyword">adc</span> [<span class="hljs-built_in">edi</span>], <span class="hljs-built_in">al</span><span class="hljs-comment">; 带CF的相加</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><span class="hljs-comment">; 相加指针移动</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span><span class="hljs-comment">; 相加指针移动</span><br><span class="hljs-keyword">dec</span> <span class="hljs-built_in">cl</span><span class="hljs-comment">; 剩余未加字节数减少</span><br><span class="hljs-keyword">jnz</span> next<span class="hljs-comment">; 判断是否相加完成</span><br></code></pre></td></tr></table></figure>
<h4 id="subsbbdec"><a class="markdownIt-Anchor" href="#subsbbdec"></a> sub/sbb/dec</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> oprd1, oprd2<span class="hljs-comment">; oprd1-oprd2送到oprd1内</span><br><span class="hljs-keyword">sbb</span> oprd1, oprd2<span class="hljs-comment">; oprd1-oprd2-CF送到oprd1内</span><br><span class="hljs-keyword">dec</span> oprd<span class="hljs-comment">; oprd自减1 </span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
sub: 将oprd1与oprd2相减送到oprd1中<br />
sbb: 将oprd1与oprd2相减再减去CF标志位送到oprd1中。<br />
inc: oprd自减1<br />
操作数要求:<br />
sub/sbb: 与<a href="#mov">mov指令</a>基本相同<br />
dec:</p>
<ol>
<li>不能是立即数</li>
<li>不能是段寄存器<br />
对操作数影响:<br />
sub/sbb: oprd1变为oprd1-oprd2-(CF)，oprd2无影响<br />
inc: oprd自增1<br />
对标志位影响:<br />
sub/sbb: 对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)<br />
dec: <strong>不影响CF</strong>，其他5个状态标志位仍然受到影响</li>
</ol>
<h4 id="neg"><a class="markdownIt-Anchor" href="#neg"></a> neg</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">neg</span> oprd<span class="hljs-comment">; 0-oprd送oprd内</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
用0减去操作数，相当于对该操作数求补，但不是补码。<br />
操作数要求:<br />
必须是寄存器操作数(8位、16位、32位均可)或存储器操作数<br />
对操作数影响:<br />
oprd变为0 - oprd<br />
对标志位影响:<br />
6个标志位(AF、PF、CF、OF、ZF、SF)都会被影响<br />
对CF的影响:</p>
<ol>
<li>oprd为0时，CF=0</li>
<li>oprd不为0时，CF=1</li>
</ol>
<p>对OF的影响:<br />
当字节操作数为-128(80H)，或字操作数为-32768(8000H)或双字操作数为80000000H时，结果将无变化，但溢出标志OF被置1</p>
<h4 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> cmp</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cmp</span> oprd1, oprd<span class="hljs-comment">; 执行oprd1-oprd2，但不送任何单元</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
用于比较两个数的大小，可作为条件转移指令转移的条件<br />
操作数要求:<br />
与<a href="#mov">mov指令</a>基本相同<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
对6个状态标志位均产生影响(AF、PF、CF、OF、ZF、SF)</p>
<p><strong>cmp指令对标志位的影响主要通过CF、ZF、OF、SF四个标志位来判断两个数的大小</strong><br />
<b></p>
<ul>
<li>无符号数比较:
<ol>
<li>oprd1 &gt; oprd2: CF = 0 &amp; ZF = 0</li>
<li>oprd1 = oprd2: ZF = 1</li>
<li>oprd1 &lt; oprd2: CF = 1 &amp; ZF = 0</li>
</ol>
</li>
<li>带符号数比较:
<ol>
<li>oprd1 &gt; oprd2: OF = SF &amp; ZF = 0(为正数时，OF与SF相等表示结果仍为正数，说明oprd1大;为负数时，SF为1时结果为负数，OF为1表示结果溢出，oprd1大，SF为0时结果为正数，OF为0表示不溢出，说明oprd2的绝对值大，负数小)</li>
<li>oprd1 = oprd2: ZF = 1</li>
<li>oprd1 &lt; oprd2: OF <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> SF &amp; ZF = 0(与oprd1 &gt; oprd2结论相反，除了ZF = 0)</li>
</ol>
</li>
</ul>
<p>也可通过直接的跳转指令实现根据两数大小的跳转:</p>
<ol>
<li>无符号数比较跳转:
<ul>
<li>ja/jae: ja为当oprd1&gt;oprd2时跳转，jae为当oprd1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd2时跳转</li>
<li>jb/jbe: jb为当oprd2&gt;oprd1时跳转，jbe为当oprd2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd1时跳转</li>
</ul>
</li>
<li>带符号数比较跳转:
<ul>
<li>jg/jge: jg为当oprd1&gt;oprd2时跳转，jge为当oprd1<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd2时跳转</li>
<li>jl/jle: jl为当oprd2&gt;oprd1时跳转，jle为当oprd2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>oprd1时跳转<br />
</b></li>
</ul>
</li>
</ol>
<p><strong>cmp实现20个无符号数寻找最大值示例</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">max <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><span class="hljs-comment">; 定义存储最大值变量单元</span><br>buff <span class="hljs-built_in">db</span> <span class="hljs-number">5</span> dup(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">; 20个无符号数</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, max<span class="hljs-comment">; 取得max的偏移地址，便于后面存储最大值</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, buff<span class="hljs-comment">; 取得20个数的起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">20</span>-<span class="hljs-number">1</span><span class="hljs-comment">; 20个数只需要比较19次</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 取出第一个数到寄存器中</span><br><span class="hljs-symbol">next:</span> <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><span class="hljs-comment">; 循环的开始，需要比较指针自增</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 比较已取出的数与下一个数的大小</span><br><span class="hljs-keyword">jnc</span> goon<span class="hljs-comment">; 如果al比较大就跳转到goon里面直接进行比较指针的移动</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; al比较小，更新al</span><br><span class="hljs-symbol">goon:</span> <span class="hljs-keyword">dec</span> <span class="hljs-built_in">cl</span><span class="hljs-comment">; cl减1，比较完成</span><br><span class="hljs-keyword">jnz</span> next<span class="hljs-comment">; 重新比较流程，如果比较次数完成则直接将al内的最大值放入max中</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edi</span>], <span class="hljs-built_in">al</span><span class="hljs-comment">; 将al内的最大值放入max中</span><br></code></pre></td></tr></table></figure>
<h4 id="mulimul"><a class="markdownIt-Anchor" href="#mulimul"></a> mul/imul</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mul</span> oprd<span class="hljs-comment">; 无符号数的乘法，使用隐含寻址al、ax、eax，将隐含寻址的值*oprd送到ax、dx:ax、edx:eax中</span><br><span class="hljs-keyword">imul</span> oprd<span class="hljs-comment">; 与mul相同，但操作数被视为带符号数</span><br><span class="hljs-keyword">imul</span> dest, src<span class="hljs-comment">; src乘以dest送到dest中</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
mul/imul: 将隐含寻址的值乘以oprd倍送到扩展寄存器中(结果为64位时，由edx:eax构成64位寄存器)<br />
imul: 将src<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>dest的结果送到dest中，若结果超过目的寄存器位数则截断高位<br />
操作数要求:<br />
mul/imul: 隐含寻址时，操作数只能是寄存器操作数或存储器操作数<br />
imul: 可以是寄存器操作数或存储器操作数或<strong>比目的操作数位数少的立即数</strong><br />
对操作数影响:<br />
mul/imul: 对oprd无影响，隐含寻址操作数变为乘积的低位<br />
imul: dest操作数变为src*dest的结果的低位<br />
imul:<br />
<b>对标志位影响:<br />
mul: 只对CF和OF产生影响，若高位寄存器(即AH、DX、EDX)为全0则CF=OF=0，否则CF=OF=1<br />
imul: 只对CF和OF产生影响，隐含寻址时，若高位寄存器(即AH、DX、EDX)全为低位的符号位扩展则CF=OF=0，否则CF=OF=1<br />
imul: 只对CF和OF产生影响，如果存放结果的目的寄存器中丢弃了乘积高位的有效数值则CF=OF=1，否则CF=OF=0</b></p>
<h4 id="dividiv"><a class="markdownIt-Anchor" href="#dividiv"></a> div/idiv</h4>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">div</span> reg/mem8<br><span class="hljs-keyword">div</span> reg/mem16<br><span class="hljs-keyword">div</span> reg/mem32<br><span class="hljs-keyword">idiv</span> reg/mem8<br><span class="hljs-keyword">idiv</span> reg/mem16<br><span class="hljs-keyword">idiv</span> reg/mem32<br></code></pre></td></tr></table></figure>
<p>功能:<br />
将隐含寻址的目的操作数除以源操作数的倍数，结果放入隐含寻址的操作数中<br />
操作数要求:<br />
指令要求被除数是除数的双倍字长，因此除法指令常与扩展指令CBW、CWD、CDQ配合使用。<br />
<img src="div.png" srcset="/img/loading.gif" lazyload alt="div操作数要求" /><br />
对操作数影响:<br />
源操作数无影响，目的操作数按上图所示变化<br />
对标志位影响:<br />
无影响</p>
<h4 id="cbwcwdcdq"><a class="markdownIt-Anchor" href="#cbwcwdcdq"></a> cbw/cwd/cdq</h4>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cbw</span><span class="hljs-comment">; 隐含寻址，将AL的符号位扩展到AH</span><br><span class="hljs-keyword">cwd</span><span class="hljs-comment">; 隐含寻址，将AX的符号位扩展到DX</span><br><span class="hljs-keyword">cdq</span><span class="hljs-comment">; 隐含寻址，将EAX的符号位扩展到EDX</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
扩展源操作数的符号位到指定位置<br />
操作数要求:<br />
必须在隐含寻址的寄存器内<br />
对操作数影响:<br />
源操作数无影响，目的操作数变为源操作数的符号位扩展<br />
对标志位影响:<br />
无影响</p>
<h4 id="bcd码校正指令daaaaadasaasaamaad"><a class="markdownIt-Anchor" href="#bcd码校正指令daaaaadasaasaamaad"></a> BCD码校正指令(daa/aaa/das/aas/aam/aad)</h4>
<p><em>不要求掌握，了解即可。</em><br />
在X86系统中，BCD码可以有两种表示方式:</p>
<ul>
<li>压缩型: 一个字节表示两个BCD码，即两位十进制数。<strong>每4位表示1个十进制数</strong>。</li>
<li>非压缩型: 一个字节的<strong>低四位表示一个BCD码</strong>，而高四位对所表示的十进制数<strong>没有影响</strong>，常为0000或0011。</li>
</ul>
<p>BCD码处理指令: 先用二进制数的加、减、乘、除运算指令对BCD码运算，再用BCD码校正指令对结果校正。<br />
<img src="bcd.png" srcset="/img/loading.gif" lazyload alt="BCD码校正指令" /></p>
<h3 id="位操作指令"><a class="markdownIt-Anchor" href="#位操作指令"></a> 位操作指令</h3>
<p>位操作大多数时候也是一种算术运算，如乘法在一定程度上可以视为左移，除法在一定程度上可以用右移操作今天代替。同时位操作往往也会导致标志位的变化，同时某些<strong>特殊的位操作目的是对特定的标志位操作</strong>。</p>
<h4 id="and"><a class="markdownIt-Anchor" href="#and"></a> and</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> oprd1, oprd2<span class="hljs-comment">; oprd1和oprd2按位&amp;，结果送oprd1</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现两操作数按位相与的运算，<strong>使目标操作数的某些位不变，某些位清零</strong><br />
操作数要求:<br />
与<a href="#mov">mov指令</a>相同<br />
对操作数影响:<br />
源操作数无影响，目的操作数变为按位与的结果<br />
对标志位影响:<br />
CF=OF=0，其余状态位根据结果产生</p>
<p><strong>判断某些位是否为0</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">1</span><span class="hljs-comment">; 定义测试变量</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, data<span class="hljs-comment">; 取得测试变量偏移地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">01H</span><span class="hljs-comment">; 构造测试位为1，其余位为0的数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 测试变量与测试数据按位与</span><br><span class="hljs-keyword">jz</span> bit1<span class="hljs-comment">; 如果结果全0说明测试位为0</span><br></code></pre></td></tr></table></figure>
<p><strong>将CF和OF清零</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">; 自身按位与不改变操作数，且能将CF和OF清零</span><br></code></pre></td></tr></table></figure>
<h4 id="or"><a class="markdownIt-Anchor" href="#or"></a> or</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">or</span> oprd1, oprd2<span class="hljs-comment">; oprd1和oprd2按位|，结果送oprd1</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现两操作数按位相或的运算，<strong>使目标操作数的某些位不变，某些位置1</strong><br />
操作数要求:<br />
与<a href="#mov">mov指令</a>相同<br />
对操作数影响:<br />
源操作数无影响，目的操作数变为按位或的结果<br />
对标志位影响:<br />
CF=OF=0，其余状态位根据结果产生</p>
<p><strong>将CF和OF清零</strong>:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">and</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span><span class="hljs-comment">; 自身按位或不改变操作数，且能将CF和OF清零</span><br></code></pre></td></tr></table></figure>
<h4 id="not"><a class="markdownIt-Anchor" href="#not"></a> not</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">not</span> oprd<span class="hljs-comment">; 将操作数按位取反再送回原地址</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
将操作数按位取反<br />
操作数要求:</p>
<ol>
<li>不能为立即数</li>
<li>操作数为存储器操作数时需要说明数据类型(db、dw、dd)<br />
对操作数影响:<br />
操作数变为按位取反的结果<br />
对标志位影响:<br />
无影响</li>
</ol>
<h4 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> xor</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">xor</span> oprd1, oprd2<span class="hljs-comment">; 两操作数按位相异或，结果送目标地址</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
两操作数按位相异或，结果送目标地址，<strong>xor有个很重要的属性: 自身相异或结果为0，经常用以判断数据是否为预期数据</strong><br />
操作数要求:<br />
与<a href="#mov">mov指令</a>相同<br />
对操作数影响:<br />
源操作数无影响，目的操作数变为两操作数按位相异或结果<br />
对标志位影响:<br />
CF=OF=0，其余状态位根据结果产生</p>
<p><strong>属性应用:</strong><br />
与test例相同，需要判断bit1、bit3、bit5是否为均1，用xor指令十分优雅但会改变数据</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 去除其他位的影响</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 如果为数据bit1、bit3、bit5均为1，则与2AH(自身)异或结果为0，只需要判断ZF是否为1即可得知al的几位数据</span><br></code></pre></td></tr></table></figure>
<p><strong>还有一种在不改变数据的情况下能一次性比较多位的方式: cmp指令</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; 去除其他位的影响</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">2AH</span><span class="hljs-comment">; cmp指令通过al-2AH的方式来判断ZF，并且结果并不会送回到al中，因此不改变数据同样能够得到ZF标志位来进行判断</span><br><br>#### <span class="hljs-keyword">test</span><br>格式: <br><span class="hljs-string">```</span> x86asm<br><span class="hljs-keyword">test</span> oprd1, oprd2<span class="hljs-comment">; 执行与运算，运算的结果影响标志位，但不送回目标地址</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
判断两操作数按位与结果对标志位的影响<br />
操作数要求:<br />
与<a href="#mov">mov指令</a>相同<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
CF=OF=0，其余状态位根据结果产生</p>
<p><strong>可跟and指令一样判断某些位数据，并且不影响测试数据，因此可用来判断多位且不影响数据</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">data <span class="hljs-built_in">db</span> <span class="hljs-number">214</span><span class="hljs-comment">; 定义数据</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, data<span class="hljs-comment">; 拿到数据</span><br><span class="hljs-keyword">test</span>  <span class="hljs-built_in">al</span>，<span class="hljs-number">02H</span><span class="hljs-comment">; 判断bit1</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">08H</span><span class="hljs-comment">; 判断bit3</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">20H</span><span class="hljs-comment">; 判断bit5</span><br></code></pre></td></tr></table></figure>
<h4 id="salshl"><a class="markdownIt-Anchor" href="#salshl"></a> sal/shl</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sal</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1左移oprd2位</span><br><span class="hljs-keyword">shl</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1左移oprd2位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
<strong>sal与shl在机器指令执行时为同一条指令</strong>，将oprd1左移oprd2位，区别在于sal将操作数视为无符号数，shl将操作数视为带符号数<br />
操作数要求:<br />
<strong>oprd2必须是8位立即数或CL寄存器内容</strong><br />
对操作数影响:<br />
oprd1变为左移后的结果，oprd2无影响<br />
对标志位影响:<br />
影响标志位OF、SF、ZF、PF、CF</p>
<p><strong>左移在二进制操作中可视为特殊乘法</strong>: 左移n位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇔</mo><mi>o</mi><mi>p</mi><mi>r</mi><mi>d</mi><mn>1</mn><mo>×</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Leftrightarrow oprd1 \times 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="sarshr"><a class="markdownIt-Anchor" href="#sarshr"></a> sar/shr</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sar</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1右移oprd2位</span><br><span class="hljs-keyword">shr</span> oprd1, oprd2<span class="hljs-comment">; 将oprd1右移oprd2位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
<strong>sar与shr并不相同，sar高位补零，shr高位补符号位</strong>，将oprd1右移oprd2位，区别在于sar将操作数视为无符号数，shr将操作数视为带符号数<br />
操作数要求:<br />
<strong>oprd2必须是8位立即数或CL寄存器内容</strong><br />
对操作数影响:<br />
oprd1变为右移后的结果，oprd2无影响<br />
对标志位影响:<br />
影响标志位OF、SF、ZF、PF、CF</p>
<p><strong>右移在二进制操作中可视为特殊除法</strong>: 右移n位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇔</mo><mi>o</mi><mi>p</mi><mi>r</mi><mi>d</mi><mn>1</mn><mo>÷</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Leftrightarrow oprd1 \div 2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<h4 id="rolrcl"><a class="markdownIt-Anchor" href="#rolrcl"></a> rol/rcl</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">rol</span> oprd1, oprd2<span class="hljs-comment">; 不带CF的循环左移位oprd2位</span><br><span class="hljs-keyword">rcl</span> oprd1, oprd2<span class="hljs-comment">; 带CF的循环移左位oprd2位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
循环左移oprd2位，并将结果放入oprd1中<br />
操作数要求:<br />
与<a href="#salshl">sal/shl</a>相同<br />
对操作数影响:<br />
oprd1变为循环移位后的结果，oprd2无影响<br />
对标志位影响:<br />
<strong>影响标志位CF(rol无影响)、OF(若移位位数为1次，且移位前后目的操作数的最高位发生变化，那么OF置1，否则OF清零。若移位位数大于1，那么OF不确定)。其他标志位无影响</strong></p>
<h4 id="rorrcr"><a class="markdownIt-Anchor" href="#rorrcr"></a> ror/rcr</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ror</span> oprd1, oprd2<span class="hljs-comment">; 不带CF的循环右移位oprd2位</span><br><span class="hljs-keyword">rcr</span> oprd1, oprd2<span class="hljs-comment">; 带CF的循环移右位oprd2位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
循环右移oprd2位，并将结果放入oprd1中<br />
操作数要求:<br />
与<a href="#salshl">sal/shl</a>相同<br />
对操作数影响:<br />
oprd1变为循环移位后的结果，oprd2无影响<br />
对标志位影响:<br />
<strong>影响标志位CF(rol无影响)、OF(若移位位数为1次，且移位前后目的操作数的最高位发生变化，那么OF置1，否则OF清零。若移位位数大于1，那么OF不确定)。其他标志位无影响</strong></p>
<p>通过带CF的循环移位可以实现多字节单元数据联合移位(如<a href="#addadcinc">adc大数加法一般</a>)</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">M <span class="hljs-built_in">dw</span> <span class="hljs-number">3</span> dup(<span class="hljs-number">1</span>)<span class="hljs-comment">; 定义变量</span><br><span class="hljs-keyword">sal</span> M, <span class="hljs-number">1</span><span class="hljs-comment">; 低字节移位到CF</span><br><span class="hljs-keyword">rcl</span> M+<span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 带CF循环移位</span><br><span class="hljs-keyword">rcl</span> M+<span class="hljs-number">4</span>, <span class="hljs-number">1</span><span class="hljs-comment">; 带CF循环移位</span><br></code></pre></td></tr></table></figure>
<p><img src="big_shift.png" srcset="/img/loading.gif" lazyload alt="多字节单元数据联合移位" /></p>
<h4 id="shldshrd"><a class="markdownIt-Anchor" href="#shldshrd"></a> shld/shrd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">shld</span> dest, src, count<span class="hljs-comment">; 将目的操作数dest向左移动指定位数，移动形成的空位由源操作数source的高位填充，指令执行后source保持不变</span><br><span class="hljs-keyword">shrd</span> dest, src, count<span class="hljs-comment">; 将目的操作数dest向右移动指定位数，移动形成的空位由源操作数source的低位填充，指令执行后source保持不变</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
双精度移位操作，移位时以一定数据进行填充空位而非固定0或1<br />
操作数要求:<br />
与<a href="#salshl">sal/shl</a>相同<br />
对操作数影响:<br />
src无影响，dest变为移位后结果<br />
对标志位影响:<br />
会影响SF、ZF、AF、PF、CF</p>
<h3 id="串操作指令"><a class="markdownIt-Anchor" href="#串操作指令"></a> 串操作指令</h3>
<p>串操作是针对数据块或字符串的操作，可实现存储器到存储器的数据传送，默认源串地址由[ESI]提供，目的串地址由[EDI]提供。<br />
<strong>地址修改方向由DF标志位决定，DF=0时为增地址方向，DF=1时为减地址方向。</strong></p>
<h4 id="重复前缀"><a class="markdownIt-Anchor" href="#重复前缀"></a> 重复前缀</h4>
<p><strong>串操作指令前面可加上自动重复前缀，实现自动重复执行串操作，重复执行次数必须由ECX指定，每次执行ECX自减1。</strong><br />
共有5条重复前缀:</p>
<ul>
<li>rep: 无其他条件重复，即ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li>
<li>repe: 相等重复，即ZF = 1 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li>
<li>repz: 为零重复，即ZF = 1 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li>
<li>repne: 不相等重复，即ZF = 0 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li>
<li>repnz: 不为零重复，即ZF = 0 &amp; ECX <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0时重复</li>
</ul>
<h4 id="movsmovsbmovswmovsd"><a class="markdownIt-Anchor" href="#movsmovsbmovswmovsd"></a> movs/movsb/movsw/movsd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">movs [<span class="hljs-built_in">edi</span>], [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将esi内容的存储器单元内容送到edi内容的存储器单元中</span><br><span class="hljs-keyword">movsb</span><span class="hljs-comment">;  将esi内容的存储器字节单元内容送到edi内容的存储器字节单元中</span><br><span class="hljs-keyword">movsw</span><span class="hljs-comment">; 将esi内容的存储器字单元内容送到edi内容的存储器字单元中</span><br><span class="hljs-keyword">movsd</span><span class="hljs-comment">; 将esi内容的存储器双字单元内容送到edi内容的存储器双字单元中</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现存储器单元的直接传送<br />
操作数要求:<br />
源操作数必须是esi寄存器间接寻址单元，目的操作数必须是edi寄存器间接寻址单元，<strong>movs必须指明操作数结构</strong><br />
对操作数影响:<br />
目的操作数会变为源操作数，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />
对标志位影响:</p>
<h4 id="cmpscmpsbcmpswcmpsd"><a class="markdownIt-Anchor" href="#cmpscmpsbcmpswcmpsd"></a> cmps/cmpsb/cmpsw/cmpsd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">cmps [<span class="hljs-built_in">esi</span>], [<span class="hljs-built_in">edi</span>]<span class="hljs-comment">; 执行[esi]-[edi]，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsb</span><span class="hljs-comment">;  计算[esi]字节单元 - [edi]字节单元，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsw</span><span class="hljs-comment">; 计算[esi]字单元 - [edi]字单元，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">cmpsd</span><span class="hljs-comment">; 计算[esi]双字单元 - [edi]双字单元，结果影响标志位但不送任何地址</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现存储器单元的直接比较并影响标志位<br />
操作数要求:<br />
源操作数必须是esi寄存器间接寻址单元，目的操作数必须是edi寄存器间接寻址单元，<strong>cmps必须指明操作数结构</strong><br />
对操作数影响:<br />
无影响，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />
对标志位影响:<br />
与<a href="#cmp">cmp</a>相同</p>
<p><strong>cmps指令常与条件重复前缀共同使用</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">mem1 <span class="hljs-built_in">db</span> <span class="hljs-number">200</span> dup(?)<span class="hljs-comment">; 定义mem1</span><br>mem1 <span class="hljs-built_in">db</span> <span class="hljs-number">200</span> dup(?)<span class="hljs-comment">; 定义mem2</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">esi</span>, mem1<span class="hljs-comment">; 取得起始地址一</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, mem2<span class="hljs-comment">; 取得起始地址二</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">200</span><span class="hljs-comment">; 比较区间长度</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">repe</span> <span class="hljs-keyword">cmpsb</span><span class="hljs-comment">; 重复寻找，直到第一个不同数据</span><br></code></pre></td></tr></table></figure>
<h4 id="scasscasbscaswscasd"><a class="markdownIt-Anchor" href="#scasscasbscaswscasd"></a> scas/scasb/scasw/scasd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">scas <span class="hljs-built_in">edi</span><span class="hljs-comment">; 执行EAX、AX、AL - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasb</span><span class="hljs-comment">; 执行AL - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasw</span><span class="hljs-comment">; 执行AX - [edi]内容，结果影响标志位但不送任何地址</span><br><span class="hljs-keyword">scasd</span><span class="hljs-comment">; 执行EAX - [edi]内容，结果影响标志位但不送任何地址</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
从edi串数据中扫描AL、AX、EAX寄存器内容数据<br />
操作数要求:<br />
必须是edi存储器操作数，<strong>scas必须指明操作数结构</strong><br />
对操作数影响:<br />
无影响，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />
对标志位影响:<br />
与<a href="#subsbbdec">sub</a>相同</p>
<p><strong>scas扫描找出对应字符所在串位置</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">buff <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ABCDEFGHIJK&#x27;</span><span class="hljs-comment">; 定义字符串</span><br>len $-buff<span class="hljs-comment">; 微指令求字符串长度</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span> buff<span class="hljs-comment">; 取得字符串起始地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;H&#x27;</span><span class="hljs-comment">; 将寻找字符放入al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, len<span class="hljs-comment">; 重复前缀次数</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">repne</span> <span class="hljs-keyword">scasb</span><span class="hljs-comment">; 重复扫描字符</span><br></code></pre></td></tr></table></figure>
<h4 id="lodslodsblodswlodsd"><a class="markdownIt-Anchor" href="#lodslodsblodswlodsd"></a> lods/lodsb/lodsw/lodsd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">lods [<span class="hljs-built_in">esi</span>]<span class="hljs-comment">; 将[esi]内容装入AL、AX、EAX</span><br><span class="hljs-keyword">lodsb</span><span class="hljs-comment">; 将[esi]内容装入AL</span><br><span class="hljs-keyword">lodsw</span><span class="hljs-comment">; 将[esi]内容装入AX</span><br><span class="hljs-keyword">lodsd</span><span class="hljs-comment">; 将[esi]内容装入EAX</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
将存储器操作数装入累加器<br />
操作数要求:<br />
必须是esi寄存器间接寻址存储器操作数，<strong>lods必须指明操作数结构</strong><br />
对操作数影响:<br />
累加器内容变为[esi]<br />
对标志位影响:<br />
无影响</p>
<p><strong>lods一般不需要重复前缀，因为累加器数据会被覆盖</strong></p>
<h4 id="stosstosbstoswstosd"><a class="markdownIt-Anchor" href="#stosstosbstoswstosd"></a> stos/stosb/stosw/stosd</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">stos [<span class="hljs-built_in">edi</span>]<span class="hljs-comment">; 将AL、AX、EAX内容送入[edi]</span><br><span class="hljs-keyword">stosb</span><span class="hljs-comment">; 将AL内容送入[edi]</span><br><span class="hljs-keyword">stosw</span><span class="hljs-comment">; 将AX内容送入[edi]</span><br><span class="hljs-keyword">stosd</span><span class="hljs-comment">; 将EAX内容送入[edi]</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
将累加器内容送入存储器操作数<br />
操作数要求:<br />
必须是edi寄存器间接寻址存储器操作数，<strong>stos必须指明操作数结构</strong><br />
对操作数影响:<br />
存储器操作数变为累加器内容，<strong>确定串操作方向后添加重复前缀会自动移动地址</strong><br />
对标志位影响:<br />
无影响</p>
<p><strong>stos常用于将内存某个区域置同样的值</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">buff <span class="hljs-built_in">db</span> <span class="hljs-number">20</span> dup(?)<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">F4H</span><span class="hljs-comment">; 需存储值</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">edi</span>, buff<span class="hljs-comment">; 取得偏移地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">20</span><span class="hljs-comment">; 区域长度</span><br><span class="hljs-keyword">cld</span><span class="hljs-comment">; 设置为地址增方向</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">stosb</span><span class="hljs-comment">; 重复存储</span><br></code></pre></td></tr></table></figure>
<h3 id="程序控制指令"><a class="markdownIt-Anchor" href="#程序控制指令"></a> 程序控制指令</h3>
<p>程序控制指令一般没有操作数或只有单个操作数，且一般对标志位没有影响。<strong>其主要通过标志位控制程序执行的方向。</strong></p>
<h4 id="jmp"><a class="markdownIt-Anchor" href="#jmp"></a> jmp</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> oprd<br></code></pre></td></tr></table></figure>
<p>功能:<br />
跳转到距离jmp指令下一条指令oprd字节的指令。如<a href="#%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%AF%BB%E5%9D%80">转移地址寻址</a>中说的，有两个寻址方式，当采用直接寻址的方式时，称为<strong>短距离转移</strong>，jmp指令仅2字节长，当采用间接寻址方式时可按转移地址是否仍在本代码段分为<strong>近转移</strong>和<strong>远转移</strong>，jmp指令长为5字节<br />
操作数要求:<br />
操作数可以为标号，由汇编器进行翻译为8位的位移量或32位的位移量，也可为寄存器间接寻址的存储器单元<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="jcjncjojnojzjnzjpjnpjcxzjcxnz"><a class="markdownIt-Anchor" href="#jcjncjojnojzjnzjpjnpjcxzjcxnz"></a> jc/jnc/jo/jno/jz/jnz/jp/jnp/jcxz/jcxnz</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">jc label</span><span class="hljs-comment">; CF=1时跳转</span><br><span class="hljs-symbol">jnc label</span><span class="hljs-comment">; CF=0时跳转</span><br><span class="hljs-symbol">jo label</span><span class="hljs-comment">; OF=1时跳转</span><br><span class="hljs-symbol">jno label</span><span class="hljs-comment">; OF=0时跳转</span><br><span class="hljs-symbol">jz label</span><span class="hljs-comment">; ZF=1时跳转</span><br><span class="hljs-symbol">jnz label</span><span class="hljs-comment">; ZF=0时跳转</span><br><span class="hljs-symbol">jp label</span><span class="hljs-comment">; PF=1时跳转</span><br><span class="hljs-symbol">jnp label</span><span class="hljs-comment">; PF=0时跳转</span><br><span class="hljs-symbol">jcxz label</span><span class="hljs-comment">; CX或ECX=0时跳转</span><br><span class="hljs-symbol">jcxnz label</span><span class="hljs-comment">; CX或ECX不为0时跳转</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
根据一个标志位或CX、ECX决定是否跳转<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="jajaejbjbejgjgejljle"><a class="markdownIt-Anchor" href="#jajaejbjbejgjgejljle"></a> ja/jae/jb/jbe/jg/jge/jl/jle</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">ja label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jae label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jb label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jbe label</span><span class="hljs-comment">; 根据CF和OF状态决定是否跳转</span><br><span class="hljs-symbol">jg label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jge label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jl label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br><span class="hljs-symbol">jle label</span><span class="hljs-comment">; 根据OF和SF状态决定是否跳转</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
见<a href="#cmp">cmp</a><br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="looploopzloopnz"><a class="markdownIt-Anchor" href="#looploopzloopnz"></a> loop/loopz/loopnz</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">loop label</span><span class="hljs-comment">; ECX不为零</span><br><span class="hljs-keyword">loopz</span>(<span class="hljs-keyword">loope</span>) label<span class="hljs-comment">; ECX为不为零且ZF=1，则跳转label</span><br><span class="hljs-keyword">loopnz</span>(<span class="hljs-keyword">loopne</span>) label<span class="hljs-comment">; ECX不为零且ZF=0，则跳转label</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
根据ECX内容和ZF决定是否跳转<br />
操作数要求:<br />
转移范围为当前EIP内容的-128~+127内<br />
对操作数影响:<br />
无要求<br />
对标志位影响:<br />
无影响</p>
<h4 id="call"><a class="markdownIt-Anchor" href="#call"></a> call</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">call</span> subprocess<span class="hljs-comment">; 调用子过程</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
调用子过程，等价于以下代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 将断点地址压栈</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eip</span> subprocess<span class="hljs-comment">; 将子过程开始地址放入EIP</span><br></code></pre></td></tr></table></figure>
<p>操作数要求:<br />
subprocess必须是子过程的开始地址，汇编器会代替程序员进行这件事<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="ret"><a class="markdownIt-Anchor" href="#ret"></a> ret</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ret</span><span class="hljs-comment">; 从堆栈中弹出断点地址，返回原程序</span><br><span class="hljs-keyword">ret</span> n<span class="hljs-comment">; 从堆栈中n个数据，其中第n个是断点地址，返回原程序</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
在子程序中从堆栈中弹出断点，以返回原程序，其功能等价于以下代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">ret</span> =&gt;<br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 从堆栈中弹出断点地址送到EIP中</span><br><span class="hljs-keyword">ret</span> n =&gt;<br><span class="hljs-keyword">pop</span> oprd1<span class="hljs-comment">; 弹出第一个参数</span><br><span class="hljs-keyword">pop</span> oprd2<span class="hljs-comment">; 弹出第二个参数</span><br>·<br>·<br>·<br><span class="hljs-keyword">pop</span> oprdn-<span class="hljs-number">1</span><span class="hljs-comment">; 弹出第n-1个参数</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">eip</span><span class="hljs-comment">; 弹出断点地址送到EIP中</span><br></code></pre></td></tr></table></figure>
<p>操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="intintoiret"><a class="markdownIt-Anchor" href="#intintoiret"></a> int/into/iret</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> n<span class="hljs-comment">; 程序发出中断类型号为n的软中断请求</span><br><span class="hljs-keyword">into</span><span class="hljs-comment">; 程序发出溢出中断请求</span><br><span class="hljs-keyword">iret</span><span class="hljs-comment">; 中断服务程序发出，用来恢复断点和标志寄存器内容</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
int: 给予程序发出软中断请求的能力<br />
into: 检测是否溢出，如果溢出(OF=1)即等价于<code>int 4</code>发出一个类型号为4的中断请求，如果<strong>未溢出则不做任何操作</strong><br />
iret: 中断服务程序结束的固定流程指令(恢复现场、开中断)<br />
操作数要求:<br />
<strong>int: 操作数为立即数，且范围必须在0~255(X86下中断向量表只有256个表项)</strong><br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h3 id="处理器控制指令"><a class="markdownIt-Anchor" href="#处理器控制指令"></a> 处理器控制指令</h3>
<p><b>处理器一般通过标志位来控制指令的执行方式，因此控制指令一般可以直接更改标志位而无需运算来实现(如通过and、or实现CF和OF清零)，或直接通过指令来实现处理器工作情况的控制，如暂停、让出总线使用权等。</b></p>
<h4 id="clcstccmc"><a class="markdownIt-Anchor" href="#clcstccmc"></a> clc/stc/cmc</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">clc</span><span class="hljs-comment">; CF复位</span><br><span class="hljs-keyword">stc</span><span class="hljs-comment">; CF置位</span><br><span class="hljs-keyword">cmc</span><span class="hljs-comment">; CF取反</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现对CF的直接操作<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
更改CF值</p>
<h4 id="cldstd"><a class="markdownIt-Anchor" href="#cldstd"></a> cld/std</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cld</span><span class="hljs-comment">; DF复位</span><br><span class="hljs-keyword">std</span><span class="hljs-comment">; DF置位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现对DF的直接操作，以进行对串操作的方向控制<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
更改CF值</p>
<h4 id="clisti"><a class="markdownIt-Anchor" href="#clisti"></a> cli/sti</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cli</span><span class="hljs-comment">; IF复位</span><br>stu<span class="hljs-comment">; IF置位</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
实现对IF的直接操作，用以控制处理器的中断屏蔽状态，一般在中断处理时使用<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
更改IF值</p>
<h4 id="nop"><a class="markdownIt-Anchor" href="#nop"></a> nop</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">nop</span><span class="hljs-comment">; 不执行任何操作，使处理器空闲一个指令周期(3个时钟周期)</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
使处理器空闲一个指令周期(3个时钟周期)<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="hlt"><a class="markdownIt-Anchor" href="#hlt"></a> hlt</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">hlt</span><span class="hljs-comment">; 使 CPU 处于暂停状态，不执行任何操作，等待复位信号或下一次外部中断的到</span><br>来<br></code></pre></td></tr></table></figure>
<p>功能:<br />
阻塞CPU，等待中断请求或多机系统的同步<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="wait"><a class="markdownIt-Anchor" href="#wait"></a> wait</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">wait<span class="hljs-comment">; 使 CPU 处于等待状态，不执行任何操作。 CPU 将等待外部中断发生，如果有中</span><br>断发生，则完成中断任务后仍返回 WAIT 指令继续等待。<br></code></pre></td></tr></table></figure>
<p>功能:<br />
使CPU等待，以使得CPU与协处理器或外部设备同步工作<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="esc"><a class="markdownIt-Anchor" href="#esc"></a> esc</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">esc oprd, src<span class="hljs-comment">; CPU让出总线使得src内容可以到数据总线上，从而将存储器中的指</span><br>令或数据传送给其他处理器<br></code></pre></td></tr></table></figure>
<p>功能:<br />
CPU让出总线，使得协处理器能够使用总线进行数据传送<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无影响<br />
对标志位影响:<br />
无影响</p>
<h4 id="lock前缀"><a class="markdownIt-Anchor" href="#lock前缀"></a> lock前缀</h4>
<p>格式:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">lock</span> op<span class="hljs-comment">; 使得op指令在执行期间封锁总线(独占总线)</span><br></code></pre></td></tr></table></figure>
<p>功能:<br />
保证指令独占总线，防止协处理器破坏数据<br />
操作数要求:<br />
无要求<br />
对操作数影响:<br />
无要求<br />
对标志位影响:<br />
无要求</p>
<h2 id="代码参考"><a class="markdownIt-Anchor" href="#代码参考"></a> 代码参考</h2>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127518/4665720">代码参考</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Assembly-Language/">Assembly Language</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/08/X86%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">X86汇编语法</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/05/8086%E4%B8%8EIA32%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/">
                        <span class="hidden-mobile">8086与IA32微处理器</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Thm-lab/blog_commit');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
