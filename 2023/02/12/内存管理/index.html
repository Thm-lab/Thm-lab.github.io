

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Thm">
  <meta name="keywords" content="谭泓旻">
  
    <meta name="description" content="内存管理 内存管理: 关注内存和外存之间的信息流的组织，简单来说就是关注进程在什么时候将进程放入内存和内存中如何放置  基本内存管理 基本内存管理指不使用虚存技术，也不使用高速存储技术(cache)，仅有内存和外存作为存储设备时，OS对内存的管理  程序的加载与链接 高级语言由源代码转换为进程需要3个步骤:  编译: 由编译器将源代码转为机器指令，其中源代码会被编译为多个模块(某些库文件是单独模">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Thm&#39;s blog">
<meta property="og:description" content="内存管理 内存管理: 关注内存和外存之间的信息流的组织，简单来说就是关注进程在什么时候将进程放入内存和内存中如何放置  基本内存管理 基本内存管理指不使用虚存技术，也不使用高速存储技术(cache)，仅有内存和外存作为存储设备时，OS对内存的管理  程序的加载与链接 高级语言由源代码转换为进程需要3个步骤:  编译: 由编译器将源代码转为机器指令，其中源代码会被编译为多个模块(某些库文件是单独模">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/absolutely_load.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/static_load.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dynamic_load.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/partition.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/fixed_partition.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dynamic_partition.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/dynamic_partition_example.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/partner_system.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page.jpg">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/logical_address.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_mapping.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/logical_address_2.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/segment_mapping.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_segment.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/virtual_page_table_item.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/two_level_page.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/virtual_page_address.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/two_level_page_mapping.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/two_level_page_example.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hash_page.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/TLB.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_size.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/normal_page_size.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_segment_combination.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page_segment_combination_mapping.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/OPT.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/LRU.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FIFO.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Clock.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/efficiency.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/residence_replace.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/working_set.png">
<meta property="og:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/time_working_set.png">
<meta property="article:published_time" content="2023-02-12T14:25:42.000Z">
<meta property="article:modified_time" content="2023-02-13T13:22:18.485Z">
<meta property="article:author" content="Thm">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/02/12/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/absolutely_load.png">
  
  
  <title>内存管理 - Thm&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>life and study balance</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/banner.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="内存管理">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Thm
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-12 22:25" pubdate>
        February 12, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      73 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">内存管理</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：February 13, 2023 pm
                
              </p>
            
            <div class="markdown-body">
              <h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<p>内存管理: <strong>关注内存和外存之间的信息流的组织</strong>，简单来说就是关注<strong>进程在什么时候将进程放入内存和内存中如何放置</strong></p>
<h2 id="基本内存管理"><a class="markdownIt-Anchor" href="#基本内存管理"></a> 基本内存管理</h2>
<p>基本内存管理指不使用虚存技术，也不使用高速存储技术(cache)，仅有内存和外存作为存储设备时，OS对内存的管理</p>
<h3 id="程序的加载与链接"><a class="markdownIt-Anchor" href="#程序的加载与链接"></a> 程序的加载与链接</h3>
<p>高级语言由源代码转换为进程需要<strong>3个步骤</strong>:</p>
<ul>
<li><strong>编译</strong>: 由<strong>编译器将源代码转为机器指令</strong>，其中源代码会被<strong>编译为多个模块</strong>(某些库文件是单独模块)</li>
<li><strong>链接</strong>: 将编译出的<strong>多个模块链接到一起形成加载模块(包含完整程序和数据模块)</strong></li>
<li><strong>加载</strong>: 由<strong>加载程序将加载模块装入内存</strong></li>
</ul>
<h4 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h4>
<p>链接的方式有<strong>3种</strong>:</p>
<ul>
<li>静态链接</li>
<li>加载时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h5 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h5>
<p>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个<strong>完整的装配模块</strong>(又称执行模块)，以后不再拆开<br />
静态链接即将所有目标模块和库函数<strong>打包为一个模块</strong>，在打包时链接器需要:</p>
<ul>
<li><strong>修改相对地址</strong>: 由编译程序产生的所有目标模块中，使用的都是相对地址，其起始地址都为0，在<strong>链接成一个加载模块时修改模块的相对地址</strong></li>
<li><strong>变换外部引用地址</strong>: 将每个模块中所用的<strong>外部调用符号也都变换为相对地址(加载模块内部的相对地址)</strong></li>
</ul>
<p>缺点:</p>
<ul>
<li><strong>不利于代码共享</strong>: 不同应用使用同一个模块，但该模块被多次分别打包入不同加载模块</li>
<li><strong>不利于模块的独立升级</strong>: 每次对某个目标模块的修改升级，都要打开整个加载模块</li>
<li><strong>浪费存储空间和处理器时间</strong>: 可能链接一些不会执行的模块</li>
</ul>
<h5 id="加载时动态链接"><a class="markdownIt-Anchor" href="#加载时动态链接"></a> 加载时动态链接</h5>
<p>待加载的模块在加载内存时，如果该模块中有到外部模块的引用，<strong>加载程序将查找这些模块并加载内存</strong>，并把这些引用修改为相对应用程序模块开始处的相对地址<br />
<strong>加载时动态链接的模块链接由加载程序完成，链接器只完成了对外部模块引用的声明</strong></p>
<p>优点:</p>
<ul>
<li><strong>便于各个模块的独立升级</strong>: 重新编译新模块后<strong>将加载模块重新加载</strong>即可</li>
<li><strong>便于实现模块的共享</strong>: 共享的模块只需在内存中保留一份即可</li>
</ul>
<p>缺点:</p>
<ul>
<li><strong>浪费存储空间和处理器时间</strong>: 可能链接一些不会执行的模块</li>
<li><strong>模块加载后不能移动位置</strong>: 因为仅在加载时重定位，若移动则地址错误</li>
</ul>
<h5 id="运行时动态链接"><a class="markdownIt-Anchor" href="#运行时动态链接"></a> 运行时动态链接</h5>
<p>在程序执行中需要某目标模块时，<strong>由操作系统去找到该模块并将之加载内存</strong>，随后把它链接到调用者模块上，<strong>典型的就是Windows下dll文件</strong></p>
<p>凡在执行过程中未被用到的目标模块，不会被调入内存和被链接到加载模块上，这样不仅可<strong>加快程序的加载过程</strong>，而且<strong>可节省大量的内存空间</strong>，并且<strong>支持分段系统</strong>，是主流做法</p>
<h4 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h4>
<p>加载程序需要<strong>将可加载模块装入内存</strong>、<strong>将执行文件中的逻辑地址转化为内存物理地址的过程</strong></p>
<p>其中地址映射建立方式有<strong>3种</strong>:</p>
<ul>
<li>绝对加载方式</li>
<li>静态重定位</li>
<li>动态重定位</li>
</ul>
<h5 id="绝对加载"><a class="markdownIt-Anchor" href="#绝对加载"></a> 绝对加载</h5>
<p><strong>程序中的逻辑地址与实际内存地址完全相同</strong>，因此不同模块的地址在编码时就需要确定，由程序员进行完全掌控，在汇编语言中较为常见<br />
<img src="absolutely_load.png" srcset="/img/loading.gif" lazyload alt="绝对加载" /></p>
<p>优点: <strong>实现简单</strong>，无须进行逻辑地址到物理地址的变换</p>
<p>缺点:</p>
<ul>
<li>程序每次必须装入<strong>同一内存区</strong></li>
<li>程序员必须事先了解内存的使用情况，根据内存情况确定程序的逻辑地址</li>
<li>不适于多道程序系统</li>
</ul>
<h5 id="静态重定位"><a class="markdownIt-Anchor" href="#静态重定位"></a> 静态重定位</h5>
<p><strong>地址映射在程序加载时进行，以后不再更改程序地址</strong><br />
<img src="static_load.png" srcset="/img/loading.gif" lazyload alt="静态重定位" /></p>
<p>优点: 易实现，<strong>无需硬件支持</strong></p>
<p>缺点: 程序重定位后就<strong>不能移动</strong>，因而<strong>不能重新分配内存</strong>，不利于内存的有效利用</p>
<h5 id="动态重定位"><a class="markdownIt-Anchor" href="#动态重定位"></a> 动态重定位</h5>
<p>程序的地址转换不是在加载时进行，而是在程序运行时动态进行，在运行时<strong>通过重定位寄存器内的起始物理地址和指令或数据的逻辑地址计算其物理地址</strong><br />
<img src="dynamic_load.png" srcset="/img/loading.gif" lazyload alt="动态重定位" /></p>
<p>优点:</p>
<ul>
<li><strong>程序不必连续存放在内存中</strong>，可分散存储，<strong>可移动</strong></li>
<li>便于共享</li>
<li>有利于紧凑、碎片问题的解决</li>
</ul>
<p>缺点:</p>
<ul>
<li>需要硬件支持，实现存储管理的软件算法比较复杂</li>
<li>同一地址，可能多次转换</li>
</ul>
<h3 id="内存管理的需求"><a class="markdownIt-Anchor" href="#内存管理的需求"></a> 内存管理的需求</h3>
<h4 id="重定位"><a class="markdownIt-Anchor" href="#重定位"></a> 重定位</h4>
<p>因为程序员事先并不知道在某个程序执行期间会有其他哪些程序驻留在内存中，也不知道下一次装入内存的物理地址，因此需要将程序写为逻辑地址来表明程序功能，而OS需要将程序的逻辑地址转换为内存中的物理地址才能对程序进行执行<br />
而<strong>将逻辑地址转为物理地址就叫重定位</strong></p>
<h4 id="保护"><a class="markdownIt-Anchor" href="#保护"></a> 保护</h4>
<p>指: <strong>进程以外的其他进程中的程序不能未经授权地访问</strong>(进行读操作或写操作)该进程的<strong>内存单元</strong><br />
因此需要既支持重定位也支持保护的<strong>硬件</strong></p>
<h4 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h4>
<p>多个进程正在执行同一程序时，<strong>允许每个进程访问该程序的同一个副本</strong>，要比让每个进程有自己独立的副本更有利<br />
因此需要既支持重定位也支持共享的机制</p>
<h4 id="逻辑组织"><a class="markdownIt-Anchor" href="#逻辑组织"></a> 逻辑组织</h4>
<p>内存被组织成一维线性空间，而没有外存的存在，在编写程序时不需要管理内外存交换</p>
<h4 id="物理组织"><a class="markdownIt-Anchor" href="#物理组织"></a> 物理组织</h4>
<p>而真实的物理组织是内外存的差异的，OS需要满足逻辑组织的需求，将两层存储结构间进行数据移动</p>
<h3 id="内存分区"><a class="markdownIt-Anchor" href="#内存分区"></a> 内存分区</h3>
<p>内存管理的主要操作是处理器把程序加载内存中执行<br />
在基本内存管理中主要有4种分区方法，加上虚存技术后共6种分区方法，但总的来说只有<strong>2种分区思想</strong>: <strong>固定分区(分页是固定分区的升级思想)和动态分区(分段是动态分区的升级思想)</strong><br />
<img src="partition.png" srcset="/img/loading.gif" lazyload alt="分区方法" /></p>
<h4 id="固定分区"><a class="markdownIt-Anchor" href="#固定分区"></a> 固定分区</h4>
<p>固定分区的思想: 将除操作系统占用的内存，<strong>按照固定的大小分为不同的区域</strong>，<strong>区域的大小可以是均匀的也可以是不均的</strong><br />
<img src="fixed_partition.png" srcset="/img/loading.gif" lazyload alt="固定分区" /></p>
<p>如果每个区域大小相同:</p>
<ul>
<li><strong>程序可能太大而不能放到一个分区中</strong></li>
<li>内存的利用率非常低，因为<strong>小程序占用了比需求大的空间</strong>，从而产生<strong>内部碎片</strong>(区域内的空闲空间)</li>
</ul>
<p>不等大分区可以缓解内部碎片问题，同样如果将区域划分为很小，并且将进程也划分为与区域一样小的块，则可以将多个进程块装入不同区域(<strong>分页思路的来源</strong>)</p>
<p>固定分区存在的问题: 分区的数量在系统生成阶段已经确定，因而<strong>限制了系统活动(未挂起)进程的数量</strong></p>
<h4 id="动态分区"><a class="markdownIt-Anchor" href="#动态分区"></a> 动态分区</h4>
<p>动态分区就是<strong>分配与进程需求完全一致的空闲内存空间</strong>，因此分区大小和数量不固定<br />
分段思路的来源: 将进程分为不同的模块，每个模块都由OS进行动态分区，这一个分区就是段</p>
<p><img src="dynamic_partition.png" srcset="/img/loading.gif" lazyload alt="动态分区" /><br />
动态分区方法在内存中产生越来越多的<strong>外部碎片</strong>(不同分区间的内存区域，但是由于太小而无法满足任何一个进程的需求从而浪费)</p>
<p>外部碎片的解决方法: 压缩技术: 在一段时间后或内存不能找出任何一块区域来满足需求时，<strong>OS将所有进程进行移动</strong>，将外部碎片全部清除掉从而得到新的一大块空间</p>
<h5 id="匹配算法"><a class="markdownIt-Anchor" href="#匹配算法"></a> 匹配算法</h5>
<p>动态分区会产生很多块空闲的空间，如果很多空间都能满足需求，<strong>如何选择哪块空间来满足需求</strong>则需要匹配算法</p>
<p><strong>首次匹配</strong><br />
思想: <strong>从头开始扫描内存，选择大小足够的第一个可用块</strong><br />
评价:</p>
<ul>
<li>为大作业分配大的内存空间创造条件</li>
<li>内存前端出现很多小的空闲分区，且每次查找都要经过这些分区</li>
</ul>
<p><strong>循环匹配</strong><br />
思想: 从<strong>上一次放置的位置开始</strong>扫描内存，选择第一个大小足够的可用块<br />
评价:</p>
<ul>
<li>比首次匹配性能差，常常在内存末尾分配空间，导致空闲的分区分布均匀</li>
<li>缺少大的空闲块，需要更多次数紧凑</li>
</ul>
<p><strong>最佳匹配</strong><br />
思想: <strong>选择空间大小与需求最接近的空闲块分配</strong><br />
评价:</p>
<ul>
<li>产生的外部碎片都很小</li>
<li>内存中形成很多小到无法满足任何分配需求的块，需要更频繁的进行内存压缩</li>
</ul>
<p><strong>最差匹配</strong><br />
思想: <strong>选择满足需求的最大的空闲分区分配</strong><br />
评价:</p>
<ul>
<li>每次分配留下的空闲空间较大，便于再次利用</li>
<li>大的空间不容易保留，对大作业不利</li>
</ul>
<p><img src="dynamic_partition_example.png" srcset="/img/loading.gif" lazyload alt="匹配算法示例" /></p>
<h4 id="伙伴系统"><a class="markdownIt-Anchor" href="#伙伴系统"></a> 伙伴系统</h4>
<p>固定分区方案限制了活跃进程的数量。并且，如果分区大小与进程大小不匹配，则内存空间的利用率非常低<br />
动态分区方案维护复杂，并且引入了紧凑的额外开销</p>
<p>因此出现了<strong>伙伴系统</strong>，其<strong>结合了固定分区与动态分区思想</strong>，<strong>每一次分区都是固定分区，但分的大小是根据需求来定的</strong></p>
<p>伙伴系统: 内存空间被视为一个大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span>的块，每次分配的块的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>，L ≤ K ≤ U，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>L</mi></msup></mrow><annotation encoding="application/x-tex">2^L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span></span></span></span> = 分配的<strong>最小块的大小</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>U</mi></msup></mrow><annotation encoding="application/x-tex">2^U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span></span></span></span></span></span></span></span> =分配的<strong>最大块的大小</strong></p>
<p><img src="partner_system.png" srcset="/img/loading.gif" lazyload alt="伙伴系统" /></p>
<h3 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h3>
<p>分页: <strong>将内存划分成大小固定、相等的块(称为页框)，且块相对较小，进程也划分成同样大小的块(称为页)</strong><br />
页表: 操作系统为<strong>每个进程维护一个页表</strong>，<strong>页表固定存放在内存中</strong>，起始地址由PCB进行保存，并且由页表寄存器存放当前运行进程的页表的起始地址</p>
<p><img src="page.jpg" srcset="/img/loading.gif" lazyload alt="页表" /><br />
页表中记录了从逻辑地址到物理地址转换需要的<strong>对应关系——页号与页框号的映射</strong><br />
<img src="logical_address.png" srcset="/img/loading.gif" lazyload alt="分页逻辑地址" /><br />
逻辑地址由<strong>页号</strong>和<strong>页内偏移</strong>组成，在<strong>进行逻辑地址转为物理地址过程中</strong>，根据页面将页号映射为页框号即可<br />
<img src="page_mapping.png" srcset="/img/loading.gif" lazyload alt="逻辑地址转物理地址" /></p>
<p><strong>逻辑地址的计算</strong><br />
若给定一个<strong>逻辑地址空间中的地址为A</strong>，<strong>页面的大小为L</strong>，则<strong>页号P</strong>和<strong>页内地址d</strong>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mi>A</mi><mi>L</mi></mfrac><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mi>A</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>l</mi><mtext> </mtext><mi>L</mi></mrow><annotation encoding="application/x-tex">P = \lfloor \frac{A}{L} \rfloor, d = A \: mol \: L
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">L</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p>
<p>如: 某系统的页面大小为1KB，设A = 2170 B，试计算其页号P与页内地址d</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mn>2170</mn><mn>1024</mn></mfrac><mo stretchy="false">⌋</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo>=</mo><mn>2170</mn><mtext> </mtext><mi>m</mi><mi>o</mi><mi>l</mi><mtext> </mtext><mn>1024</mn><mo>=</mo><mn>122</mn></mrow><annotation encoding="application/x-tex">P = \lfloor \frac{2170}{1024} \rfloor = 2, d = 2170 \: mol \: 1024 = 122
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">7</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">2</span></span></span></span></span></p>
<p>将结果转为二进制: 2 = <code>00 0010</code>，122 = <code>00 0111 1010</code>，因此逻辑地址为<code>0000 1000 0111 1010</code></p>
<p>分页的<strong>优点</strong>:</p>
<ul>
<li>存在页内碎片，但碎片相对较小，<strong>内存利用率较高</strong></li>
<li>实现了离散分配</li>
<li>无外部碎片</li>
</ul>
<p>分页的<strong>缺点</strong>:</p>
<ul>
<li>需要专门的硬件支持，尤其是<strong>快表(页面项放在cache中)</strong></li>
<li>不支持动态链接，不易实现共享</li>
</ul>
<h3 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h3>
<p>分段: 将程序划分为几段，<strong>每段长度可以不相等</strong>但有最长限制，每个段都从0开始编址，并<strong>占用一段连续的地址空间</strong><br />
段表: <strong>记录逻辑段和物理段的映射关系</strong></p>
<p><img src="segment.png" srcset="/img/loading.gif" lazyload alt="段表" /><br />
段表中同样也记录了记录了从逻辑地址到物理地址转换需要的<strong>对应关系——段号与段首址的映射关系</strong>，但段表比页表多了一个项，段长，<strong>如果段内偏移大于段长则出现了地址错误</strong><br />
<img src="logical_address_2.png" srcset="/img/loading.gif" lazyload alt="分段逻辑地址" /><br />
逻辑地址由<strong>段号</strong>和<strong>段内偏移</strong>组成，在<strong>进行逻辑地址转为物理地址过程中</strong>，根据段号找到对应段首址，如果段内偏移小于段长，则将<strong>段首址加上段内偏移即可得到物理地址</strong>(相加时段内偏移高位补零)<br />
<img src="segment_mapping.png" srcset="/img/loading.gif" lazyload alt="逻辑地址转物理地址" /></p>
<p>分段的<strong>优点</strong>:</p>
<ul>
<li>便于程序模块化设计</li>
<li>便于动态链接</li>
<li>便于保护和共享</li>
<li>无内部碎片</li>
</ul>
<p>分段的<strong>缺点</strong>:</p>
<ul>
<li>地址转换需要硬件的支持——<strong>段表寄存器</strong></li>
<li>分段的最大尺寸受到主存可用空间的限制(可用虚存技术)</li>
<li>有外部碎片</li>
</ul>
<h3 id="分段与分页的比较"><a class="markdownIt-Anchor" href="#分段与分页的比较"></a> 分段与分页的比较</h3>
<ul>
<li><strong>页是信息的物理单位</strong>，分页的目的是实现离散分配，减少内存的外部碎片，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是<strong>信息的逻辑单位</strong>，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要</li>
<li><strong>页的大小固定且由系统决定</strong>，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而<strong>段的长度却不固定</strong>，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li>
<li><strong>分页的作业地址空间是一维的</strong>，即单一的线性地址空间，程序员只需利用一个记忆符(逻辑地址)，即可表示一个地址；而<strong>分段的作业地址空间则是二维的</strong>，程序员在标识一个地址时，既需给出<strong>段号</strong>，又需给出<strong>段内地址</strong></li>
<li><strong>分页存储管理系统不易实现共享，不支持运行时动态链接，而分段系统易于实现共享和动态链接</strong></li>
</ul>
<h2 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h2>
<p><strong>虚拟内存</strong>: 在存储分配机制中，辅<strong>存可被看作主存的一部分来完成寻址</strong>，<strong>程序使用的地址与内存物理存储的地址不同</strong>，程序生成的地址会自动转换为物理地址。虚拟存储的大小受计算机系统寻址机制和可用辅存容量的限制，<strong>而不受主存实际大小限制</strong><br />
<strong>虚拟地址</strong>: 在虚拟内存中分配给某一位置的地址，它使得该位置可被访问，就好像是主存的一部分那样，有时也称为逻辑地址(与基本内存管理逻辑地址相同)<br />
<strong>虚拟地址空间</strong>: 分配给进程的<strong>虚拟存储</strong><br />
<strong>地址空间</strong>: 用于某进程的<strong>内存地址范围</strong><br />
<strong>实地址(物理地址)</strong>: <strong>内存中</strong>存储位置的地址</p>
<p><img src="page_segment.png" srcset="/img/loading.gif" lazyload alt="分页和分段的特点" /></p>
<p>虚存技术最重要的是<span style="color:#ff562b"><b>无需将全部程序装入内存，而是只装入部分，其他部分在需要使用时再装入</b></span></p>
<p><strong>抖动: 即将要用到的块被换出，系统又得很快将它取回，导致页面被频繁地换入换出，缺页率急剧增加</strong><br />
当内存空间几乎被进程块占据时，每读取一块，必须把另一块换出，<strong>如果出现抖动，处理器的大部分时间都用于交换而非执行指令</strong>，因此需要选择合适的<a href="#%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5">置换策略</a></p>
<h3 id="虚存的硬件与控制结构"><a class="markdownIt-Anchor" href="#虚存的硬件与控制结构"></a> 虚存的硬件与控制结构</h3>
<h4 id="局部性原理虚存的合理性"><a class="markdownIt-Anchor" href="#局部性原理虚存的合理性"></a> 局部性原理(虚存的合理性)</h4>
<p><strong>局部性原理</strong>: 存储器的访问呈簇(cluster)性(簇：一组程序或数据的集合)，在很长一段时间内，使用的簇会发生变化，但<strong>在很短的时间内，处理器基本上只与固定的簇打交道</strong></p>
<p><strong>如果发生缺页则进行中断，将页面从外存中调入内容</strong></p>
<p>解释:</p>
<ul>
<li>描述了进程中程序和数据引用的集簇倾向</li>
<li>在很短的时间内仅需要进程的一部分块</li>
<li>对将来可能会访问的块进行猜测，以避免抖动</li>
</ul>
<h4 id="虚拟分页"><a class="markdownIt-Anchor" href="#虚拟分页"></a> 虚拟分页</h4>
<p>虚拟内存通常与使用分页的系统联系在一起，并且分页的虚存方案中，<strong>页表项变得更复杂</strong></p>
<p>分页逻辑地址仍然为<strong>页号</strong>和<strong>页内偏移</strong>组成，其转换方法也仍然为将页号映射为页框号，<strong>但页表项发生了改变</strong><br />
<img src="virtual_page_table_item.png" srcset="/img/loading.gif" lazyload alt="页表项" /></p>
<ul>
<li><strong>P</strong>: <strong>存在位</strong>，表明对应的页是否在内存</li>
<li><strong>M</strong>: <strong>修改位</strong>，表明相应页上次装入内存到现在是否修改过</li>
</ul>
<p>然而虚拟分页的逻辑地址转为物理地址的过程仍与<a href="#%E5%88%86%E9%A1%B5">基本内存</a>中相同</p>
<h4 id="多级分页"><a class="markdownIt-Anchor" href="#多级分页"></a> 多级分页</h4>
<p>每个进程一个页表，如果<strong>进程的逻辑地址空间大，则页表庞大</strong>，例如每个进程虚存空间可达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>=4GB，若每个页大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>=1K字节，则需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个页表项，每个页表项为4字节，页表大小则总共需要4MB</p>
<p>因此可以将页表再次进行分级，<strong>次页表也放置于虚存中</strong>，可以减少对内存的占用，<strong>只有顶层页表放置在内存中以便查询</strong><br />
<img src="two_level_page.png" srcset="/img/loading.gif" lazyload alt="两级页表" /><br />
<strong>因此逻辑地址的含义也发生了变化，高10位作为页表页号，中间10位作为页号，低12位作为页内偏移</strong><br />
<img src="virtual_page_address.png" srcset="/img/loading.gif" lazyload alt="两级页表逻辑地址" /></p>
<p>在逻辑地址转为物理地址时，则需要<strong>先根据根页表将页表页号转为页表的物理地址</strong>，再<strong>从页表中将页号转为页框号</strong>，最后得到物理地址<br />
<img src="two_level_page_mapping.png" srcset="/img/loading.gif" lazyload alt="两级页表逻辑地址转为物理地址" /></p>
<p>例题:<br />
32位逻辑地址空间、4KB页面、4B页表项、求逻辑地址4197721的物理地址？<br />
<img src="two_level_page_example.png" srcset="/img/loading.gif" lazyload alt="根页表与页表" /><br />
首先将<strong>逻辑地址</strong>4197721转为二进制<code>0000000001 0000000000 110101011001</code>，高10位为页表页号=1，中间10位为页表号为0，低12位为页内偏移<br />
查表得，页表页号1转202，在202的页表内查询，页表号0转为505，将结果转为二进制505=<code>0111111001</code>，因此结果为<code>00000000000111111001 110101011001</code>=<strong>物理地址</strong>2071897</p>
<p><strong>注意最后的505是高22位！(因为505是页框号，是代表除页面偏移地址外的所有物理地址)</strong></p>
<p>当两级页表也十分大时，可以<strong>再次分级</strong>，形成多级页表，原理与二级页表相同，<strong>但会增加额外的存储空间，页表的级数越多，地址转换过程越复杂，转换的速度也越慢</strong></p>
<h4 id="倒置页表"><a class="markdownIt-Anchor" href="#倒置页表"></a> 倒置页表</h4>
<p><strong>倒置页表</strong>: 虚拟地址的<strong>页号部分使用一个简单的散列函数(hash)映射到散列表中，即将页号hash成页框号</strong><br />
页表结构称为倒排的原因是，它<strong>使用页框号而非虚拟页号来索引页表项</strong><br />
无论有多少进程、支持多少虚拟页，页表都只需要实存中的一个固定部分(即页框数量的部分)<br />
<img src="hash_page.png" srcset="/img/loading.gif" lazyload alt="倒置页表" /></p>
<h4 id="tlb快表"><a class="markdownIt-Anchor" href="#tlb快表"></a> TLB(快表)</h4>
<p>将一部分页表项放入cache中，以便快速使用<br />
具体访存在<a target="_blank" rel="noopener" href="https://thm-lab.github.io/2022/06/12/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%8Bcpu%E8%AE%BF%E5%AD%98%E8%BF%87%E7%A8%8B">组成原理</a>中有所介绍<br />
<img src="TLB.png" srcset="/img/loading.gif" lazyload alt="带快表的地址转换" /></p>
<h4 id="页面大小"><a class="markdownIt-Anchor" href="#页面大小"></a> 页面大小</h4>
<p><strong>缺页率: 发生缺页的次数与总访问次数的比值</strong></p>
<p>在<strong>基本内存管理</strong>中，因为没有虚存技术，因此程序执行时所有的页都必须在内存中，页面小并不会带来什么严重后果，反而<strong>页面越小，内部碎片的总量越少</strong><br />
然而在虚存中，页面越小，每个进程需要的页的数量越多，而页表也越大，<strong>一次内存访问可能产生两次缺页中断</strong>，因此页面大小会影响缺页率</p>
<p><img src="page_size.png" srcset="/img/loading.gif" lazyload alt="缺页率" /><br />
<img src="normal_page_size.png" srcset="/img/loading.gif" lazyload alt="常见页面大小" /></p>
<h4 id="虚拟分段"><a class="markdownIt-Anchor" href="#虚拟分段"></a> 虚拟分段</h4>
<p>虚拟分段与基本内存<a href="#%E5%88%86%E6%AE%B5">分段</a>几乎没有区别，仅仅段表项进行了一点改变，增加修改位、存在位等属性<br />
<strong>分段式逐渐被淘汰，虚拟分页为现代操作系统主流方式</strong></p>
<h4 id="段页式"><a class="markdownIt-Anchor" href="#段页式"></a> 段页式</h4>
<p><strong>段页式</strong>: 用户的地址空间<strong>被程序员划分为许多段</strong>，<strong>每段划分为许多固定大小的页</strong></p>
<ul>
<li>支持数据结构增长: 段长可变</li>
<li>支持共享和保护</li>
<li>消除外部碎片</li>
<li>有效利用内存</li>
</ul>
<b>
每个进程一个段表、一个页表
程序员的角度: 逻辑地址 = 段号 + 段内偏移量
系统的角度: 段内偏移量 = 页号 + 页内偏移量
</b>
<p><img src="page_segment_combination.png" srcset="/img/loading.gif" lazyload alt="段页式" /></p>
<ol>
<li>先根据<strong>段表起始地址(段寄存器)<strong>和</strong>段号</strong>查找段表，得到<strong>对应段的页表起始地址</strong></li>
<li>根据页表起始地址和页号查找页表，得到<strong>页框号</strong></li>
<li>页框号和偏移量构成物理地址</li>
</ol>
<p>因此段页式需要<strong>访存3次</strong>:</p>
<ul>
<li>第一次，访问段表，从中获得该段的页表首址</li>
<li>第二次，访问页表，从中取出逻辑地址指定的页面所在的页框号，并将该页框号和页内偏移量相加，形成物理地址</li>
<li>第三次，根据物理地址，取出对应存储单元的指令或数据</li>
</ul>
<p><img src="page_segment_combination_mapping.png" srcset="/img/loading.gif" lazyload alt="段页式逻辑地址转物理地址" /></p>
<h4 id="保护与共享"><a class="markdownIt-Anchor" href="#保护与共享"></a> 保护与共享</h4>
<p>分段有助于实现保护和共享机制:</p>
<ul>
<li><strong>保护</strong>: <strong>每个段都包括一个长度和一个基地址</strong>，可以控制非法访问(超出段长度会产生内存错误，不被处理器允许)</li>
<li><strong>共享</strong>: <strong>一个段可以在多个进程的段表中被引用</strong>，实现共享</li>
</ul>
<p>而分页对保护和共享并不友好:<br />
假定每个页面4KB，160KB的共享代码需要40个页面<br />
每个进程需要40个<strong>页表项</strong>来存储相应信息，开销160B(设定每个页表项4B)<br />
共享部分作为一个段，每个进程仅需1个<strong>段表项</strong>来存放共享段信息，开销4B</p>
<h3 id="操作系统对虚存的管理"><a class="markdownIt-Anchor" href="#操作系统对虚存的管理"></a> 操作系统对虚存的管理</h3>
<h4 id="读取策略"><a class="markdownIt-Anchor" href="#读取策略"></a> 读取策略</h4>
<p><strong>读取策略: 决定某页何时进入内存</strong></p>
<ul>
<li><strong>请求调页(Demand Paging)</strong>:
<ul>
<li><strong>仅在引用页面时</strong>，才把相应的页面调入内存</li>
<li>进程<strong>首次启动时</strong>，<strong>会发生很多缺页中断</strong></li>
<li>局部性原则表明，大多数将来访问的页面都是最近读取的页面，<strong>一段时间后，缺页中断会降低到很低的水平</strong></li>
</ul>
</li>
<li><strong>预调页(Prepaging)</strong>:
<ul>
<li><strong>额外读取所缺页面以外的页面</strong></li>
<li><strong>考虑大多数辅助储设备</strong>的特性: 寻道、旋转延迟等</li>
<li>若进程的页面<strong>连续存储在辅存</strong>中，则一次读取多个页面会<strong>更有效</strong></li>
<li>如果额外读取的页面未使用，则低效</li>
</ul>
</li>
</ul>
<h4 id="放置策略"><a class="markdownIt-Anchor" href="#放置策略"></a> 放置策略</h4>
<p><strong>放置策略: 确定进程驻留在内存中的位置</strong><br />
是分段系统中的重要设计内容，放置策略即动态分区中的<a href="#%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">匹配算法</a></p>
<h4 id="置换策略"><a class="markdownIt-Anchor" href="#置换策略"></a> 置换策略</h4>
<p><strong>置换策略: 读取新页时，若内存页面不足，具体淘汰哪个页面用以置换</strong></p>
<p>需要说明的是，OS提供<strong>页框锁定</strong>功能(对页框锁定位进行标记)，当页框被锁定时，当前存储在该页框中的页面不能被置换，一般用于保存<strong>操作系统内核</strong>和<strong>重要的数据结构</strong>，<strong>I/O缓冲区和时间要求严格的区域也可能保存在锁定的页框中</strong></p>
<p>常见置换策略:</p>
<ul>
<li>最优(OPT)</li>
<li>最近最少使用(LRU)</li>
<li>先进先出(FIFO)</li>
<li>时钟(Clock)</li>
</ul>
<h5 id="opt"><a class="markdownIt-Anchor" href="#opt"></a> OPT</h5>
<p>思想: <strong>置换下次访问距当前时间最长的页面</strong><br />
<img src="OPT.png" srcset="/img/loading.gif" lazyload alt="F表示所分配的页框在初始填满后产生缺页中断" /><br />
但是在实际情况中很难得知页的访问顺序，因此OPT策略几乎无法使用</p>
<h5 id="lru"><a class="markdownIt-Anchor" href="#lru"></a> LRU</h5>
<p>思想: <strong>置换内存中最长时间未引用的页面</strong>(原理为局部性原理)<br />
<img src="LRU.png" srcset="/img/loading.gif" lazyload alt="F表示所分配的页框在初始填满后产生缺页中断" /><br />
<strong>LRU的最大问题在于其开销大</strong>，需要每页添加最近访问时间戳或建立链表来<strong>记录访问</strong></p>
<h5 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h5>
<p>思想: <strong>将页框视为队列，置换驻留在内存中时间最长的页面</strong><br />
<img src="FIFO.png" srcset="/img/loading.gif" lazyload alt="F表示所分配的页框在初始填满后产生缺页中断" /><br />
实现简单</p>
<h5 id="clock"><a class="markdownIt-Anchor" href="#clock"></a> Clock</h5>
<p>思想: <strong>是一种最近未使用算法，置换的页面都是最近没有使用的那个</strong><br />
方法:</p>
<ul>
<li>每个页框关联一个使用位U(也称访问位)</li>
<li>当页面<strong>首次加载</strong>到内存中或<strong>被引用</strong>时，<strong>使用位U设置为1</strong></li>
<li>发生缺页中断时，检查表针指向页面
<ul>
<li>如果使用位为0，则<strong>新页面替换之</strong>，<strong>表针前移一个位置</strong></li>
<li>如果使用位为1，则<strong>清0</strong>，<strong>表针前移一个位置</strong></li>
<li><strong>一直循环，直到置换完成</strong></li>
</ul>
</li>
</ul>
<p><img src="Clock.png" srcset="/img/loading.gif" lazyload alt="F表示所分配的页框在初始填满后产生缺页中断，*表示使用位为1" /></p>
<p>改进的Clock策略<br />
除了使用位U，每个页框还有修改位M</p>
<ol>
<li>从指针当前位置开始扫描，这次扫描对使用位不作任何修改，选择遇到的第一个页框(U = 0, M = 0)置换</li>
<li>若第1步失败，重新扫描，选择遇到的第一个(U = 0, M = 1)的页框置换。这一过程中，将使每个扫描过的页框U置0</li>
<li>若第2步失败，则再次重新扫描，重复第1步，并在必要时重复第2步</li>
</ol>
<p>改进Clock置换的优先级(从高到低):</p>
<ul>
<li>(U = 0, M = 0)</li>
<li>(U = 1, M = 0)</li>
<li>(U = 0, M = 1)</li>
<li>(U = 1, M = 1)</li>
</ul>
<p><img src="efficiency.png" srcset="/img/loading.gif" lazyload alt="页框数与缺页率在不同置换策略下的关系" /><br />
可以看出LRU在实际情况中效果最好，FIFO效果最差并且可能出现Belay异常</p>
<h5 id="页缓冲"><a class="markdownIt-Anchor" href="#页缓冲"></a> 页缓冲</h5>
<p>置换的页，如果要写回辅存，代价较大，因此在内存中有一批专用页框，分别为<strong>空闲页</strong>和<strong>修改页</strong><br />
<strong>当有页需要被置换时，如果页未被修改，则放入空闲页链表的尾部，如果页已被修改，则放入修改页链表的尾部</strong><br />
<strong>空闲页链表满后仍然按照一定的置换策略进行置换，而修改页链表满后成批写回辅存</strong></p>
<p>对于较大的cache，如果置换页在cache中则会对性能产生影响，因为cache及内存中所对应的页<strong>都将失效</strong><br />
因此在使用页缓冲的系统中，可以<strong>从页缓冲区中选择任意页框来放置从而提高高速缓存性能</strong></p>
<h4 id="驻留集管理"><a class="markdownIt-Anchor" href="#驻留集管理"></a> 驻留集管理</h4>
<h5 id="驻留集大小"><a class="markdownIt-Anchor" href="#驻留集大小"></a> 驻留集大小</h5>
<p><strong>页框分配</strong>: 即给每个活动进行分配多少个页框</p>
<ul>
<li><strong>分配给每个进程的内存越小，可以驻留在内存中的进程越多</strong></li>
<li><strong>一个进程在内存中的页面少，则缺页率相对较高</strong></li>
<li>进程分配的页框数超出一定大小后，由于局部性原理，<strong>缺页率下降到稳定水平</strong></li>
</ul>
<p>页框分配有<strong>2种方式</strong>:</p>
<ul>
<li><strong>固定分配</strong>: 在内存中为进程提供<strong>固定数量的页框</strong>，发生缺页时，<strong>必须替换该进程的其中一个页面</strong></li>
<li><strong>可变分配</strong>: 允许分配给进程的页框数在进程的生命周期内变化，发生缺页时<strong>可以通过增加驻留集大小(即置换掉其他进程的页面)来调入页面</strong></li>
</ul>
<h5 id="置换范围"><a class="markdownIt-Anchor" href="#置换范围"></a> 置换范围</h5>
<p>置换范围: 计划置换的页集局限于产生<strong>缺页的进程本身(局部)</strong>，还是<strong>内存内的所有非锁定进程(全局)</strong></p>
<p><img src="residence_replace.png" srcset="/img/loading.gif" lazyload alt="组合" /></p>
<p><strong>固定分配，局部置换</strong></p>
<ul>
<li><strong>页框数大</strong>
<ul>
<li><strong>增加了处理器的空闲时间</strong>(内存中进程少)</li>
<li><strong>增加了花在交换上(swapping)的时间</strong></li>
</ul>
</li>
<li><strong>页框数小</strong>
<ul>
<li><strong>缺页率高</strong></li>
</ul>
</li>
</ul>
<p><strong>可变分配，全局置换</strong>，是主流方法</p>
<ul>
<li>实现容易</li>
<li>选择置换对象不当，将容易再次产生缺页中断(<strong>页缓冲可以缓解问题</strong>)</li>
</ul>
<p><strong>可变分配，局部置换</strong></p>
<ul>
<li>当缺页中断发生时，<strong>从进程驻留集中选择一页用于置换</strong></li>
<li>不时重新评估进程的页框分配情况，增加或减少分配的页框，以提高整体性能</li>
</ul>
<h5 id="工作集"><a class="markdownIt-Anchor" href="#工作集"></a> 工作集</h5>
<p><strong>工作集</strong>: 进程在虚拟时间t的参数为Δ的工作集W(t, Δ)，表示<strong>该进程在从t开始往前的的Δ个虚拟时间单位被访问到的页集合</strong><br />
虚拟时间窗口Δ越大，则工作集越大</p>
<p><img src="working_set.png" srcset="/img/loading.gif" lazyload alt="工作集示例" /></p>
<p>对于固定的Δ，工作集大小随时间变化的情况: <strong>稳定阶段和快速变化阶段交替出现</strong><br />
<img src="time_working_set.png" srcset="/img/loading.gif" lazyload alt="工作集大小变化" /></p>
<p>根据工作集来决定驻留集的大小: <strong>周期性的从驻留集中移去不在工作集中的页(近似LRU)</strong></p>
<h4 id="清除策略"><a class="markdownIt-Anchor" href="#清除策略"></a> 清除策略</h4>
<p><strong>清除策略: 用于确定何时将修改过的页写回辅存</strong></p>
<ul>
<li><strong>按需清除(Demand Cleaning)</strong>: <strong>只有当一页被选择用于置换时才被写回辅存</strong>，发生缺页中断的进程在解除阻塞前需等待两次页传送(没有页缓冲): 写回修改页+读入新页</li>
<li><strong>预清除(Precleaning)</strong>: 将<strong>修改的多页</strong>在需要使用它们占据页框之前，<strong>成批写回辅存</strong>，但预先写回辅存的页，在置换前可能又会被修改，使得预清除意义不大</li>
</ul>
<p><strong>结合页缓冲技术后，只清除用于置换的页，已修改表中的页可以成批写回辅存</strong></p>
<h4 id="负载控制"><a class="markdownIt-Anchor" href="#负载控制"></a> 负载控制</h4>
<p><strong>负载控制: 决定驻留在内存中的进程的数量</strong></p>
<ul>
<li><strong>L=S准则</strong>: <strong>发生缺页的平均时间L等于处理缺页故障的平均时间S，此时处理器的利用率最大</strong></li>
<li><strong>监测Clock算法中指针扫描的速度</strong>:
<ul>
<li>速度低，缺页率低，增加多道程序度</li>
<li>速度高，缺页率高或多道程序度高，降低多道程序度</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Operating-System/">Operating System</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/13/I-O%E7%AE%A1%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">I/O管理与磁盘调度</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/10/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">
                        <span class="hidden-mobile">进程管理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Thm-lab/blog_commit');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
