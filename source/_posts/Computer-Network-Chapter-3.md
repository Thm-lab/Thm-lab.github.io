---
title: Computer Network Chapter 3
date: 2022-05-26 13:31:31
tags: Computer Network
math: true
---

# Chapter 3: Transport Layer

## Transport Layer Services(传输层服务)
传输层服务: 为在两个不同的主机上运行的应用程序之间提供**逻辑通信**。
传输层协议运行在端系统，发送方将应用程序报文分成数据段传递给网络层，接收方将数据段重新组装成报文传递到应用层。
在Internet上传输层主要有2个协议: 
- TCP: 提供的服务有: 
    - 连接建立
    - 可靠按序递交
    - 拥塞控制
    - 流量控制
- UDP: "尽力传递"，是IP的直接扩展，不提供其他服务。
**说明**: TCP和UDP均不能提供延迟保证和带宽保证

## Multiplexing and Demultiplexing(多路复用和多路分解)
多路分解发生在接受主机上，传输层将接收到的数据段传递到正确的套接字即为多路分解。
多路复用发生在发送主机上，传输层从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层即为多路复用。  
多路的意思即是将一个数据段分给不同应用层的socket，因为同时可能会存在多个socket但都被封装为了数据段的格式。
![Multiplexing and Demultiplexing](multiplexing_demultiplexing.png)

### Demultiplexing Working Principle(多路分解工作原理)
主机从网络层收到IP数据报，每个数据报搬运一个数据段，每个数据段有源和目的端口号，主机用数据报中的IP地址和数据段的端口号来指明数据段属于哪个合适的套接字。

- 无连接多路分解(UDP): UDP套接字由两个因素指定:(目的IP地址, 目的端口号)。当主机收到UDP数据段时，检查数据段中的目的端口号并且用端口号指示UDP数据段属于哪个套接字。
**具有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字。**
![UDP Demultiplexing](udp_demultiplexing.svg)
从上图可以看到，来自不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号的IP数据报指向同样的套接字。

- 面向连接的多路分解(TCP): TCP套接字由两个因素指定:(源IP地址, 源端口号, 目的IP地址, 目的端口号)。**接收主机使用所有四个值将数据段定位到合适的套接字。**
![TCP Demultiplexing](tcp_demultiplexing.svg)
与UDP不同的是，即便是目的IP地址和目的端口号相同，但源IP地址和源端口号不同的IP数据报需要指向不同的套接字。

## Connectionless Transport: UDP(无连接传输: UDP)
"无修饰","不加渲染的"因特网传输层协议。"尽最大努力"服务, UDP数据段可能: 丢失，会传递失序的报文到应用程序。
UDP的特点: 
- 不需要建立连接 (减少延迟)
- 简单: 在发送者接受者之间不需要连接状态
- 很小的数据段首部(8B)
- 没有拥塞控制: UDP 能够用想象的快的速度传递

### UDP Segment Structure(UDP数据段结构)
![UDP Segment Structure](udp.svg)
**特别的:** UDP数据段的首部长度为**8B**，而不是TCP的20B。并且UDP数据段的首部中长度属性为整个UDP数据段的长度。

### UDP checksum(UDP校验和)
目标: 检测传输的数据段的"错误"(如bit丢失,bit错误)
计算方法: 
- 发送方: 将整个数据段(此时校验和位还没有产生)看成16bit的序列，将整个数据段视为16bit的序列，依次相加，如果有溢出需要将溢出回卷到最低位，将最终结果取反得到校验和。
- 接收方: 使用与校验和的计算方法将整个数据段(包括校验和)按照16bit的序列全部加起来(中间出现溢出也需要回卷)，若全为1则通过了校验和检验，但仍可能出现错误，若不全为1则一定出现了错误。
![example](checksum_example.svg)

## Principles of Reliable Data Transfer(可靠数据传输原理)

### RDT发展过程

#### RDT1.0
RDT1.0: 完全可靠信道上的可靠数据传输。
前提: 
- 完全可靠信道上不会出现bit错误
- 完全可靠信道上不会出现分组丢失
在完全可靠信道上进行可靠数据传输十分简单，发送方只需要将数据发送到下层信道，接收方从下层信道上获取数据即可完成可靠数据传输。

#### RDT2.0
但完全可靠信道几乎不可能出现，RDT2.0: 具有bit错误的信道，但不会出现分组丢失。在RDT2.0上实现可靠数据传输需要提供新的机制: 
- 差错检验
- 接收方反馈
- 发送方重传

为实现上述机制，需要明确指出当接收方发现bit错误时的处理方法。以下为RDT2.0的有限自动机示意图:
![RDT2.0](rdt2.0.svg)
- 发送方: 将数据发送到下层信道，然后等待接收方反馈的ACK(正确收信息到)或NAK(错误收到信息)，若接收到ACK则继续发送下个包，若接收到NAK则重新发送上个包。
- 接收方: 从下层信道获取数据，通过UDP或TCP中的校验和来检测是否发生bit错误，若无发生bit错误则向发送方发送ACK并且继续接收，若发生bit错误则向发送方发送NAK然后重新接收数据直到收到正确数据。

但RDT2.0存在致命缺陷，即ACK与NAK可能发生混淆即ACK或NAK在向发送方传输过程中也有可能出现bit错误，这个问题由RDT2.1来解决。

#### RDT2.1
RDT2.1为处理ACK或NAK混淆问题，选择在收到ACK或NAK时同样进行校验和检验，若检验和正确则按RDT2.0的方式处理，若检验和错误则发生了bit错误，需要重新发送上一包。但这样会存在ACK发生了bit错误但发送方又重新发送了一次的情况，为避免重复，**RDT2.1需要给每个分组加上序号**，当接收方收到相同序号的数据段时会将其丢弃。
![RDT2.1 Sender](rdt2.1_sender.svg)
![RDT2.1 Receiver](rdt2.1_receiver.svg)
**这里需要提出一个新的概念，停-等协议: 发送方发送一个报文，然后等待接受方的响应。** 可以发现RDT2.0和RDT2.1均为停-等协议，由此可以引发以下思考。

仔细观察上方图中RDT2.1的sender和receiver可以看出，发送方附加的序号其实并非是数据包的唯一标识，而是只需要在0和1之间进行选择即可，这个特点是取决于停-等协议而产生的，只有确定了发送成功才会更新序号，因此只需要2个序号就可以完全满足识别的需求。同时由于停-等协议的特点，此时也不会出现后发出的包先被交付给上层的情况即数据包乱序问题。  

#### RDT2.2
RDT2.2的特点在于取消了RDT2.0提出的NAK机制，由于RDT2.1中给每个分组加上了序号，因此在停-等协议中，接收方只需要在ACK中回复收到的数据包的序号即可实现ACK和NAK的功能。例如: sender发送了序号为0的包，receiver正确收到了序号为0的包则回复为0的ACK，若收到的数据包出现了bit错误，则回复为1的ACK。而接收方如果收到了与发送序号相同的ACK则为发送成功，若收到了与发送序号不同的ACK则为发送失败，需要重新发送。
![RDT2.2 Sender](rdt2.2_sender.jpg)
![RDT2.2 Receiver](rdt2.2_receiver.jpg)

#### RDT3.0
RDT1.0: 具有bit出错和分组丢失的信道。与RDT2.0解决出现bit错误一样，当出现分组丢失的可能后需要引入新的机制来保障数据的可靠传输。在RDT3.0中选择的是倒计时定时器机制来实现保障。
定时器的工作原理: 
![Principle of RDT3.0](rdt3.0_1.svg)
![Principle of RDT3.0](rdt3.0_2.svg)
由上面两张图可以看出，引入定时器后情况会立马复杂很多，在上面展示了4种可能出现的情况，为便于理解需要全部掌握。
1. 没有发生任何错误: 这是最为简单的情况，当没有发生任何错误时，RDT3.0与RDT2.2工作过程是完全相同的。
2. 发生了分组丢失: 发生了分组丢失后，对接收方其实没有任何影响，因此接收方不会返回ACK，当超过定时器规定的时间后发送方仍然没有收到ACK的话，发送方则会进行重传，并且重置定时器。
3. 发生了ACK丢失: 此时接收方是已经收到了分组，并且向发送方发送了ACK(无论是要求发送方重传还是发送成功)，但是由于ACK的丢失，在到达定时器规定的时间后发送方会认为本次发送失败于是会重新发送该分组，并且重置定时器。在收到重新发送的分组后接收方会发现已经收到了该分组，则会丢弃分组并且回复ACK。
4. 发生了ACK阻塞: 此时接收方是已经收到了分组，并且向发送方发送了ACK(无论是要求发送方重传还是发送成功)，但是由于ACK的阻塞，在到达定时器规定的时间后发送方仍然没有收到ACK会认为本次发送失败于是会重新发送该分组，并且重置定时器。在收到重新发送的分组后接收方会发现已经收到了该分组，则会丢弃分组并且回复ACK。

其实我认为定时器机制下只有2位的序号是无法保障可靠数据传输的，特别是在ACK发生阻塞的情况下，极有可能发生出现了错误但没有纠正回来的情况。但是在课程中并没有做深入的讨论，我认为RDT的发展过程只是为我们实现可靠数据传输提供一个思路，并且在实际实现中TCP的可靠数据传输是比RDT3.0更复杂一些的，因此无需过于纠结本节的不完美之处。

### Pipeline(流水线技术)
RDT3.0的效率其实是非常低的，当数据在传播时和接收方进行处理和回复的过程中的时间是被浪费的同时还有停-等协议要求的定时器等待时间也被白白浪费了，因此出现了流水线的方法来提高传输效率，就跟HTTP中的流水线一样。
流水线: 发送方允许发送多个"在路上的", 还没有确认的报文。但使用流水线技术对传输新增了以下要求: 
- 用于标志分组序号的范围应当增加，因为采用流水线技术后不再能通过2位的序号来标志分组的唯一性。
- 发送方/接收方需要有缓冲区，由于采用流水线方法后，分组存在不按序到达的情况，但上层要求按序递交因此需要将先到的后序分组缓冲起来等待前面分组到达后再行递交。
![流水线](pipeline.svg)
这里出现了一个很重要的概念: **发送窗口长度**，即流水线操作中允许的最大未确认分组数量。从上面流水线运行示意图可以看到，利用率为相对于RDT3.0利用率的发送窗口倍，发送窗口越大利用率越大直到发送窗口对应分组传输时延大于一个RTT的时间。

#### Go-Back-N(滑动窗口)
在分组头中规定一个k位的序号。
- 发送方: 发放方为最早未被确认的分组启动定时器，然后发送所有在发送窗口内的分组，直到发送窗口内的分组全部发送完毕。当收到ACK为n时，确认所有的报文直到(包含)序号n。若定时器超时，则重发窗口中的报文n及以上更高序号的报文(只有一个定时器记录最早的未被确认报文的发送时间)。
![滑动窗口](gbn.svg)
- 接收方: 发送累积ACK，假如收到分组与前面的分组之间有间隙，则不发送ack且丢弃失序分组(因此接收方无需缓冲区)。
![example](gbn_example.svg)

<b>重要说明: GBN的窗口大小为$2^k-1$(k为序号位数)</b>

#### Selective Repeat(选择性重传)
在分组头中规定一个k位的序号。
- 发送方: 发送方需要对每个没有确认的报文都要启动一个定时器(每个未被确认的报文都有一个定时器)，并只重发没有收到确认的分组。
![选择性重传](sr.svg)
- 接收方: 接收方分别确认已经收到的分组，必要(收到分组并非按序)时，缓冲分组, 最后按序提交给上层。
![example](sr_example.svg)
<b>重要说明: SR的窗口大小为$\frac{2^k}{2}$(k为序号位数)即发送窗口长度小于等于序号空间</b>

## Principles of Congestion Control(拥塞控制原理)